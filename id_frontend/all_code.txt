

/* ===== C:\Users\icipa\team-platform-public\id_frontend\Dockerfile ===== */

# id_frontend/Dockerfile
FROM node:20-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN npm ci
ARG VITE_API_BASE=/idp
ARG VITE_CLIENT_ID=id_frontend
ENV VITE_API_BASE=$VITE_API_BASE
ENV VITE_CLIENT_ID=$VITE_CLIENT_ID
COPY . .
RUN npm run build

# serve
FROM nginx:1.27-alpine
COPY --from=build /app/dist /usr/share/nginx/html
# SPA fallback + кэш ассетов
COPY nginx.conf /etc/nginx/conf.d/default.conf
EXPOSE 80



/* ===== C:\Users\icipa\team-platform-public\id_frontend\eslint.config.js ===== */

import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { globalIgnores } from 'eslint/config'

export default tseslint.config([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])



/* ===== C:\Users\icipa\team-platform-public\id_frontend\index.html ===== */

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Asynq ID</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>



/* ===== C:\Users\icipa\team-platform-public\id_frontend\package.json ===== */

{
  "name": "id_frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "axios": "^1.11.0",
    "react": "^19.1.1",
    "react-dom": "^19.1.1",
    "react-router-dom": "^7.8.1"
  },
  "devDependencies": {
    "@eslint/js": "^9.33.0",
    "@types/react": "^19.1.10",
    "@types/react-dom": "^19.1.7",
    "@vitejs/plugin-react": "^5.0.0",
    "eslint": "^9.33.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.20",
    "globals": "^16.3.0",
    "sass": "^1.90.0",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.39.1",
    "vite": "^7.1.2"
  }
}



/* ===== C:\Users\icipa\team-platform-public\id_frontend\src\api\client.ts ===== */

// ============= src/api/client.ts =============
import axios, {
  type AxiosInstance,
  type AxiosError,
  type InternalAxiosRequestConfig,
  AxiosHeaders,
} from 'axios'
import { type TokenResponse } from '../types/oauth.types'
import {
  TOKEN_STORAGE_KEY,
  REFRESH_TOKEN_STORAGE_KEY,
  ID_TOKEN_STORAGE_KEY,
} from '../utils/constants'

const API_BASE = import.meta.env.VITE_API_BASE ?? '' // '' в dev, '/idp' в prod

class ApiClient {
  private client: AxiosInstance
  private refreshPromise: Promise<TokenResponse> | null = null
  private csrfToken: string | null = null

  constructor() {
    this.client = axios.create({
      baseURL: API_BASE,
      timeout: 30000,
      headers: { 'Content-Type': 'application/json' },
      withCredentials: true,
    })
    this.setupInterceptors()
  }

  // ---------- Interceptors ----------
  private setupInterceptors() {
    this.client.interceptors.request.use(async (config) => {
      const headers = (config.headers ??= new AxiosHeaders(config.headers))
      const token = this.getAccessToken()
      if (token) headers.set('Authorization', `Bearer ${token}`)

      if (this.needsCsrf(config)) {
        // лениво получаем CSRF из ответа или cookie
        if (!this.csrfToken && !this.getCookie('csrf_token')) {
          await this.fetchCsrf()
        }
        const csrf = this.csrfToken || this.getCookie('csrf_token')
        if (csrf) headers.set('X-CSRF-Token', csrf)

      }
      return config
    })

    

    this.client.interceptors.response.use(
      (r) => r,
      async (error: AxiosError) => {
        const original = error.config as (InternalAxiosRequestConfig & { _retry?: boolean }) | undefined
        const status = error.response?.status
        const url = original?.url || ''

        // Не пытаемся рефрешить /oauth/token|/oauth/revoke и избегаем циклов
        const isTokenEndpoint = url.startsWith('/token') || url.startsWith('/revoke')
        if (status === 401 && original && !original._retry && !isTokenEndpoint && this.getRefreshToken()) {

          original._retry = true
          try {
            await this.refreshToken()
            const token = this.getAccessToken()
            if (token && original.headers) (original.headers as AxiosHeaders).set('Authorization', `Bearer ${token}`)
            return this.client(original)
          } catch (e) {
            this.clearTokens()
            window.location.href = '/login'
            throw e
          }
        }
        throw error
      }
    )
  }

  private async fetchCsrf(): Promise<string | null> {
    try {
      const resp = await this.client.get('/api/auth/csrf', {
        headers: { 'X-Requested-With': 'XMLHttpRequest' },
      })
      const headers = resp.headers as any
      const fromHeader = headers['x-csrf-token'] || headers['x-csrf']
      const body: any = resp.data
      const fromBody = body?.csrf || body?.csrf_token || body?.token
      const fromCookie = this.getCookie('csrf_token')
      const token = fromHeader || fromBody || fromCookie || null
      this.csrfToken = token
      return token
    } catch {
      return null
    }
  }


  // ---------- Helpers ----------
  private getAccessToken() {
    return localStorage.getItem(TOKEN_STORAGE_KEY)
  }
  private getRefreshToken() {
    return localStorage.getItem(REFRESH_TOKEN_STORAGE_KEY)
  }
  private setTokens(tokens: TokenResponse) {
    localStorage.setItem(TOKEN_STORAGE_KEY, tokens.access_token)
    if (tokens.refresh_token) localStorage.setItem(REFRESH_TOKEN_STORAGE_KEY, tokens.refresh_token)
    if (tokens.id_token) localStorage.setItem(ID_TOKEN_STORAGE_KEY, tokens.id_token)
  }
  private clearTokens() {
    localStorage.removeItem(TOKEN_STORAGE_KEY)
    localStorage.removeItem(REFRESH_TOKEN_STORAGE_KEY)
    localStorage.removeItem(ID_TOKEN_STORAGE_KEY)
  }

  private getCookie(name: string): string | null {
    const m = document.cookie.match(new RegExp('(?:^|; )' + name.replace(/([.$?*|{}()[\]\\/+^])/g, '\\$1') + '=([^;]*)'))
    return m ? decodeURIComponent(m[1]) : null
  }

private needsCsrf(config: InternalAxiosRequestConfig): boolean {
  const method = (config.method ?? 'get').toUpperCase()
  if (method === 'GET' || method === 'HEAD' || method === 'OPTIONS') return false
  const url = config.url ?? ''

  // исключения
  if (
    url.startsWith('/token') ||            url.startsWith('/revoke') ||       
    url.startsWith('/api/auth/csrf') ||
    url.startsWith('/.well-known') ||
    url.startsWith('/health')
  ) { return false }

  // вот здесь добавляем oauth/authorize (закроет POST /oauth/authorize/consent)
  return (
    url.startsWith('/api/auth/') ||
    url.startsWith('/api/account/') ||
    url.startsWith('/authorize')
    // при необходимости — если logout у вас под CSRF:
    // || url.startsWith('/api/session/')
  )
}

  // ---------- Refresh ----------
  private async refreshToken(): Promise<TokenResponse> {
    if (this.refreshPromise) return this.refreshPromise

    const refreshToken = this.getRefreshToken()
    if (!refreshToken) throw new Error('No refresh token')

    const body = new URLSearchParams({
      grant_type: 'refresh_token',
      refresh_token: refreshToken,
      // Для public-клиента client_id обязателен
      client_id: import.meta.env.VITE_CLIENT_ID || 'id_frontend',
    })

      this.refreshPromise = this.client
        .post<TokenResponse>('/token', body, {
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        })
      .then(({ data }) => {
        this.setTokens(data)
        this.refreshPromise = null
        return data
      })
      .catch((e) => {
        this.refreshPromise = null
        throw e
      })

    return this.refreshPromise
  }

  // ---------- Public API ----------
  getClient() {
    return this.client
  }
  saveTokens(tokens: TokenResponse) {
    this.setTokens(tokens)
  }
  logout() {
    this.clearTokens()
  }
}

export const apiClient = new ApiClient()
export const api = apiClient.getClient()



/* ===== C:\Users\icipa\team-platform-public\id_frontend\src\api\endpoints.ts ===== */

// ============= src/api/endpoints.ts =============

export const API_ENDPOINTS = {
  // Auth endpoints
  AUTH: {
    LOGIN: '/api/auth/login',
    REGISTER: '/api/auth/register',
    VERIFY_EMAIL: '/api/auth/verify-email',
    RESEND_CODE: '/api/auth/resend-code',
    FORGOT_PASSWORD: '/api/auth/forgot-password',
    RESET_PASSWORD: '/api/auth/reset-password',
    ME: '/api/account/profile',
  },
  
  // OAuth endpoints
  OAUTH: {
    AUTHORIZE: '/authorize',
    TOKEN: '/token',
    USERINFO: '/userinfo',
    REVOKE: '/revoke',
    CONSENT: '/authorize/consent',
    JWKS: '/.well-known/jwks.json',
    DISCOVERY: '/.well-known/openid-configuration',
  },

  
  // Session endpoints
  SESSION: {
    LOGOUT: '/api/session/logout',
    STATUS: '/api/session/status',
  },
  
  // Client endpoints
  CLIENTS: {
    GET: (clientId: string) => `/api/clients/${clientId}`,
  },
};


/* ===== C:\Users\icipa\team-platform-public\id_frontend\src\App.tsx ===== */

import { useState } from 'react'
import reactLogo from './assets/react.svg'
import viteLogo from '/vite.svg'
import './app.scss'

function App() {
  const [count, setCount] = useState(0)

  return (
    <>
      <div>
        <a href="https://vite.dev" target="_blank">
          <img src={viteLogo} className="logo" alt="Vite logo" />
        </a>
        <a href="https://react.dev" target="_blank">
          <img src={reactLogo} className="logo react" alt="React logo" />
        </a>
      </div>
      <h1>Vite + React</h1>
      <div className="card">
        <button onClick={() => setCount((count) => count + 1)}>
          count is {count}
        </button>
        <p>
          Edit <code>src/App.tsx</code> and save to test HMR
        </p>
      </div>
      <p className="read-the-docs">
        Click on the Vite and React logos to learn more
      </p>
    </>
  )
}

export default App



/* ===== C:\Users\icipa\team-platform-public\id_frontend\src\components\AuthForm\LoginForm.tsx ===== */

// ============= src/components/AuthForm/LoginForm.tsx =============

import React, { useState } from 'react';
import { Link } from 'react-router-dom';
import { validators } from '../../utils/validators';
import { handleApiError } from '../../utils/errors';
import { ROUTES } from '../../utils/constants';
import { useAuth } from '../../hooks/useAuth'

interface LoginFormProps {
  onSuccess?: () => void;
  redirectUrl?: string;
}

export const LoginForm: React.FC<LoginFormProps> = ({ onSuccess, redirectUrl }) => {
  const [formData, setFormData] = useState({
    email: '',
    password: '',
  });
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [isLoading, setIsLoading] = useState(false);
  const [generalError, setGeneralError] = useState('');
  const { login } = useAuth();

  const handleChange = (field: string, value: string) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    // Очищаем ошибку поля при изменении
    if (errors[field]) {
      setErrors(prev => ({ ...prev, [field]: '' }));
    }
    if (generalError) {
      setGeneralError('');
    }
  };

  const validateForm = (): boolean => {
    const newErrors: Record<string, string> = {};
    
    const emailValidation = validators.email(formData.email);
    if (!emailValidation.isValid) {
      newErrors.email = emailValidation.error!;
    }
    
    const passwordValidation = validators.password(formData.password);
    if (!passwordValidation.isValid) {
      newErrors.password = passwordValidation.error!;
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!validateForm()) return;
    
    setIsLoading(true);
    setGeneralError('');
    
    try {
      await login(formData.email, formData.password)   // было: authService.login(formData)
      if (onSuccess) onSuccess()
      else if (redirectUrl) window.location.href = redirectUrl
      else window.location.href = ROUTES.PROFILE
    } catch (error) {
      setGeneralError(handleApiError(error))
    } finally {
      setIsLoading(false)
    }
  };

  return (
    <form className="auth-form" onSubmit={handleSubmit}>
      <h1 className="auth-form__title">Вход</h1>
      
      {generalError && (
        <div className="auth-form__error">
          {generalError}
        </div>
      )}
      
      <div className="auth-form__field">
        <input
          type="email"
          placeholder=" "
          value={formData.email}
          onChange={(e) => handleChange('email', e.target.value)}
          className={`auth-form__input ${errors.email ? 'auth-form__input--error' : ''}`}
          disabled={isLoading}
          autoFocus
        />
        <span className="auth-form__placeholder">Email</span>
        {errors.email && (
          <span className="auth-form__field-error">{errors.email}</span>
        )}
      </div>
      
      <div className="auth-form__field">
        <input
          type="password"
          placeholder=" "
          value={formData.password}
          onChange={(e) => handleChange('password', e.target.value)}
          className={`auth-form__input ${errors.password ? 'auth-form__input--error' : ''}`}
          disabled={isLoading}
        />
        <span className="auth-form__placeholder">Пароль</span>
        {errors.password && (
          <span className="auth-form__field-error">{errors.password}</span>
        )}
      </div>
      
      <div className="auth-form__links">
        <Link to={ROUTES.REGISTER} className="auth-form__link auth-form__link--register">
          Создать аккаунт
        </Link>
        <Link to={ROUTES.FORGOT_PASSWORD} className="auth-form__link auth-form__link--forgot">
          Забыли пароль?
        </Link>
      </div>
            
      <button
        type="submit"
        className="auth-form__submit"
        disabled={isLoading}
      >
        {isLoading ? (
          <span className="auth-form__submit-spinner" />
        ) : (
          'Войти'
        )}
      </button>
    
    </form>
  );
};



/* ===== C:\Users\icipa\team-platform-public\id_frontend\src\components\AuthForm\RegisterForm.tsx ===== */

/* ============= src/components/AuthForm/RegisterForm.tsx ============= */

import React, { useState } from 'react'
import { Link, useNavigate } from 'react-router-dom'
import { authService } from '../../services/auth.service'
import { validators, isWeakPassword } from '../../utils/validators'
import { handleApiError } from '../../utils/errors'
import { ROUTES } from '../../utils/constants'

interface RegisterFormProps {
  onSuccess?: (userId: string, email: string) => void
}

export const RegisterForm: React.FC<RegisterFormProps> = ({ onSuccess }) => {
  const navigate = useNavigate()
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: '',
    passwordConfirm: '',
  })
  const [errors, setErrors] = useState<Record<string, string>>({})
  const [isLoading, setIsLoading] = useState(false)
  const [generalError, setGeneralError] = useState('')
  const [weakPassword, setWeakPassword] = useState(false)
  const [submitted, setSubmitted] = useState(false)

  const handleChange = (field: string, value: string) => {
    setFormData((prev) => ({ ...prev, [field]: value }))
    if (errors[field]) setErrors((prev) => ({ ...prev, [field]: '' }))
    if (generalError) setGeneralError('')
    if (field === 'password') setWeakPassword(false)
  }

  const validateForm = (): boolean => {
    const newErrors: Record<string, string> = {}
    const u = validators.username(formData.username); if (!u.isValid) newErrors.username = u.error!
    const e = validators.email(formData.email); if (!e.isValid) newErrors.email = e.error!
    const p = validators.password(formData.password); if (!p.isValid) newErrors.password = p.error!
    const pc = validators.passwordConfirm(formData.password, formData.passwordConfirm); if (!pc.isValid) newErrors.passwordConfirm = pc.error!
    setErrors(newErrors)
    return Object.keys(newErrors).length === 0
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setSubmitted(true)

    if (!validateForm()) return
    if (isWeakPassword(formData.password)) { setWeakPassword(true); return }

    setIsLoading(true)
    setGeneralError('')

    try {
      const r = await authService.register({
        username: formData.username,
        email: formData.email,
        password: formData.password,
        password_confirm: formData.passwordConfirm,
      })

      if (r.requires_verification) {
        const url = `${ROUTES.VERIFY_EMAIL}?user_id=${r.user_id}&email=${encodeURIComponent(r.email)}`
        onSuccess ? onSuccess(r.user_id, r.email) : navigate(url)
      } else {
        navigate(ROUTES.LOGIN)
      }
    } catch (error) {
      setGeneralError(handleApiError(error))
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <form className={`auth-form ${submitted ? 'auth-form--submitted' : ''}`} onSubmit={handleSubmit}>
      <h1 className="auth-form__title">Регистрация</h1>

      {generalError && <div className="auth-form__error">{generalError}</div>}

      <div className="auth-form__field">
        <input
          type="text"
          placeholder=" "
          value={formData.username}
          onChange={(e) => handleChange('username', e.target.value)}
          className={`auth-form__input ${errors.username ? 'auth-form__input--error' : ''}`}
          disabled={isLoading}
          autoFocus
        />
        <span className="auth-form__placeholder">Имя пользователя</span>
        {errors.username && <span className="auth-form__field-error">{errors.username}</span>}
      </div>

      <div className="auth-form__field">
        <input
          type="email"
          placeholder=" "
          value={formData.email}
          onChange={(e) => handleChange('email', e.target.value)}
          className={`auth-form__input ${errors.email ? 'auth-form__input--error' : ''}`}
          disabled={isLoading}
        />
        <span className="auth-form__placeholder">Email</span>
        {errors.email && <span className="auth-form__field-error">{errors.email}</span>}
      </div>

      <div className={`auth-form__field auth-form__field--password ${weakPassword ? 'is-weak' : ''}`}>
        <input
          type="password"
          placeholder=" "
          value={formData.password}
          onChange={(e) => handleChange('password', e.target.value)}
          className={`auth-form__input ${errors.password ? 'auth-form__input--error' : ''}`}
          disabled={isLoading}
        />
        <span className="auth-form__placeholder">Пароль</span>
        {errors.password && <span className="auth-form__field-error">{errors.password}</span>}
      </div>

      <div className="auth-form__field">
        <input
          type="password"
          placeholder=" "
          value={formData.passwordConfirm}
          onChange={(e) => handleChange('passwordConfirm', e.target.value)}
          className={`auth-form__input ${errors.passwordConfirm ? 'auth-form__input--error' : ''}`}
          disabled={isLoading}
        />
        <span className="auth-form__placeholder">Повторите пароль</span>
        {errors.passwordConfirm && <span className="auth-form__field-error">{errors.passwordConfirm}</span>}
      </div>

      <div className="auth-form__links">
        <Link to={ROUTES.LOGIN} className="auth-form__link auth-form__link--register">Войти в аккаунт</Link>
      </div>

      <button type="submit" className="auth-form__submit" disabled={isLoading}>
        {isLoading ? <span className="auth-form__submit-spinner" /> : 'Зарегистрироваться'}
      </button>
    </form>
  )
}



/* ===== C:\Users\icipa\team-platform-public\id_frontend\src\components\CodeInput\CodeInput.tsx ===== */

// ============= src/components/CodeInput/CodeInput.tsx =============

import React, { useState, useRef, useEffect } from 'react';
interface CodeInputProps {
  length?: number;
  onChange: (code: string) => void;
  onComplete?: (code: string) => void;
  error?: boolean;
  disabled?: boolean;
  autoFocus?: boolean;
}

export const CodeInput: React.FC<CodeInputProps> = ({
  length = 4,
  onChange,
  onComplete,
  error = false,
  disabled = false,
  autoFocus = true,
}) => {
  const [values, setValues] = useState<string[]>(new Array(length).fill(''));
  const inputRefs = useRef<(HTMLInputElement | null)[]>([]);

  useEffect(() => {
    if (autoFocus && inputRefs.current[0]) {
      inputRefs.current[0].focus();
    }
  }, [autoFocus]);

  const handleChange = (index: number, value: string) => {
    if (disabled) return;

    // Разрешаем только цифры
    const numericValue = value.replace(/[^0-9]/g, '');
    
    if (numericValue.length <= 1) {
      const newValues = [...values];
      newValues[index] = numericValue;
      setValues(newValues);
      
      const code = newValues.join('');
      onChange(code);
      
      // Переход к следующему полю
      if (numericValue && index < length - 1) {
        inputRefs.current[index + 1]?.focus();
      }
      
      // Вызываем onComplete если все поля заполнены
      if (code.length === length && onComplete) {
        onComplete(code);
      }
    }
  };

  const handleKeyDown = (index: number, e: React.KeyboardEvent<HTMLInputElement>) => {
    if (disabled) return;

    if (e.key === 'Backspace' && !values[index] && index > 0) {
      inputRefs.current[index - 1]?.focus();
    }
  };

  const handlePaste = (e: React.ClipboardEvent) => {
    if (disabled) return;
    
    e.preventDefault();
    const pastedData = e.clipboardData.getData('text/plain').replace(/[^0-9]/g, '').slice(0, length);
    const newValues = [...values];
    
    for (let i = 0; i < pastedData.length; i++) {
      newValues[i] = pastedData[i];
    }
    
    setValues(newValues);
    const code = newValues.join('');
    onChange(code);
    
    // Фокус на последнее заполненное поле или следующее пустое
    const lastFilledIndex = Math.min(pastedData.length - 1, length - 1);
    inputRefs.current[lastFilledIndex]?.focus();
    
    if (code.length === length && onComplete) {
      onComplete(code);
    }
  };

  return (
    <div className={`code-input ${error ? 'code-input--error' : ''} ${disabled ? 'code-input--disabled' : ''}`}>
      {values.map((value, index) => (
        <input
          key={index}
          ref={(el) => { inputRefs.current[index] = el; }}  
          type="text"
          inputMode="numeric"
          maxLength={1}
          value={value}
          onChange={(e) => handleChange(index, e.target.value)}
          onKeyDown={(e) => handleKeyDown(index, e)}
          onPaste={handlePaste}
          disabled={disabled}
          className="code-input__field"
          autoComplete="off"
        />
      ))}
    </div>
  );
};


/* ===== C:\Users\icipa\team-platform-public\id_frontend\src\components\Layout\Layout.tsx ===== */

// ============= src/components/Layout/Layout.tsx =============

import React from 'react';
import { useAuth } from '../../hooks/useAuth';

interface LayoutProps {
  children: React.ReactNode;
  showLogo?: boolean;
}

export const Layout: React.FC<LayoutProps> = ({ children, showLogo = true }) => {
  const { logout } = useAuth();
  return (
    <div className="layout">
              {showLogo && (
        <div className="id-badge">
            <div className="id-icon">
              <svg width="23" height="22" viewBox="0 0 23 22" xmlns="http://www.w3.org/2000/svg">
                <path d="M16.4131 19.3398L12.4463 13.0098L12.082 12.4287L11.6406 12.9531L7.85742 17.4482L7.73926 17.5879V20.9697H3.66211L4.19629 16.7354L9.09277 11.2275L9.51465 10.7539L8.95605 10.4541L5.6875 8.70312L5.65234 8.68359L5.61523 8.6709L2.07422 7.44922L21.7803 1.28809L16.4131 19.3398Z" fill="#69A2FF" stroke="#69A2FF"/>
              </svg>
            </div>
            <span className="id-text">ID</span>
          </div>
        )}

        <div className="logout-btn" onClick={() => { void logout(); }}>
            <span className="material-symbols-outlined">close</span>
        </div>
      <div className="layout-background" />
      <div className="layout-container">

        
        <div className="layout-content">
          {children}
        </div>
      </div>
    </div>
  );
};


/* ===== C:\Users\icipa\team-platform-public\id_frontend\src\components\LoadingOverlay\LoadingOverlay.tsx ===== */

// ============= src/components/LoadingOverlay/LoadingOverlay.tsx =============

import React from 'react';

interface LoadingOverlayProps {
  message?: string;
  fullScreen?: boolean;
}

export const LoadingOverlay: React.FC<LoadingOverlayProps> = ({ 
  message = 'Загрузка...', 
  fullScreen = true 
}) => {
  return (
    <div className={`loading-overlay ${fullScreen ? 'loading-overlay--fullscreen' : ''}`}>
      <div className="loading-overlay__content">
        <div className="loading-overlay__spinner" />
        {message && <p className="loading-overlay__message">{message}</p>}
      </div>
    </div>
  );
};


/* ===== C:\Users\icipa\team-platform-public\id_frontend\src\components\PasswordStrength\PasswordStrength.tsx ===== */

// ============= src/components/PasswordStrength/PasswordStrength.tsx =============

import React, { useMemo } from 'react';
import { getPasswordStrength } from '../../utils/validators';

interface PasswordStrengthProps {
  password: string;
  showLabel?: boolean;
}

export const PasswordStrength: React.FC<PasswordStrengthProps> = ({ 
  password, 
  showLabel = true 
}) => {
  const strength = useMemo(() => getPasswordStrength(password), [password]);

  if (!password) return null;

  return (
    <div className="password-strength">
      <div className="password-strength__bars">
        <div 
          className="password-strength__bar"
          style={{
            width: `${strength.score * 100}%`,
            backgroundColor: strength.color
          }}
        />
      </div>
      {showLabel && (
        <span 
          className="password-strength__label"
          style={{ color: strength.color }}
        >
          {strength.label}
        </span>
      )}
    </div>
  );
};


/* ===== C:\Users\icipa\team-platform-public\id_frontend\src\hooks\useAuth.tsx ===== */

// ============= src/hooks/useAuth.tsx =============

import React, { createContext, useContext, useState, useEffect, type ReactNode } from 'react';
import { authService } from '../services/auth.service';
import { storageService } from '../services/storage.service';
import { type User } from '../types/auth.types';
import { TOKEN_STORAGE_KEY, REFRESH_TOKEN_STORAGE_KEY, ID_TOKEN_STORAGE_KEY } from '../utils/constants'

interface AuthContextType {
  user: User | null;
  isLoading: boolean;
  isAuthenticated: boolean;
  login: (email: string, password: string) => Promise<void>;
  register: (username: string, email: string, password: string, passwordConfirm: string) => Promise<{ userId: string; email: string }>;
  logout: () => Promise<void>;
  checkAuth: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

const checkAuth = async () => {
  setIsLoading(true)
  try {
    const userData = await authService.getCurrentUser() // по cookie или по Bearer
    setUser(userData)
  } catch {
    localStorage.removeItem(TOKEN_STORAGE_KEY)
    localStorage.removeItem(REFRESH_TOKEN_STORAGE_KEY)
    localStorage.removeItem(ID_TOKEN_STORAGE_KEY)
    setUser(null)
  } finally {
    setIsLoading(false)
  }
}

  useEffect(() => {
    checkAuth();
  }, []);

  const login = async (email: string, password: string) => {
    const response = await authService.login({ email, password });
    setUser(response.user);
  };

  const register = async (username: string, email: string, password: string, passwordConfirm: string) => {
    const response = await authService.register({
      username,
      email,
      password,
      password_confirm: passwordConfirm,
    });
    return { userId: response.user_id, email: response.email };
  };

  const logout = async () => {
    await authService.logout();
    setUser(null);
    storageService.clear();
  };

  const value: AuthContextType = {
    user,
    isLoading,
    isAuthenticated: !!user,
    login,
    register,
    logout,
    checkAuth,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};


/* ===== C:\Users\icipa\team-platform-public\id_frontend\src\hooks\useForm.tsx ===== */

// ============= src/hooks/useForm.tsx =============

import { useState, useCallback } from 'react'
import type { ChangeEvent, FormEvent, FocusEvent } from 'react'

interface UseFormOptions<T> {
  initialValues: T;
  validate?: (values: T) => Record<string, string>;
  onSubmit: (values: T) => void | Promise<void>;
}

export function useForm<T extends Record<string, any>>({
  initialValues,
  validate,
  onSubmit,
}: UseFormOptions<T>) {
  const [values, setValues] = useState<T>(initialValues);
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [touched, setTouched] = useState<Record<string, boolean>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleChange = useCallback((
    e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>
  ) => {
    const { name, value } = e.target;
    setValues(prev => ({ ...prev, [name]: value }));
    if (errors[name]) setErrors(prev => ({ ...prev, [name]: '' }));
  }, [errors]);

  const handleBlur = useCallback((
    e: FocusEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>
  ) => {
    const { name } = e.target;
    setTouched(prev => ({ ...prev, [name]: true }));
    if (validate) {
      const validationErrors = validate(values);
      if (validationErrors[name]) {
        setErrors(prev => ({ ...prev, [name]: validationErrors[name] }));
      }
    }
  }, [validate, values]);

  const handleSubmit = useCallback(async (e: FormEvent) => {
    e.preventDefault();
    if (validate) {
      const validationErrors = validate(values);
      if (Object.keys(validationErrors).length) {
        setErrors(validationErrors);
        setTouched(Object.keys(values).reduce((acc, k) => ({ ...acc, [k]: true }), {}));
        return;
      }
    }
    setIsSubmitting(true);
    try { await onSubmit(values); } finally { setIsSubmitting(false); }
  }, [validate, values, onSubmit]);

  const reset = useCallback(() => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
    setIsSubmitting(false);
  }, [initialValues]);

  const setFieldValue = useCallback((name: string, value: any) => {
    setValues(prev => ({ ...prev, [name]: value }));
  }, []);

  const setFieldError = useCallback((name: string, error: string) => {
    setErrors(prev => ({ ...prev, [name]: error }));
  }, []);

  return { values, errors, touched, isSubmitting, handleChange, handleBlur, handleSubmit, reset, setFieldValue, setFieldError };
}



/* ===== C:\Users\icipa\team-platform-public\id_frontend\src\hooks\useOAuth.tsx ===== */

// ============= src/hooks/useOAuth.tsx =============

import { useState, useCallback } from 'react';
import { useNavigate, useSearchParams } from 'react-router-dom';
import { oauthService } from '../services/oauth.service';
import { storageService } from '../services/storage.service';
import type { AuthorizationRequest } from '../types/oauth.types';
import { ROUTES } from '../utils/constants';

export const useOAuth = () => {
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  const [isProcessing, setIsProcessing] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const random = (len = 32) =>
    Array.from(crypto.getRandomValues(new Uint8Array(len)))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('')

  const initializeAuthorization = useCallback(async () => {
    const clientId = searchParams.get('client_id')
    const redirectUri = searchParams.get('redirect_uri')
    const responseType = (searchParams.get('response_type') || 'code') as 'code' | 'token'
    const scope = searchParams.get('scope') || 'openid profile email'
    const state = searchParams.get('state') || random()
    const nonce = searchParams.get('nonce') || random()
    const prompt = (searchParams.get('prompt') as any) || undefined

    if (!clientId || !redirectUri) {
      setError('Отсутствуют обязательные параметры')
      return null
    }

    const pkce = await oauthService.generatePKCE()

    const authRequest: AuthorizationRequest = {
      client_id: clientId,
      redirect_uri: redirectUri,
      response_type: responseType,
      scope,
      state,                         // <= всегда есть
      code_challenge: pkce.challenge,
      code_challenge_method: 'S256',
      nonce,
      prompt,
    }

    // всегда сохраняем по state
    storageService.saveOAuthState(state, authRequest)
    storageService.savePKCEVerifier(state, pkce.verifier)

    return authRequest
  }, [searchParams])


  const authorizeWithConsent = useCallback(async (
    authRequest: AuthorizationRequest,
    consent: boolean
  ) => {
    setIsProcessing(true);
    setError(null);

    try {
      const response = await oauthService.authorizeWithConsent(authRequest, consent);
      
      if (response.redirect_url) {
        window.location.href = response.redirect_url;
      }
    } catch (err: any) {
      setError(err.message || 'Ошибка авторизации');
      setIsProcessing(false);
    }
  }, []);

  const handleCallback = useCallback(async () => {
    const code = searchParams.get('code');
    const state = searchParams.get('state');
    const error = searchParams.get('error');

    if (error) {
      navigate(`${ROUTES.ERROR}?error=${error}&description=${searchParams.get('error_description')}`);
      return;
    }

    if (!code || !state) {
      navigate(`${ROUTES.ERROR}?error=invalid_request`);
      return;
    }

    setIsProcessing(true);

    try {
      // Получаем сохраненные данные
      const authRequest = storageService.getAndRemoveOAuthState(state);
      const verifier = storageService.getPKCEVerifier(state);

      if (!authRequest || !verifier) {
        throw new Error('Invalid state or expired session');
      }

      // Обмениваем код на токены
      await oauthService.exchangeCodeForTokens({
        grant_type: 'authorization_code',
        code,
        redirect_uri: authRequest.redirect_uri,
        code_verifier: verifier,
        client_id: authRequest.client_id,
      });

      // Перенаправляем на профиль или главную
      navigate(ROUTES.PROFILE);
    } catch (err: any) {
      navigate(`${ROUTES.ERROR}?error=exchange_failed`);
    } finally {
      setIsProcessing(false);
    }
  }, [navigate, searchParams]);

  return {
    initializeAuthorization,
    authorizeWithConsent,
    handleCallback,
    isProcessing,
    error,
  };
};


/* ===== C:\Users\icipa\team-platform-public\id_frontend\src\main.tsx ===== */

import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom'
import { AuthProvider } from './hooks/useAuth'
import { LoginPage } from './pages/LoginPage'
import { RegisterPage } from './pages/RegisterPage'
import { ProfilePage } from './pages/ProfilePage'
import { AuthorizePage } from './pages/AuthorizePage'
import { ErrorPage } from './pages/ErrorPage'
import { ForgotPasswordPage } from './pages/ForgotPasswordPage'
import { ResetPasswordPage } from './pages/ResetPasswordPage'
import { VerifyEmailPage } from './pages/VerifyEmailPage'
import OAuthCallbackPage from './pages/OAuthCallbackPage'
import './styles/app.scss'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <AuthProvider>
      <BrowserRouter>
        <Routes>
          <Route path="/" element={<Navigate to="/login" />} />
          <Route path="/login" element={<LoginPage />} />
          <Route path="/register" element={<RegisterPage />} />
          <Route path="/profile" element={<ProfilePage />} />
          <Route path="/oauth/authorize" element={<AuthorizePage />} />
          <Route path="/error" element={<ErrorPage />} />
          <Route path="/forgot-password" element={<ForgotPasswordPage />} />
          <Route path="/reset-password" element={<ResetPasswordPage />} />
          <Route path="/verify-email" element={<VerifyEmailPage />} />
          <Route path="/oauth/callback" element={<OAuthCallbackPage />} />
        </Routes>
      </BrowserRouter>
    </AuthProvider>
  </StrictMode>
)



/* ===== C:\Users\icipa\team-platform-public\id_frontend\src\pages\AuthorizePage.tsx ===== */

// ============= src/pages/AuthorizePage.tsx =============

import React, { useState, useEffect } from 'react';
import { Navigate } from 'react-router-dom';
import { Layout } from '../components/Layout/Layout';
import { LoadingOverlay } from '../components/LoadingOverlay/LoadingOverlay';
import { useAuth } from '../hooks/useAuth';
import { useOAuth } from '../hooks/useOAuth';
import { oauthService } from '../services/oauth.service';
import { ROUTES } from '../utils/constants';

export const AuthorizePage: React.FC = () => {
  const { isAuthenticated, isLoading: authLoading } = useAuth();
  const { initializeAuthorization, authorizeWithConsent, isProcessing, error } = useOAuth();
  
  const [authRequest, setAuthRequest] = useState<any>(null);
  const [clientInfo, setClientInfo] = useState<any>(null);
  const [isLoadingClient, setIsLoadingClient] = useState(true);

  useEffect(() => {
    const init = async () => {
      const request = await initializeAuthorization();
      if (request) {
        setAuthRequest(request);
        
        // Загружаем информацию о клиенте
        try {
          const client = await oauthService.getClientInfo(request.client_id);
          setClientInfo(client);
        } catch (err) {
          console.error('Failed to load client info:', err);
        }
      }
      setIsLoadingClient(false);
    };
    
    init();
  }, [initializeAuthorization]);

  if (authLoading || isLoadingClient) {
    return <LoadingOverlay message="Загрузка..." />;
  }

  if (!isAuthenticated) {
    const currentUrl = window.location.href;
    return <Navigate to={`${ROUTES.LOGIN}?redirect_uri=${encodeURIComponent(currentUrl)}`} />;
  }

  if (error || !authRequest) {
    return (
      <Layout>
        <div className="authorize-page">
          <div className="authorize-page__error">
            <h2>Ошибка авторизации</h2>
            <p>{error || 'Неверные параметры запроса'}</p>
          </div>
        </div>
      </Layout>
    );
  }

  const handleApprove = () => {
    authorizeWithConsent(authRequest, true);
  };

  const handleDeny = () => {
    authorizeWithConsent(authRequest, false);
  };

  return (
    <Layout>
      <div className="authorize-page">
        <div className="authorize-page__card">
          {clientInfo?.logo_uri && (
            <img 
              src={clientInfo.logo_uri} 
              alt={clientInfo.client_name}
              className="authorize-page__logo"
            />
          )}
          
          <h2 className="authorize-page__title">
            {clientInfo?.client_name || authRequest.client_id} запрашивает доступ
          </h2>
          
          <div className="authorize-page__scopes">
            <p>Приложение запрашивает следующие разрешения:</p>
            <ul>
              {authRequest.scope.split(' ').map((scope: string) => (
                <li key={scope}>{getScopeDescription(scope)}</li>
              ))}
            </ul>
          </div>
          
          <div className="authorize-page__actions">
            <button
              className="authorize-page__deny"
              onClick={handleDeny}
              disabled={isProcessing}
            >
              Отклонить
            </button>
            <button
              className="authorize-page__approve"
              onClick={handleApprove}
              disabled={isProcessing}
            >
              Разрешить
            </button>
          </div>
        </div>
        
        {isProcessing && <LoadingOverlay message="Обработка..." />}
      </div>
    </Layout>
  );
};

function getScopeDescription(scope: string): string {
  const descriptions: Record<string, string> = {
    openid: 'Базовая информация профиля',
    profile: 'Имя и фото профиля',
    email: 'Адрес электронной почты',
    offline_access: 'Доступ к данным в автономном режиме',
  };
  return descriptions[scope] || scope;
}



/* ===== C:\Users\icipa\team-platform-public\id_frontend\src\pages\ErrorPage.tsx ===== */

// ============= src/pages/ErrorPage.tsx =============

import React from 'react';
import { Link, useSearchParams } from 'react-router-dom';
import { Layout } from '../components/Layout/Layout';
import { ROUTES } from '../utils/constants';

export const ErrorPage: React.FC = () => {
  const [searchParams] = useSearchParams();
  
  const error = searchParams.get('error');
  const description = searchParams.get('description');

  const getErrorMessage = (): { title: string; message: string } => {
    switch (error) {
      case 'invalid_request':
        return {
          title: 'Неверный запрос',
          message: description || 'Запрос содержит недопустимые параметры',
        };
      case 'unauthorized_client':
        return {
          title: 'Неавторизованный клиент',
          message: description || 'Клиент не авторизован для выполнения этого запроса',
        };
      case 'access_denied':
        return {
          title: 'Доступ запрещен',
          message: description || 'Вы отклонили запрос на авторизацию',
        };
      case 'server_error':
        return {
          title: 'Ошибка сервера',
          message: description || 'Произошла внутренняя ошибка сервера',
        };
      default:
        return {
          title: 'Ошибка',
          message: description || 'Произошла неизвестная ошибка',
        };
    }
  };

  const { title, message } = getErrorMessage();

  return (
    <Layout>
      <div className="error-page">
        <div className="error-page__content">
          <h1 className="error-page__title">{title}</h1>
          <p className="error-page__message">{message}</p>
          <Link to={ROUTES.HOME} className="error-page__link">
            Вернуться на главную
          </Link>
        </div>
      </div>
    </Layout>
  );
};


/* ===== C:\Users\icipa\team-platform-public\id_frontend\src\pages\ForgotPasswordPage.tsx ===== */

// ============= src/pages/ForgotPasswordPage.tsx =============

import React, { useState, useEffect } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import { Layout } from '../components/Layout/Layout';
import { CodeInput } from '../components/CodeInput/CodeInput';
import { authService } from '../services/auth.service';
import { validators, isWeakPassword } from '../utils/validators';
import { handleApiError } from '../utils/errors';
import { ROUTES, CODE_RESEND_TIMEOUT, CODE_LENGTH } from '../utils/constants';

function parseCooldownSeconds(msg: string): number | null {
  const m = msg.match(/Please wait (\d+) seconds/i);
  return m ? Number(m[1]) : null;
}

export const ForgotPasswordPage: React.FC = () => {
  const navigate = useNavigate();

  // step= "request" -> ввод email, "confirm" -> код + новый пароль
  const [step, setStep] = useState<'request' | 'confirm'>('request');

  // request
  const [email, setEmail] = useState('');
  const [emailError, setEmailError] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  // confirm
  const [code, setCode] = useState('');
  const [pwd, setPwd] = useState('');
  const [pwd2, setPwd2] = useState('');
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [weakPassword, setWeakPassword] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);

  // resend
  const [isResending, setIsResending] = useState(false);
  const [resendTimer, setResendTimer] = useState<number>(0);

  useEffect(() => {
    if (resendTimer <= 0) return;
    const id = setInterval(() => setResendTimer((s) => (s > 0 ? s - 1 : 0)), 1000);
    return () => clearInterval(id);
  }, [resendTimer]);

  const sendCode = async () => {
    const v = validators.email(email);
    if (!v.isValid) {
      setEmailError(v.error!);
      return;
    }
    setEmailError('');
    setIsLoading(true);
    try {
      await authService.forgotPassword({ email });
      setStep('confirm');
      setResendTimer(CODE_RESEND_TIMEOUT);
    } catch (err) {
      const msg = handleApiError(err);
      setEmailError(msg);
      const s = parseCooldownSeconds(msg);
      if (typeof s === 'number') setResendTimer(s);
    } finally {
      setIsLoading(false);
    }
  };

  const resend = async () => {
    if (resendTimer > 0 || !email) return;
    setIsResending(true);
    try {
      await authService.forgotPassword({ email });
      setResendTimer(CODE_RESEND_TIMEOUT);
      setCode('');
    } catch (err) {
      const msg = handleApiError(err);
      const s = parseCooldownSeconds(msg);
      if (typeof s === 'number') setResendTimer(s);
    } finally {
      setIsResending(false);
    }
  };

  const submitNewPassword = async (e: React.FormEvent) => {
    e.preventDefault();
    const newErrors: Record<string, string> = {};

    const c = validators.code(code); if (!c.isValid) newErrors.code = c.error!;
    const p = validators.password(pwd); if (!p.isValid) newErrors.password = p.error!;
    const pc = validators.passwordConfirm(pwd, pwd2); if (!pc.isValid) newErrors.passwordConfirm = pc.error!;
    setErrors(newErrors);
    if (Object.keys(newErrors).length > 0) return;

    if (isWeakPassword(pwd)) { setWeakPassword(true); return; }

    setIsSubmitting(true);
    try {
      await authService.resetPassword({
        email,
        code,
        new_password: pwd,
        new_password_confirm: pwd2,
      });
      navigate(ROUTES.LOGIN);
    } catch (err) {
      setErrors({ general: handleApiError(err) });
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Layout>
      <div className="forgot-page">
        <h1 className="forgot-page__title">Сменить пароль</h1>

        {step === 'request' && (
          <>
            <p className="forgot-page__description">
              Введите email, указанный при регистрации
            </p>

            <form className="forgot-page__form" onSubmit={(e) => { e.preventDefault(); void sendCode(); }}>
              <input
                type="email"
                className={`forgot-page__input ${emailError ? 'forgot-page__input--error' : ''}`}
                placeholder="Email"
                value={email}
                onChange={(e) => { setEmail(e.target.value); setEmailError(''); }}
                disabled={isLoading}
                autoFocus
              />

              {emailError && <div className="forgot-page__error">{emailError}</div>}

              <Link to={ROUTES.LOGIN} className="auth-form__link auth-form__link--register">
                Вернуться к входу
              </Link>

              <button type="submit" className="forgot-page__submit" disabled={isLoading}>
                {isLoading ? 'Отправка...' : 'Отправить код'}
              </button>
            </form>
          </>
        )}

        {step === 'confirm' && (
          <>
            <p className="forgot-page__description">
              Мы отправили код на <b>{email}</b>. Введите код и новый пароль.
            </p>

            <div style={{ display: 'flex', justifyContent: 'center', marginBottom: 16 }}>
              <CodeInput
                length={CODE_LENGTH}
                onChange={(val) => { setCode(val); if (errors.code) setErrors((e) => ({ ...e, code: '' })); }}
                error={!!errors.code}
                disabled={isSubmitting}
              />
            </div>
            {errors.code && <div className="forgot-page__error">{errors.code}</div>}

            <form className={`reset-page__form auth-form ${weakPassword ? 'auth-form--submitted' : ''}`} onSubmit={submitNewPassword}>
              <div className={`auth-form__field auth-form__field--password ${weakPassword ? 'is-weak' : ''}`}>
                <input
                  type="password"
                  placeholder=" "
                  value={pwd}
                  onChange={(e) => { setPwd(e.target.value); setWeakPassword(false); if (errors.password) setErrors((er) => ({ ...er, password: '' })); }}
                  className={`auth-form__input ${errors.password ? 'auth-form__input--error' : ''}`}
                  disabled={isSubmitting}
                />
                <span className="auth-form__placeholder">Новый пароль</span>
                {errors.password && <span className="auth-form__field-error">{errors.password}</span>}
              </div>

              <div className="auth-form__field">
                <input
                  type="password"
                  placeholder=" "
                  value={pwd2}
                  onChange={(e) => { setPwd2(e.target.value); if (errors.passwordConfirm) setErrors((er) => ({ ...er, passwordConfirm: '' })); }}
                  className={`auth-form__input ${errors.passwordConfirm ? 'auth-form__input--error' : ''}`}
                  disabled={isSubmitting}
                />
                <span className="auth-form__placeholder">Повторите пароль</span>
                {errors.passwordConfirm && <span className="auth-form__field-error">{errors.passwordConfirm}</span>}
              </div>

              {errors.general && (
                <div className="reset-page__error reset-page__error--general">{errors.general}</div>
              )}

              <button type="submit" className="auth-form__submit" disabled={isSubmitting || code.length !== CODE_LENGTH}>
                {isSubmitting ? 'Сохранение...' : 'Сменить пароль'}
              </button>
            </form>

            <div className="verify-page__resend" style={{ marginTop: 16, textAlign: 'center' }}>
              {resendTimer > 0 ? (
                <span className="verify-page__timer">
                  Отправить код повторно через {resendTimer}с
                </span>
              ) : (
                <button
                  className="verify-page__resend-btn"
                  onClick={() => { void resend(); }}
                  disabled={isResending}
                >
                  {isResending ? 'Отправка...' : 'Отправить код повторно'}
                </button>
              )}
            </div>

            <div style={{ textAlign: 'center', marginTop: 16 }}>
              <button
                className="verify-page__resend-btn"
                onClick={() => setStep('request')}
                disabled={isSubmitting || isResending}
              >
                Изменить email
              </button>
            </div>
          </>
        )}
      </div>
    </Layout>
  );
};



/* ===== C:\Users\icipa\team-platform-public\id_frontend\src\pages\LoginPage.tsx ===== */

// ============= src/pages/LoginPage.tsx =============

import React, { useEffect } from 'react';
import { useNavigate, useSearchParams } from 'react-router-dom';
import { Layout } from '../components/Layout/Layout';
import { LoginForm } from '../components/AuthForm/LoginForm';
import { useAuth } from '../hooks/useAuth';
import { ROUTES } from '../utils/constants';

export const LoginPage: React.FC = () => {
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  const { isAuthenticated } = useAuth();
  
  const redirectUrl = searchParams.get('redirect_uri') || ROUTES.PROFILE;

  const isSafe = (u: string) => {
    try { const url = new URL(u); return url.origin === window.location.origin }
    catch { return u.startsWith('/') }
  };

  useEffect(() => {
    if (isAuthenticated) {
      navigate(redirectUrl);
    }
  }, [isAuthenticated, navigate, redirectUrl]);

  const handleSuccess = () => {
    if (isSafe(redirectUrl)) {
      if (/^https?:\/\//i.test(redirectUrl)) window.location.href = redirectUrl;
      else navigate(redirectUrl);
    } else {
      navigate(ROUTES.PROFILE);
    }
  }
  return (
    <Layout>
      <LoginForm onSuccess={handleSuccess} redirectUrl={redirectUrl} />
    </Layout>
  );
};


/* ===== C:\Users\icipa\team-platform-public\id_frontend\src\pages\OAuthCallbackPage.tsx ===== */

// src/pages/OAuthCallbackPage.tsx
import { useEffect, useRef } from 'react'
import { useOAuth } from '../hooks/useOAuth'
import { LoadingOverlay } from '../components/LoadingOverlay/LoadingOverlay'

export default function OAuthCallbackPage() {
  const { handleCallback } = useOAuth()
  const ran = useRef(false)
  useEffect(() => {
    if (ran.current) return
    ran.current = true
    void handleCallback()
  }, [handleCallback])
  return <LoadingOverlay message="Обработка..." />
}



/* ===== C:\Users\icipa\team-platform-public\id_frontend\src\pages\ProfilePage.tsx ===== */

// ============= src/pages/ProfilePage.tsx =============

import React from 'react';
import { Navigate } from 'react-router-dom';
import { Layout } from '../components/Layout/Layout';
import { LoadingOverlay } from '../components/LoadingOverlay/LoadingOverlay';
import { useAuth } from '../hooks/useAuth';
import { ROUTES } from '../utils/constants';

export const ProfilePage: React.FC = () => {
  const { user, isLoading, isAuthenticated, logout } = useAuth();

  if (isLoading) {
    return <LoadingOverlay message="Загрузка профиля..." />;
  }

  if (!isAuthenticated) {
    return <Navigate to={ROUTES.LOGIN} />;
  }

  const handleLogout = async () => {
    await logout();
  };

  return (
    <Layout>
      <div className="profile-page">
        <h1 className="profile-page__title">Профиль</h1>
        
        <div className="profile-page__card">
          <div className="profile-page__info">
            <div className="profile-page__field">
              <span className="profile-page__label">Имя пользователя:</span>
              <span className="profile-page__value">{user?.username}</span>
            </div>
            
            <div className="profile-page__field">
              <span className="profile-page__label">Email:</span>
              <span className="profile-page__value">
                {user?.email}
                {user?.email_verified && (
                  <span className="profile-page__verified">✓</span>
                )}
              </span>
            </div>
            
            <div className="profile-page__field">
              <span className="profile-page__label">ID:</span>
              <span className="profile-page__value">{user?.id}</span>
            </div>
          </div>
          
          <button
            className="profile-page__logout"
            onClick={handleLogout}
          >
            Выйти
          </button>
        </div>
      </div>
    </Layout>
  );
};


/* ===== C:\Users\icipa\team-platform-public\id_frontend\src\pages\RegisterPage.tsx ===== */

// ============= src/pages/RegisterPage.tsx =============

import React, { useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { Layout } from '../components/Layout/Layout';
import { RegisterForm } from '../components/AuthForm/RegisterForm';
import { useAuth } from '../hooks/useAuth';
import { ROUTES } from '../utils/constants';

export const RegisterPage: React.FC = () => {
  const navigate = useNavigate();
  const { isAuthenticated } = useAuth();

  useEffect(() => {
    if (isAuthenticated) {
      navigate(ROUTES.PROFILE);
    }
  }, [isAuthenticated, navigate]);

  const handleSuccess = (userId: string, email: string) => {
    navigate(`${ROUTES.VERIFY_EMAIL}?user_id=${userId}&email=${encodeURIComponent(email)}`);
  };

  return (
    <Layout>
      <RegisterForm onSuccess={handleSuccess} />
    </Layout>
  );
};


/* ===== C:\Users\icipa\team-platform-public\id_frontend\src\pages\ResetPasswordPage.tsx ===== */

// ============= src/pages/ResetPasswordPage.tsx =============
import React, { useState, useEffect } from 'react';
import { useNavigate, useSearchParams } from 'react-router-dom';
import { Layout } from '../components/Layout/Layout';
import { authService } from '../services/auth.service';
import { validators, isWeakPassword } from '../utils/validators';
import { handleApiError } from '../utils/errors';
import { ROUTES } from '../utils/constants';

export const ResetPasswordPage: React.FC = () => {
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();

  const userId = searchParams.get('user_id');
  const code = searchParams.get('code');

  const [password, setPassword] = useState('');
  const [passwordConfirm, setPasswordConfirm] = useState('');
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [isLoading, setIsLoading] = useState(false);
  const [submitted, setSubmitted] = useState(false);
  const [weakPassword, setWeakPassword] = useState(false);

  useEffect(() => {
    if (!userId || !code) navigate(ROUTES.FORGOT_PASSWORD);
  }, [userId, code, navigate]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setSubmitted(true);

    const newErrors: Record<string, string> = {};
    const p = validators.password(password); if (!p.isValid) newErrors.password = p.error!;
    const pc = validators.passwordConfirm(password, passwordConfirm); if (!pc.isValid) newErrors.passwordConfirm = pc.error!;
    if (Object.keys(newErrors).length > 0) { setErrors(newErrors); return; }

    if (isWeakPassword(password)) { setWeakPassword(true); return; }
    if (!userId || !code) return;

    setIsLoading(true);
    setErrors({});
    try {
      await authService.resetPassword({
        user_id: userId,
        code,
        new_password: password,
        new_password_confirm: passwordConfirm,
      });
      navigate(ROUTES.LOGIN);
    } catch (err) {
      setErrors({ general: handleApiError(err) });
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Layout>
      <div className="reset-page">
        <h1 className="reset-page__title">Новый пароль</h1>

        <form className={`reset-page__form auth-form ${submitted ? 'auth-form--submitted' : ''}`} onSubmit={handleSubmit}>
          <div className={`reset-page__field auth-form__field auth-form__field--password ${weakPassword ? 'is-weak' : ''}`}>
            <input
              type="password"
              className={`reset-page__input auth-form__input ${errors.password ? 'reset-page__input--error auth-form__input--error' : ''}`}
              placeholder="Новый пароль"
              value={password}
              onChange={(e) => { setPassword(e.target.value); setWeakPassword(false); }}
              disabled={isLoading}
              autoFocus
            />
            {errors.password && <span className="reset-page__error">{errors.password}</span>}
          </div>

          <div className="reset-page__field auth-form__field">
            <input
              type="password"
              className={`reset-page__input auth-form__input ${errors.passwordConfirm ? 'reset-page__input--error auth-form__input--error' : ''}`}
              placeholder="Повторите пароль"
              value={passwordConfirm}
              onChange={(e) => setPasswordConfirm(e.target.value)}
              disabled={isLoading}
            />
            {errors.passwordConfirm && <span className="reset-page__error">{errors.passwordConfirm}</span>}
          </div>

          {errors.general && <div className="reset-page__error reset-page__error--general">{errors.general}</div>}

          <button type="submit" className="reset-page__submit auth-form__submit" disabled={isLoading}>
            {isLoading ? 'Сохранение...' : 'Сохранить пароль'}
          </button>
        </form>
      </div>
    </Layout>
  );
};



/* ===== C:\Users\icipa\team-platform-public\id_frontend\src\pages\VerifyEmailPage.tsx ===== */

// ============= src/pages/VerifyEmailPage.tsx =============

import React, { useState, useEffect } from 'react';
import { useNavigate, useSearchParams } from 'react-router-dom';
import { Layout } from '../components/Layout/Layout';
import { CodeInput } from '../components/CodeInput/CodeInput';
import { LoadingOverlay } from '../components/LoadingOverlay/LoadingOverlay';
import { authService } from '../services/auth.service';
import { handleApiError } from '../utils/errors';
import { ROUTES, CODE_RESEND_TIMEOUT, CODE_LENGTH } from '../utils/constants';

export const VerifyEmailPage: React.FC = () => {
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  
  const userId = searchParams.get('user_id');
  const email = searchParams.get('email');
  
  const [, setCode] = useState('');
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [isResending, setIsResending] = useState(false);
  const [resendTimer, setResendTimer] = useState(CODE_RESEND_TIMEOUT);

  useEffect(() => {
    if (!userId || !email) {
      navigate(ROUTES.REGISTER);
    }
  }, [userId, email, navigate]);

  useEffect(() => {
    const timer = setInterval(() => {
      setResendTimer((prev) => (prev > 0 ? prev - 1 : 0));
    }, 1000);
    return () => clearInterval(timer);
  }, []);

  const handleVerify = async (verificationCode: string) => {
    if (!userId) return;
    
    setError('');
    setIsLoading(true);
    
    try {
      await authService.verifyEmail({
        user_id: userId,
        code: verificationCode,
      });
      navigate(ROUTES.PROFILE);
    } catch (err) {
      setError(handleApiError(err));
    } finally {
      setIsLoading(false);
    }
  };

  const handleResend = async () => {
    if (!userId || resendTimer > 0) return;
    
    setIsResending(true);
    setError('');
    
    try {
      await authService.resendVerificationCode(userId);
      setResendTimer(CODE_RESEND_TIMEOUT);
      setCode('');
    } catch (err) {
      setError(handleApiError(err));
    } finally {
      setIsResending(false);
    }
  };

  return (
    <Layout>
      <div className="verify-page">
        <h1 className="verify-page__title">Подтверждение Email</h1>
        <p className="verify-page__description">
          Мы отправили код подтверждения на {email}
        </p>
        
        <CodeInput
          length={CODE_LENGTH}
          onChange={setCode}
          onComplete={handleVerify}
          error={!!error}
          disabled={isLoading}
        />
        
        {error && (
          <div className="verify-page__error">
            {error}
          </div>
        )}
        
        <div className="verify-page__resend">
          {resendTimer > 0 ? (
            <span className="verify-page__timer">
              Отправить повторно через {resendTimer}с
            </span>
          ) : (
            <button
              className="verify-page__resend-btn"
              onClick={handleResend}
              disabled={isResending}
            >
              {isResending ? 'Отправка...' : 'Отправить код повторно'}
            </button>
          )}
        </div>
        
        {isLoading && <LoadingOverlay message="Проверка кода..." />}
      </div>
    </Layout>
  );
};


/* ===== C:\Users\icipa\team-platform-public\id_frontend\src\services\auth.service.ts ===== */

/* ============= src/services/auth.service.ts ============= */

import { api, apiClient } from '../api/client'
import { API_ENDPOINTS } from '../api/endpoints'
import type {
  LoginRequest,
  LoginResponse,
  RegisterRequest,
  RegisterResponse,
  VerifyEmailRequest,
  ForgotPasswordRequest,
  ResetPasswordRequest,
  User,
} from '../types/auth.types'
import { AppError } from '../utils/errors'

type RegisterPayload = {
  user_id: string
  email: string
  requires_verification: boolean
  message?: string
}

function assertRegisterPayload(r: any): asserts r is RegisterPayload {
  const ok =
    r &&
    typeof r.user_id === 'string' &&
    typeof r.email === 'string' &&
    typeof r.requires_verification === 'boolean'
  if (!ok) throw new AppError('Некорректный ответ сервера регистрации')
}

class AuthService {
  async login(data: LoginRequest): Promise<LoginResponse> {
    const response = await api.post<LoginResponse>(API_ENDPOINTS.AUTH.LOGIN, data)
    if (response.data.access_token) {
      apiClient.saveTokens(response.data)
    }
    return response.data
  }

  async register(data: RegisterRequest): Promise<RegisterResponse> {
    const { data: raw } = await api.post<unknown>(API_ENDPOINTS.AUTH.REGISTER, data)
    assertRegisterPayload(raw)
    return {
      user_id: raw.user_id,
      email: raw.email,
      message: raw.message ?? '',
      requires_verification: raw.requires_verification,
    }
  }

  async verifyEmail(data: VerifyEmailRequest): Promise<LoginResponse> {
    const response = await api.post<LoginResponse>(API_ENDPOINTS.AUTH.VERIFY_EMAIL, data)
    if (response.data.access_token) {
      apiClient.saveTokens(response.data)
    }
    return response.data
  }

  async resendVerificationCode(userId: string): Promise<void> {
    await api.post(API_ENDPOINTS.AUTH.RESEND_CODE, { user_id: userId })
  }

  async forgotPassword(data: ForgotPasswordRequest): Promise<void> {
    await api.post(API_ENDPOINTS.AUTH.FORGOT_PASSWORD, data)
  }

  async resetPassword(data: ResetPasswordRequest): Promise<void> {
    await api.post(API_ENDPOINTS.AUTH.RESET_PASSWORD, data)
  }

  async getCurrentUser(): Promise<User> {
    const response = await api.get<User>(API_ENDPOINTS.AUTH.ME)
    return response.data
  }

  async logout(): Promise<void> {
    try {
      await api.post(API_ENDPOINTS.SESSION.LOGOUT)
    } finally {
      apiClient.logout()
    }
  }

  async checkSession(): Promise<boolean> {
    try {
      const response = await api.get(API_ENDPOINTS.SESSION.STATUS)
      return response.data.active
    } catch {
      return false
    }
  }
}

export const authService = new AuthService()



/* ===== C:\Users\icipa\team-platform-public\id_frontend\src\services\oauth.service.ts ===== */

// ============= src/services/oauth.service.ts =============

import { api, apiClient } from '../api/client';
import { API_ENDPOINTS } from '../api/endpoints';
import type {
  AuthorizationRequest,
  TokenRequest,
  TokenResponse,
  UserInfo,
  OAuthClient,
} from '../types/oauth.types';

class OAuthService {
  /**
   * Генерация PKCE verifier и challenge
   */
  async generatePKCE(): Promise<{ verifier: string; challenge: string }> {
    const verifier = this.generateRandomString(128);
    const encoder = new TextEncoder();
    const data = encoder.encode(verifier);
    const digest = await crypto.subtle.digest('SHA-256', data);
    const challenge = this.base64URLEncode(digest);
    return { verifier, challenge };
  }

  private generateRandomString(length: number): string {
    const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~'
    const bytes = new Uint8Array(length)
    crypto.getRandomValues(bytes)
    return Array.from(bytes, b => charset[b % charset.length]).join('')
  }


  private base64URLEncode(buffer: ArrayBuffer): string {
    const bytes = new Uint8Array(buffer);
    let str = '';
    for (const byte of bytes) {
      str += String.fromCharCode(byte);
    }
    return btoa(str)
      .replace(/\+/g, '-')
      .replace(/\//g, '_')
      .replace(/=/g, '');
  }

  /**
   * Построение URL для авторизации
   */
  buildAuthorizationUrl(params: AuthorizationRequest): string {
    const searchParams = new URLSearchParams({
      client_id: params.client_id,
      redirect_uri: params.redirect_uri,
      response_type: params.response_type,
      scope: params.scope,
    });

    if (params.state) searchParams.append('state', params.state);
    if (params.code_challenge) searchParams.append('code_challenge', params.code_challenge);
    if (params.code_challenge_method) searchParams.append('code_challenge_method', params.code_challenge_method);
    if (params.nonce) searchParams.append('nonce', params.nonce);
    if (params.prompt) searchParams.append('prompt', params.prompt);
    if (params.max_age) searchParams.append('max_age', params.max_age.toString());

    const base = import.meta.env.VITE_API_BASE || '';
    return `${base}${API_ENDPOINTS.OAUTH.AUTHORIZE}?${searchParams.toString()}`;
  }

  /**
   * Обмен authorization code на токены
   */
async exchangeCodeForTokens(params: TokenRequest): Promise<TokenResponse> {
  const body = new URLSearchParams({
    grant_type: params.grant_type,
    code: params.code ?? '',
    redirect_uri: params.redirect_uri ?? '',
    code_verifier: params.code_verifier ?? '',
    client_id: params.client_id,
  })
  const { data } = await api.post<TokenResponse>(API_ENDPOINTS.OAUTH.TOKEN, body, {
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
  })
  apiClient.saveTokens(data)
  return data
}

async refreshTokens(refreshToken: string): Promise<TokenResponse> {
  const body = new URLSearchParams({
    grant_type: 'refresh_token',
    refresh_token: refreshToken,
    client_id: import.meta.env.VITE_CLIENT_ID || 'id_frontend',
  })
  const { data } = await api.post<TokenResponse>(API_ENDPOINTS.OAUTH.TOKEN, body, {
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
  })
  apiClient.saveTokens(data)
  return data
}

  /**
   * Получение информации о пользователе
   */
  async getUserInfo(): Promise<UserInfo> {
    const response = await api.get<UserInfo>(API_ENDPOINTS.OAUTH.USERINFO);
    return response.data;
  }

  /**
   * Получение информации о клиенте
   */
  async getClientInfo(clientId: string): Promise<OAuthClient> {
    const response = await api.get<OAuthClient>(API_ENDPOINTS.CLIENTS.GET(clientId));
    return response.data;
  }

  /**
   * Отзыв токена
   */
  async revokeToken(
    token: string,
    tokenType: 'access_token' | 'refresh_token' = 'access_token'
  ): Promise<void> {
    const body = new URLSearchParams({ token, token_type_hint: tokenType });
    await api.post(API_ENDPOINTS.OAUTH.REVOKE, body, {
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    });
  }

  /**
   * Авторизация с согласием пользователя
   */
  async authorizeWithConsent(
    authRequest: AuthorizationRequest,
    consent: boolean
  ): Promise<{ redirect_url: string }> {
    const response = await api.post<{ redirect_url: string }>(API_ENDPOINTS.OAUTH.CONSENT, {
      ...authRequest,
      consent,
    });
    return response.data;
  }
}

export const oauthService = new OAuthService();


/* ===== C:\Users\icipa\team-platform-public\id_frontend\src\services\storage.service.ts ===== */

// ============= src/services/storage.service.ts =============

interface StorageData {
  [key: string]: any;
}

class StorageService {
  private prefix = 'id_app_';

  /**
   * Сохранение данных
   */
  set<T>(key: string, value: T): void {
    try {
      const serialized = JSON.stringify(value);
      localStorage.setItem(this.prefix + key, serialized);
    } catch (error) {
      console.error('Failed to save to localStorage:', error);
    }
  }

  /**
   * Получение данных
   */
  get<T>(key: string): T | null {
    try {
      const item = localStorage.getItem(this.prefix + key);
      if (item === null) return null;
      return JSON.parse(item) as T;
    } catch (error) {
      console.error('Failed to get from localStorage:', error);
      return null;
    }
  }

  /**
   * Удаление данных
   */
  remove(key: string): void {
    localStorage.removeItem(this.prefix + key);
  }

  /**
   * Очистка всех данных приложения
   */
  clear(): void {
    const keys = Object.keys(localStorage);
    keys.forEach((key) => {
      if (key.startsWith(this.prefix)) {
        localStorage.removeItem(key);
      }
    });
  }

  /**
   * Сохранение OAuth state для проверки
   */
  saveOAuthState(state: string, data: any): void {
    this.set(`oauth_state_${state}`, {
      data,
      timestamp: Date.now(),
    });
  }

  /**
   * Получение и удаление OAuth state
   */
  getAndRemoveOAuthState(state: string): any | null {
    const key = `oauth_state_${state}`;
    const stored = this.get<{ data: any; timestamp: number }>(key);
    
    if (!stored) return null;
    
    // Проверяем, что state не устарел (5 минут)
    if (Date.now() - stored.timestamp > 5 * 60 * 1000) {
      this.remove(key);
      return null;
    }
    
    this.remove(key);
    return stored.data;
  }

  /**
   * Сохранение PKCE verifier
   */
  savePKCEVerifier(state: string, verifier: string): void {
    this.set(`pkce_${state}`, {
      verifier,
      timestamp: Date.now(),
    });
  }

  /**
   * Получение PKCE verifier
   */
  getPKCEVerifier(state: string): string | null {
    const key = `pkce_${state}`;
    const stored = this.get<{ verifier: string; timestamp: number }>(key);
    
    if (!stored) return null;
    
    // Проверяем, что verifier не устарел (10 минут)
    if (Date.now() - stored.timestamp > 10 * 60 * 1000) {
      this.remove(key);
      return null;
    }
    
    this.remove(key);
    return stored.verifier;
  }
}

export const storageService = new StorageService();


/* ===== C:\Users\icipa\team-platform-public\id_frontend\src\types\api.types.ts ===== */

// ============= src/types/api.types.ts =============

export interface ApiResponse<T = any> {
  data?: T;
  error?: string;
  message?: string;
  status: number;
}

export interface PaginatedResponse<T> {
  items: T[];
  total: number;
  page: number;
  per_page: number;
  total_pages: number;
}

export interface ValidationError {
  field: string;
  message: string;
}

export interface Session {
  id: string;
  user_id: string;
  client_id?: string;
  ip_address: string;
  user_agent: string;
  created_at: string;
  last_activity: string;
  expires_at: string;
}


/* ===== C:\Users\icipa\team-platform-public\id_frontend\src\types\auth.types.ts ===== */

// ============= src/types/auth.types.ts =============

export interface User {
  id: string;
  username: string;
  email: string;
  email_verified: boolean;
  created_at: string;
  updated_at: string;
}

export interface LoginRequest { email: string; password: string; }
export interface RegisterRequest { username: string; email: string; password: string; password_confirm: string; }
export interface VerifyEmailRequest { user_id: string; code: string; }
export interface ForgotPasswordRequest { email: string; }
export interface ResetPasswordRequestBase {
  code: string;
  new_password: string;
  new_password_confirm: string;
}

export type ResetPasswordRequest =
  | (ResetPasswordRequestBase & { user_id: string })
  | (ResetPasswordRequestBase & { email: string });

export interface LoginResponse {
  access_token: string;
  refresh_token: string;
  token_type: string;
  expires_in: number;
  user: User;
}

export interface RegisterResponse {
  user_id: string;
  email: string;
  message: string;
  requires_verification: boolean;
}

export interface ApiError {
  error: string;
  message?: string;
  details?: Record<string, any>;
}



/* ===== C:\Users\icipa\team-platform-public\id_frontend\src\types\oauth.types.ts ===== */

// ============= src/types/oauth.types.ts =============

export interface OAuthClient {
  client_id: string;
  client_name: string;
  client_uri?: string;
  logo_uri?: string;
  redirect_uris: string[];
  scope: string;
}

export interface AuthorizationRequest {
  client_id: string;
  redirect_uri: string;
  response_type: 'code' | 'token';
  scope: string;
  state?: string;
  code_challenge?: string;
  code_challenge_method?: 'S256' | 'plain';
  nonce?: string;
  prompt?: 'none' | 'login' | 'consent' | 'select_account';
  max_age?: number;
}

export interface AuthorizationResponse {
  code?: string;
  state?: string;
  error?: string;
  error_description?: string;
}

export interface TokenRequest {
  grant_type: 'authorization_code' | 'refresh_token' | 'password';
  code?: string;
  redirect_uri?: string;
  code_verifier?: string;
  refresh_token?: string;
  username?: string;
  password?: string;
  client_id: string;
  client_secret?: string;
  scope?: string;
}

export interface TokenResponse {
  access_token: string;
  token_type: string;
  expires_in: number;
  refresh_token?: string;
  id_token?: string;
  scope?: string;
}

export interface UserInfo {
  sub: string;
  name?: string;
  preferred_username?: string;
  email?: string;
  email_verified?: boolean;
  picture?: string;
  updated_at?: number;
}


/* ===== C:\Users\icipa\team-platform-public\id_frontend\src\utils\constants.ts ===== */

// ============= src/utils/constants.ts =============

export const APP_NAME = 'ID Service';
export const APP_VERSION = '1.0.0';

export const PASSWORD_MIN_LENGTH = 8;
export const USERNAME_MIN_LENGTH = 3;
export const USERNAME_MAX_LENGTH = 20;

export const CODE_LENGTH = 4;
export const CODE_RESEND_TIMEOUT = 60; // seconds

export const TOKEN_STORAGE_KEY = 'access_token';
export const REFRESH_TOKEN_STORAGE_KEY = 'refresh_token';
export const ID_TOKEN_STORAGE_KEY = 'id_token';

export const OAUTH_SCOPES = {
  OPENID: 'openid',
  PROFILE: 'profile',
  EMAIL: 'email',
  OFFLINE_ACCESS: 'offline_access',
};

export const ERROR_MESSAGES = {
  NETWORK_ERROR: 'Ошибка сети. Проверьте подключение к интернету.',
  UNAUTHORIZED: 'Необходима авторизация.',
  FORBIDDEN: 'Доступ запрещен.',
  NOT_FOUND: 'Ресурс не найден.',
  VALIDATION_ERROR: 'Проверьте правильность введенных данных.',
  SERVER_ERROR: 'Ошибка сервера. Попробуйте позже.',
  UNKNOWN_ERROR: 'Произошла неизвестная ошибка.',
};

export const ROUTES = {
  HOME: '/',
  LOGIN: '/login',
  REGISTER: '/register',
  VERIFY_EMAIL: '/verify-email',
  FORGOT_PASSWORD: '/forgot-password',
  RESET_PASSWORD: '/reset-password',
  PROFILE: '/profile',
  AUTHORIZE: '/oauth/authorize',
  ERROR: '/error',
};


/* ===== C:\Users\icipa\team-platform-public\id_frontend\src\utils\errors.ts ===== */

// ============= src/utils/errors.ts =============

import { AxiosError } from 'axios';
import { ERROR_MESSAGES } from './constants';

export class AppError extends Error {
  public code?: string;
  public details?: any;

  constructor(message: string, code?: string, details?: any) {
    super(message);
    this.name = 'AppError';
    this.code = code;
    this.details = details;
  }
}

// replace handleApiError with:
export const handleApiError = (error: unknown): string => {
  if (error instanceof AxiosError) {
    const data = error.response?.data as any;

    const flatten = (v: any): string => {
      if (!v) return '';
      if (typeof v === 'string') return v;
      if (Array.isArray(v)) return v.map(flatten).filter(Boolean).join('\n');
      if (typeof v === 'object') return Object.values(v).map(flatten).filter(Boolean).join('\n') || JSON.stringify(v);
      return String(v);
    };

    const msg =
      flatten(data?.message) ||
      flatten(data?.error) ||
      flatten(data?.details);

    if (msg) return msg;

    switch (error.response?.status) {
      case 400: return ERROR_MESSAGES.VALIDATION_ERROR;
      case 401: return ERROR_MESSAGES.UNAUTHORIZED;
      case 403: return ERROR_MESSAGES.FORBIDDEN;
      case 404: return ERROR_MESSAGES.NOT_FOUND;
      case 500:
      case 502:
      case 503: return ERROR_MESSAGES.SERVER_ERROR;
      default:
        return error.response ? ERROR_MESSAGES.UNKNOWN_ERROR : ERROR_MESSAGES.NETWORK_ERROR;
    }
  }
  if (error instanceof Error) return error.message;
  return ERROR_MESSAGES.UNKNOWN_ERROR;
};


export const isNetworkError = (error: unknown): boolean => {
  if (error instanceof AxiosError) {
    return !error.response && error.code === 'ERR_NETWORK';
  }
  return false;
};

export const isUnauthorizedError = (error: unknown): boolean => {
  if (error instanceof AxiosError) {
    return error.response?.status === 401;
  }
  return false;
};


/* ===== C:\Users\icipa\team-platform-public\id_frontend\src\utils\validators.ts ===== */

// ============= src/utils/validators.ts =============

import { PASSWORD_MIN_LENGTH, USERNAME_MIN_LENGTH, USERNAME_MAX_LENGTH, CODE_LENGTH } from './constants';

export interface ValidationResult {
  isValid: boolean;
  error?: string;
}

export const validators = {
  email: (email: string): ValidationResult => {
    if (!email) {
      return { isValid: false, error: 'Email обязателен' };
    }
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return { isValid: false, error: 'Неверный формат email' };
    }
    return { isValid: true };
  },

  username: (username: string): ValidationResult => {
    if (!username) {
      return { isValid: false, error: 'Имя пользователя обязательно' };
    }
    if (username.length < USERNAME_MIN_LENGTH) {
      return { isValid: false, error: `Минимум ${USERNAME_MIN_LENGTH} символа` };
    }
    if (username.length > USERNAME_MAX_LENGTH) {
      return { isValid: false, error: `Максимум ${USERNAME_MAX_LENGTH} символов` };
    }
    const usernameRegex = /^[a-zA-Z0-9_-]+$/;
    if (!usernameRegex.test(username)) {
      return { isValid: false, error: 'Только буквы, цифры, _ и -' };
    }
    return { isValid: true };
  },

  password: (password: string): ValidationResult => {
    if (!password) {
      return { isValid: false, error: 'Пароль обязателен' };
    }
    if (password.length < PASSWORD_MIN_LENGTH) {
      return { isValid: false, error: `Минимум ${PASSWORD_MIN_LENGTH} символов` };
    }
    if (/^\d+$/.test(password)) {
      return { isValid: false, error: 'Пароль не может состоять только из цифр' };
    }
    return { isValid: true };
  },

  passwordConfirm: (password: string, confirmPassword: string): ValidationResult => {
    if (!confirmPassword) {
      return { isValid: false, error: 'Подтвердите пароль' };
    }
    if (password !== confirmPassword) {
      return { isValid: false, error: 'Пароли не совпадают' };
    }
    return { isValid: true };
  },

  code: (code: string): ValidationResult => {
    if (!code) {
      return { isValid: false, error: 'Код обязателен' };
    }
    const re = new RegExp(`^\\d{${CODE_LENGTH}}$`)
    if (!re.test(code)) {
      return { isValid: false, error: `Код должен состоять из ${CODE_LENGTH} цифр` };
    }
    return { isValid: true };
  },
};

export const getPasswordStrength = (password: string): {
  score: number;
  label: string;
  color: string;
} => {
  let score = 0;
  
  if (password.length >= 8) score++;
  if (password.length >= 12) score++;
  if (/[a-z]/.test(password)) score++;
  if (/[A-Z]/.test(password)) score++;
  if (/[0-9]/.test(password)) score++;
  if (/[^a-zA-Z0-9]/.test(password)) score++;
  
  const strength = [
    { min: 0, label: 'Очень слабый', color: '#ff4444' },
    { min: 2, label: 'Слабый', color: '#ff8800' },
    { min: 3, label: 'Средний', color: '#ffbb00' },
    { min: 4, label: 'Хороший', color: '#88dd00' },
    { min: 5, label: 'Отличный', color: '#00cc00' },
  ];
  
  const result = strength.reverse().find(s => score >= s.min) || strength[0];
  
  return {
    score: Math.min(score / 6, 1),
    label: result.label,
    color: result.color,
  };
};


export const isWeakPassword = (_pwd: string): boolean => false;



/* ===== C:\Users\icipa\team-platform-public\id_frontend\src\vite-env.d.ts ===== */

/// <reference types="vite/client" />
declare module '*.scss';


/* ===== C:\Users\icipa\team-platform-public\id_frontend\tsconfig.app.json ===== */

{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",


    

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": false
  },
  "include": ["src"]
}



/* ===== C:\Users\icipa\team-platform-public\id_frontend\tsconfig.json ===== */

{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}



/* ===== C:\Users\icipa\team-platform-public\id_frontend\tsconfig.node.json ===== */

{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}



/* ===== C:\Users\icipa\team-platform-public\id_frontend\vite.config.ts ===== */

// vite.config.ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  resolve: { alias: { '@': path.resolve(__dirname, './src') } },
  server: {
    host: true,
    port: 5173,
    hmr: {
      protocol: 'ws',
      clientPort: 80,   
    },
  },
})


