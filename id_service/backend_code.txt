

/* ===== C:\Users\icipa\team-platform-public\id_service\alembic.ini ===== */

# A generic, single database configuration.

[alembic]
# path to migration scripts
script_location = alembic

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
# Uncomment the line below if you want the files to be prepended with date and time
file_template = %%(year)d%%(month).2d%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.
prepend_sys_path = .

# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the python-dateutil library
# one of: postgresql, mysql, sqlite, mssql
# leave blank for auto-detection
sqlalchemy.url = postgresql://postgres:password@localhost/id_service

# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S


/* ===== C:\Users\icipa\team-platform-public\id_service\alembic\env.py ===== */

# id_service/alembic/env.py
from __future__ import annotations

import asyncio
from logging.config import fileConfig

from alembic import context
from sqlalchemy import pool
from sqlalchemy.engine import Connection
from sqlalchemy.ext.asyncio import AsyncEngine, create_async_engine

from core.config import settings
from db.base import Base

config = context.config
if config.config_file_name:
    fileConfig(config.config_file_name)

target_metadata = Base.metadata

def run_migrations_offline() -> None:
    url = settings.DATABASE_URL.replace("+asyncpg", "")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
        compare_type=True,
        compare_server_default=True,
        version_table="alembic_version",
    )
    with context.begin_transaction():
        context.run_migrations()

def do_run_migrations(connection: Connection) -> None:
    context.configure(
        connection=connection,
        target_metadata=target_metadata,
        compare_type=True,
        compare_server_default=True,
        version_table="alembic_version",
    )
    with context.begin_transaction():
        context.run_migrations()

async def run_migrations_online() -> None:
    engine: AsyncEngine = create_async_engine(
        settings.DATABASE_URL,
        poolclass=pool.NullPool,
        future=True,
    )
    async with engine.connect() as conn:
        await conn.run_sync(do_run_migrations)
    await engine.dispose()

if context.is_offline_mode():
    run_migrations_offline()
else:
    asyncio.run(run_migrations_online())



/* ===== C:\Users\icipa\team-platform-public\id_service\alembic\versions\20250101_000000_initial.py ===== */

# id_service/alembic/versions/20250101_000000_initial.py

"""initial

Revision ID: 0001_initial
Revises:
Create Date: 2025-01-01 00:00:00
"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql as psql

# revision identifiers, used by Alembic.
revision = "0001_initial"
down_revision = None
branch_labels = None
depends_on = None


def upgrade() -> None:
    # --- ENUM types: создаём один раз вручную и переиспользуем ---
   
    client_type = psql.ENUM("public", "confidential", name="clienttype", create_type=False)
    token_auth_method = psql.ENUM("none", "client_secret_post", "client_secret_basic", name="tokenauthmethod", create_type=False)
    
    email_code_purpose = psql.ENUM(
        "register", "reset", "change_email",
        name="emailcodepurpose",
        create_type=False,
    )

    bind = op.get_bind()
    client_type.create(bind, checkfirst=True)
    token_auth_method.create(bind, checkfirst=True)
    email_code_purpose.create(bind, checkfirst=True)

    # --- users ---
    op.create_table(
        "users",
        sa.Column("id", psql.UUID(as_uuid=True), primary_key=True, nullable=False),
        sa.Column("email", sa.String(length=255), nullable=False),
        sa.Column("username", sa.String(length=50), nullable=False),
        sa.Column("password_hash", sa.Text(), nullable=False),
        sa.Column("email_verified", sa.Boolean(), nullable=False, server_default=sa.text("false")),
        sa.Column("failed_login_attempts", sa.Integer(), nullable=False, server_default=sa.text("0")),
        sa.Column("last_login_at", sa.DateTime(timezone=True), nullable=True),
        sa.Column("last_password_change_at", sa.DateTime(timezone=True), nullable=True),
        sa.Column("created_at", sa.DateTime(timezone=True), nullable=False, server_default=sa.text("now()")),
        sa.Column("updated_at", sa.DateTime(timezone=True), nullable=False, server_default=sa.text("now()")),
        sa.Column("deleted_at", sa.DateTime(timezone=True), nullable=True),
    )
    op.create_index("ux_users_email_lower", "users", [sa.text("lower(email)")], unique=True)
    op.create_index("ux_users_username", "users", ["username"], unique=True)

    # --- clients ---
    op.create_table(
        "clients",
        sa.Column("id", psql.UUID(as_uuid=True), primary_key=True, nullable=False),
        sa.Column("client_id", sa.String(length=255), nullable=False),
        sa.Column("name", sa.String(length=255), nullable=False),
        sa.Column("type", client_type, nullable=False, server_default=sa.text("'public'::clienttype")),
        sa.Column("token_endpoint_auth_method", token_auth_method, nullable=False, server_default=sa.text("'none'::tokenauthmethod")),
        sa.Column("pkce_required", sa.Boolean(), nullable=False, server_default=sa.text("true")),
        sa.Column("redirect_uris", psql.JSONB(astext_type=sa.Text()), nullable=False, server_default=sa.text("'[]'::jsonb")),
        sa.Column("post_logout_redirect_uris", psql.JSONB(astext_type=sa.Text()), nullable=False, server_default=sa.text("'[]'::jsonb")),
        sa.Column("backchannel_logout_uri", sa.Text(), nullable=True),
        sa.Column("frontchannel_logout_uri", sa.Text(), nullable=True),
        sa.Column("scopes", psql.JSONB(astext_type=sa.Text()), nullable=False, server_default=sa.text("'[\"openid\",\"email\",\"profile\"]'::jsonb")),
        sa.Column("client_secret_hash", sa.Text(), nullable=True),
        sa.Column("secret_rotated_at", sa.DateTime(timezone=True), nullable=True),
        sa.Column("created_at", sa.DateTime(timezone=True), nullable=False, server_default=sa.text("now()")),
        sa.Column("updated_at", sa.DateTime(timezone=True), nullable=False, server_default=sa.text("now()")),
        sa.UniqueConstraint("client_id", name="ux_clients_client_id"),
    )

    # --- jwk_keys ---
    op.create_table(
        "jwk_keys",
        sa.Column("id", psql.UUID(as_uuid=True), primary_key=True, nullable=False),
        sa.Column("kid", sa.String(length=255), nullable=False),
        sa.Column("alg", sa.String(length=10), nullable=False, server_default="RS256"),
        sa.Column("public_pem", sa.Text(), nullable=False),
        sa.Column("private_pem_encrypted", sa.Text(), nullable=False),
        sa.Column("active", sa.Boolean(), nullable=False, server_default=sa.text("true")),
        sa.Column("created_at", sa.DateTime(timezone=True), nullable=False, server_default=sa.text("now()")),
        sa.Column("rotated_at", sa.DateTime(timezone=True), nullable=True),
        sa.Column("expires_at", sa.DateTime(timezone=True), nullable=True),
    )
    op.create_index("ix_jwk_keys_active_kid", "jwk_keys", ["active", "kid"])
    op.create_index(op.f("ix_jwk_keys_kid"), "jwk_keys", ["kid"], unique=True)

    # --- auth_codes ---
    op.create_table(
        "auth_codes",
        sa.Column("id", psql.UUID(as_uuid=True), primary_key=True, nullable=False),
        sa.Column("code_hash", sa.String(length=255), nullable=False),
        sa.Column("client_id", sa.String(length=255), sa.ForeignKey("clients.client_id"), nullable=False),
        sa.Column("user_id", psql.UUID(as_uuid=True), sa.ForeignKey("users.id"), nullable=False),
        sa.Column("redirect_uri", sa.Text(), nullable=False),
        sa.Column("scope", sa.String(length=500), nullable=False),
        sa.Column("code_challenge_hash", sa.String(length=255), nullable=True),
        sa.Column("nonce", sa.String(length=255), nullable=True),
        sa.Column("state", sa.String(length=500), nullable=True),
        sa.Column("auth_time", sa.DateTime(timezone=True), nullable=False),
        sa.Column("expires_at", sa.DateTime(timezone=True), nullable=False),
        sa.Column("used_at", sa.DateTime(timezone=True), nullable=True),
        sa.Column("ip_address", sa.String(length=45), nullable=True),
        sa.Column("user_agent", sa.Text(), nullable=True),
        sa.UniqueConstraint("code_hash"),
    )
    op.create_index(op.f("ix_auth_codes_code_hash"), "auth_codes", ["code_hash"])
    op.create_index(op.f("ix_auth_codes_expires_at"), "auth_codes", ["expires_at"])

    # --- email_codes ---
    op.create_table(
        "email_codes",
        sa.Column("id", psql.UUID(as_uuid=True), primary_key=True, nullable=False),
        sa.Column("user_id", psql.UUID(as_uuid=True), sa.ForeignKey("users.id"), nullable=False),
        sa.Column("purpose", email_code_purpose, nullable=False),
        sa.Column("code_hash", sa.String(length=255), nullable=False),
        sa.Column("new_email", sa.String(length=255), nullable=True),
        sa.Column("expires_at", sa.DateTime(timezone=True), nullable=False),
        sa.Column("attempts", sa.Integer(), nullable=False, server_default=sa.text("0")),
        sa.Column("resend_after", sa.DateTime(timezone=True), nullable=False),
        sa.Column("used_at", sa.DateTime(timezone=True), nullable=True),
        sa.Column("ip_address", sa.String(length=45), nullable=True),
        sa.Column("user_agent", sa.Text(), nullable=True),
    )
    op.create_index("ix_email_codes_user_purpose", "email_codes", ["user_id", "purpose", "expires_at"])

    # --- refresh_tokens ---
    op.create_table(
        "refresh_tokens",
        sa.Column("id", psql.UUID(as_uuid=True), primary_key=True, nullable=False),
        sa.Column("jti", sa.String(length=255), nullable=False),
        sa.Column("user_id", psql.UUID(as_uuid=True), sa.ForeignKey("users.id"), nullable=False),
        sa.Column("client_id", sa.String(length=255), sa.ForeignKey("clients.client_id"), nullable=False),
        sa.Column("parent_jti", sa.String(length=255), nullable=True),
        sa.Column("prev_jti", sa.String(length=255), nullable=True),
        sa.Column("scope", sa.String(length=500), nullable=False),
        sa.Column("created_at", sa.DateTime(timezone=True), nullable=False),
        sa.Column("expires_at", sa.DateTime(timezone=True), nullable=False),
        sa.Column("rotated_at", sa.DateTime(timezone=True), nullable=True),
        sa.Column("revoked_at", sa.DateTime(timezone=True), nullable=True),
        sa.Column("revoked_reason", sa.String(length=255), nullable=True),
        sa.Column("ip_address", sa.String(length=45), nullable=True),
        sa.Column("user_agent", sa.Text(), nullable=True),
        sa.UniqueConstraint("jti"),
    )
    op.create_index("ix_refresh_tokens_user_client", "refresh_tokens", ["user_id", "client_id", "revoked_at", "expires_at"])
    op.create_index(op.f("ix_refresh_tokens_parent_jti"), "refresh_tokens", ["parent_jti"])
    op.create_index(op.f("ix_refresh_tokens_expires_at"), "refresh_tokens", ["expires_at"])
    op.create_index(op.f("ix_refresh_tokens_jti"), "refresh_tokens", ["jti"], unique=True)

    # --- idp_sessions ---
    op.create_table(
        "idp_sessions",
        sa.Column("id", psql.UUID(as_uuid=True), primary_key=True, nullable=False),
        sa.Column("session_id", sa.String(length=255), nullable=False),
        sa.Column("user_id", psql.UUID(as_uuid=True), sa.ForeignKey("users.id"), nullable=False),
        sa.Column("last_seen_at", sa.DateTime(timezone=True), nullable=False),
        sa.Column("idle_expires_at", sa.DateTime(timezone=True), nullable=False),
        sa.Column("max_expires_at", sa.DateTime(timezone=True), nullable=False),
        sa.Column("ip_address", sa.String(length=45), nullable=True),
        sa.Column("user_agent", sa.Text(), nullable=True),
        sa.Column("created_at", sa.DateTime(timezone=True), nullable=False),
        sa.Column("revoked_at", sa.DateTime(timezone=True), nullable=True),
        sa.UniqueConstraint("session_id"),
    )
    op.create_index("ix_idp_sessions_user_revoked", "idp_sessions", ["user_id", "revoked_at"])
    op.create_index(op.f("ix_idp_sessions_idle_expires_at"), "idp_sessions", ["idle_expires_at"])
    op.create_index(op.f("ix_idp_sessions_max_expires_at"), "idp_sessions", ["max_expires_at"])
    op.create_index(op.f("ix_idp_sessions_session_id"), "idp_sessions", ["session_id"], unique=True)


def downgrade() -> None:
    op.drop_table("idp_sessions")
    op.drop_table("refresh_tokens")
    op.drop_table("email_codes")
    op.drop_table("auth_codes")
    op.drop_index("ix_jwk_keys_active_kid", table_name="jwk_keys")
    op.drop_index(op.f("ix_jwk_keys_kid"), table_name="jwk_keys")
    op.drop_table("jwk_keys")
    op.drop_table("clients")
    op.drop_index("ux_users_email_lower", table_name="users")
    op.drop_index("ux_users_username", table_name="users")
    op.drop_table("users")

    # enums (дропаем в конце)
    bind = op.get_bind()
    psql.ENUM(name="emailcodepurpose").drop(bind, checkfirst=True)
    psql.ENUM(name="tokenauthmethod").drop(bind, checkfirst=True)
    psql.ENUM(name="clienttype").drop(bind, checkfirst=True)



/* ===== C:\Users\icipa\team-platform-public\id_service\alembic\versions\20250822_1640-624ce4ceb2ee_rename_enum_values_to_lowercase_fix_.py ===== */

"""rename enum values to lowercase & fix defaults

Revision ID: 624ce4ceb2ee
Revises: f94c88b39bdb
Create Date: 2025-08-22 16:40:42.534939

"""

# id_service/alembic/versions/20250822_1640-624ce4ceb2ee_rename_enum_values_to_lowercase_fix_.py
from alembic import op
import sqlalchemy as sa

revision = "624ce4ceb2ee"
down_revision = "f94c88b39bdb"
branch_labels = None
depends_on = None

def upgrade() -> None:
    # убрать дефолты на время изменения enum
    op.alter_column("clients", "type", server_default=None)
    op.alter_column("clients", "token_endpoint_auth_method", server_default=None)

    # clienttype
    op.execute("""
    DO $$
    BEGIN
      IF EXISTS (
        SELECT 1 FROM pg_type t
        JOIN pg_enum e ON e.enumtypid = t.oid
        WHERE t.typname = 'clienttype' AND e.enumlabel = 'PUBLIC'
      ) THEN
        ALTER TYPE clienttype RENAME VALUE 'PUBLIC' TO 'public';
      END IF;

      IF EXISTS (
        SELECT 1 FROM pg_type t
        JOIN pg_enum e ON e.enumtypid = t.oid
        WHERE t.typname = 'clienttype' AND e.enumlabel = 'CONFIDENTIAL'
      ) THEN
        ALTER TYPE clienttype RENAME VALUE 'CONFIDENTIAL' TO 'confidential';
      END IF;
    END$$;
    """)

    # tokenauthmethod
    op.execute("""
    DO $$
    BEGIN
      IF EXISTS (
        SELECT 1 FROM pg_type t
        JOIN pg_enum e ON e.enumtypid = t.oid
        WHERE t.typname = 'tokenauthmethod' AND e.enumlabel = 'NONE'
      ) THEN
        ALTER TYPE tokenauthmethod RENAME VALUE 'NONE' TO 'none';
      END IF;

      IF EXISTS (
        SELECT 1 FROM pg_type t
        JOIN pg_enum e ON e.enumtypid = t.oid
        WHERE t.typname = 'tokenauthmethod' AND e.enumlabel = 'CLIENT_SECRET_POST'
      ) THEN
        ALTER TYPE tokenauthmethod RENAME VALUE 'CLIENT_SECRET_POST' TO 'client_secret_post';
      END IF;

      IF EXISTS (
        SELECT 1 FROM pg_type t
        JOIN pg_enum e ON e.enumtypid = t.oid
        WHERE t.typname = 'tokenauthmethod' AND e.enumlabel = 'CLIENT_SECRET_BASIC'
      ) THEN
        ALTER TYPE tokenauthmethod RENAME VALUE 'CLIENT_SECRET_BASIC' TO 'client_secret_basic';
      END IF;
    END$$;
    """)

    # вернуть дефолты в нижнем регистре
    op.alter_column("clients", "type", server_default=sa.text("'public'::clienttype"))
    op.alter_column(
        "clients",
        "token_endpoint_auth_method",
        server_default=sa.text("'none'::tokenauthmethod"),
    )

def downgrade() -> None:
    op.alter_column("clients", "type", server_default=None)
    op.alter_column("clients", "token_endpoint_auth_method", server_default=None)

    op.execute("""
    DO $$
    BEGIN
      IF EXISTS (
        SELECT 1 FROM pg_type t
        JOIN pg_enum e ON e.enumtypid = t.oid
        WHERE t.typname = 'clienttype' AND e.enumlabel = 'public'
      ) THEN
        ALTER TYPE clienttype RENAME VALUE 'public' TO 'PUBLIC';
      END IF;

      IF EXISTS (
        SELECT 1 FROM pg_type t
        JOIN pg_enum e ON e.enumtypid = t.oid
        WHERE t.typname = 'clienttype' AND e.enumlabel = 'confidential'
      ) THEN
        ALTER TYPE clienttype RENAME VALUE 'confidential' TO 'CONFIDENTIAL';
      END IF;
    END$$;
    """)

    op.execute("""
    DO $$
    BEGIN
      IF EXISTS (
        SELECT 1 FROM pg_type t
        JOIN pg_enum e ON e.enumtypid = t.oid
        WHERE t.typname = 'tokenauthmethod' AND e.enumlabel = 'none'
      ) THEN
        ALTER TYPE tokenauthmethod RENAME VALUE 'none' TO 'NONE';
      END IF;

      IF EXISTS (
        SELECT 1 FROM pg_type t
        JOIN pg_enum e ON e.enumtypid = t.oid
        WHERE t.typname = 'tokenauthmethod' AND e.enumlabel = 'client_secret_post'
      ) THEN
        ALTER TYPE tokenauthmethod RENAME VALUE 'client_secret_post' TO 'CLIENT_SECRET_POST';
      END IF;

      IF EXISTS (
        SELECT 1 FROM pg_type t
        JOIN pg_enum e ON e.enumtypid = t.oid
        WHERE t.typname = 'tokenauthmethod' AND e.enumlabel = 'client_secret_basic'
      ) THEN
        ALTER TYPE tokenauthmethod RENAME VALUE 'client_secret_basic' TO 'CLIENT_SECRET_BASIC';
      END IF;
    END$$;
    """)

    op.alter_column("clients", "type", server_default=sa.text("'PUBLIC'::clienttype"))
    op.alter_column(
        "clients",
        "token_endpoint_auth_method",
        server_default=sa.text("'NONE'::tokenauthmethod"),
    )



/* ===== C:\Users\icipa\team-platform-public\id_service\alembic\versions\20250822_1914-4844acc09d05_fix_enum_case.py ===== */

"""fix enum case

Revision ID: 4844acc09d05
Revises: 0001_initial
Create Date: 2025-08-22 19:14:18.705987

"""

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '4844acc09d05'
down_revision = '0001_initial'
branch_labels = None
depends_on = None

def upgrade() -> None:
    # Переименовать значения enum'ов, если они ещё в UPPERCASE
    op.execute("""
    DO $$
    BEGIN
        IF EXISTS (
            SELECT 1 FROM pg_type t
            JOIN pg_enum e ON t.oid = e.enumtypid
            WHERE t.typname = 'clienttype' AND e.enumlabel = 'PUBLIC'
        ) THEN
            ALTER TYPE clienttype RENAME VALUE 'PUBLIC' TO 'public';
        END IF;
    END$$;
    """)

    op.execute("""
    DO $$
    BEGIN
        IF EXISTS (
            SELECT 1 FROM pg_type t
            JOIN pg_enum e ON t.oid = e.enumtypid
            WHERE t.typname = 'tokenauthmethod' AND e.enumlabel = 'NONE'
        ) THEN
            ALTER TYPE tokenauthmethod RENAME VALUE 'NONE' TO 'none';
        END IF;
        IF EXISTS (
            SELECT 1 FROM pg_type t
            JOIN pg_enum e ON t.oid = e.enumtypid
            WHERE t.typname = 'tokenauthmethod' AND e.enumlabel = 'CLIENT_SECRET_POST'
        ) THEN
            ALTER TYPE tokenauthmethod RENAME VALUE 'CLIENT_SECRET_POST' TO 'client_secret_post';
        END IF;
        IF EXISTS (
            SELECT 1 FROM pg_type t
            JOIN pg_enum e ON t.oid = e.enumtypid
            WHERE t.typname = 'tokenauthmethod' AND e.enumlabel = 'CLIENT_SECRET_BASIC'
        ) THEN
            ALTER TYPE tokenauthmethod RENAME VALUE 'CLIENT_SECRET_BASIC' TO 'client_secret_basic';
        END IF;
    END$$;
    """)

    # Обновить server_default'ы
    op.alter_column(
        "clients", "type",
        server_default=sa.text("'public'::clienttype"),
        existing_type=sa.Enum(name="clienttype"),
    )
    op.alter_column(
        "clients", "token_endpoint_auth_method",
        server_default=sa.text("'none'::tokenauthmethod"),
        existing_type=sa.Enum(name="tokenauthmethod"),
    )


def downgrade() -> None:
    # Откатить значения enum'ов обратно в UPPERCASE (на случай даунгрейда)
    op.execute("""
    DO $$
    BEGIN
        IF EXISTS (
            SELECT 1 FROM pg_type t
            JOIN pg_enum e ON t.oid = e.enumtypid
            WHERE t.typname = 'clienttype' AND e.enumlabel = 'public'
        ) THEN
            ALTER TYPE clienttype RENAME VALUE 'public' TO 'PUBLIC';
        END IF;
    END$$;
    """)

    op.execute("""
    DO $$
    BEGIN
        IF EXISTS (
            SELECT 1 FROM pg_type t
            JOIN pg_enum e ON t.oid = e.enumtypid
            WHERE t.typname = 'tokenauthmethod' AND e.enumlabel = 'client_secret_basic'
        ) THEN
            ALTER TYPE tokenauthmethod RENAME VALUE 'client_secret_basic' TO 'CLIENT_SECRET_BASIC';
        END IF;
        IF EXISTS (
            SELECT 1 FROM pg_type t
            JOIN pg_enum e ON t.oid = e.enumtypid
            WHERE t.typname = 'tokenauthmethod' AND e.enumlabel = 'client_secret_post'
        ) THEN
            ALTER TYPE tokenauthmethod RENAME VALUE 'client_secret_post' TO 'CLIENT_SECRET_POST';
        END IF;
        IF EXISTS (
            SELECT 1 FROM pg_type t
            JOIN pg_enum e ON t.oid = e.enumtypid
            WHERE t.typname = 'tokenauthmethod' AND e.enumlabel = 'none'
        ) THEN
            ALTER TYPE tokenauthmethod RENAME VALUE 'none' TO 'NONE';
        END IF;
    END$$;
    """)

    op.alter_column(
        "clients", "type",
        server_default=sa.text("'PUBLIC'::clienttype"),
        existing_type=sa.Enum(name="clienttype"),
    )
    op.alter_column(
        "clients", "token_endpoint_auth_method",
        server_default=sa.text("'NONE'::tokenauthmethod"),
        existing_type=sa.Enum(name="tokenauthmethod"),
    )



/* ===== C:\Users\icipa\team-platform-public\id_service\alembic\versions\20250822_1929-f94c88b39bdb_lowercase_enums_and_defaults.py ===== */

"""lowercase enums and defaults

Revision ID: f94c88b39bdb
Revises: 4844acc09d05
Create Date: 2025-08-22 19:29:09.507410

"""

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'f94c88b39bdb'
down_revision = '4844acc09d05'
branch_labels = None
depends_on = None

def upgrade() -> None:
    # Переименовать значения ENUM, если они ещё в верхнем регистре
    op.execute("""
    DO $$
    BEGIN
      IF EXISTS (
        SELECT 1 FROM pg_enum e JOIN pg_type t ON t.oid=e.enumtypid
        WHERE t.typname='clienttype' AND e.enumlabel='PUBLIC'
      ) THEN
        ALTER TYPE clienttype RENAME VALUE 'PUBLIC' TO 'public';
      END IF;

      IF EXISTS (
        SELECT 1 FROM pg_enum e JOIN pg_type t ON t.oid=e.enumtypid
        WHERE t.typname='clienttype' AND e.enumlabel='CONFIDENTIAL'
      ) THEN
        ALTER TYPE clienttype RENAME VALUE 'CONFIDENTIAL' TO 'confidential';
      END IF;

      IF EXISTS (
        SELECT 1 FROM pg_enum e JOIN pg_type t ON t.oid=e.enumtypid
        WHERE t.typname='tokenauthmethod' AND e.enumlabel='NONE'
      ) THEN
        ALTER TYPE tokenauthmethod RENAME VALUE 'NONE' TO 'none';
      END IF;

      IF EXISTS (
        SELECT 1 FROM pg_enum e JOIN pg_type t ON t.oid=e.enumtypid
        WHERE t.typname='tokenauthmethod' AND e.enumlabel='CLIENT_SECRET_POST'
      ) THEN
        ALTER TYPE tokenauthmethod RENAME VALUE 'CLIENT_SECRET_POST' TO 'client_secret_post';
      END IF;

      IF EXISTS (
        SELECT 1 FROM pg_enum e JOIN pg_type t ON t.oid=e.enumtypid
        WHERE t.typname='tokenauthmethod' AND e.enumlabel='CLIENT_SECRET_BASIC'
      ) THEN
        ALTER TYPE tokenauthmethod RENAME VALUE 'CLIENT_SECRET_BASIC' TO 'client_secret_basic';
      END IF;
    END $$;
    """)

    # Обновить дефолты в таблице clients
    op.execute("ALTER TABLE clients ALTER COLUMN type SET DEFAULT 'public'::clienttype")
    op.execute("""
        ALTER TABLE clients ALTER COLUMN token_endpoint_auth_method
        SET DEFAULT 'none'::tokenauthmethod
    """)


def downgrade() -> None:
    # Вернуть дефолты
    op.execute("""
        ALTER TABLE clients ALTER COLUMN token_endpoint_auth_method
        SET DEFAULT 'NONE'::tokenauthmethod
    """)
    op.execute("ALTER TABLE clients ALTER COLUMN type SET DEFAULT 'PUBLIC'::clienttype")

    # Вернуть значения ENUM в верхний регистр (если вдруг были понижены)
    op.execute("""
    DO $$
    BEGIN
      IF EXISTS (
        SELECT 1 FROM pg_enum e JOIN pg_type t ON t.oid=e.enumtypid
        WHERE t.typname='tokenauthmethod' AND e.enumlabel='client_secret_basic'
      ) THEN
        ALTER TYPE tokenauthmethod RENAME VALUE 'client_secret_basic' TO 'CLIENT_SECRET_BASIC';
      END IF;

      IF EXISTS (
        SELECT 1 FROM pg_enum e JOIN pg_type t ON t.oid=e.enumtypid
        WHERE t.typname='tokenauthmethod' AND e.enumlabel='client_secret_post'
      ) THEN
        ALTER TYPE tokenauthmethod RENAME VALUE 'client_secret_post' TO 'CLIENT_SECRET_POST';
      END IF;

      IF EXISTS (
        SELECT 1 FROM pg_enum e JOIN pg_type t ON t.oid=e.enumtypid
        WHERE t.typname='tokenauthmethod' AND e.enumlabel='none'
      ) THEN
        ALTER TYPE tokenauthmethod RENAME VALUE 'none' TO 'NONE';
      END IF;

      IF EXISTS (
        SELECT 1 FROM pg_enum e JOIN pg_type t ON t.oid=e.enumtypid
        WHERE t.typname='clienttype' AND e.enumlabel='confidential'
      ) THEN
        ALTER TYPE clienttype RENAME VALUE 'confidential' TO 'CONFIDENTIAL';
      END IF;

      IF EXISTS (
        SELECT 1 FROM pg_enum e JOIN pg_type t ON t.oid=e.enumtypid
        WHERE t.typname='clienttype' AND e.enumlabel='public'
      ) THEN
        ALTER TYPE clienttype RENAME VALUE 'public' TO 'PUBLIC';
      END IF;
    END $$;
    """)


/* ===== C:\Users\icipa\team-platform-public\id_service\api\account\__init__.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\api\account\delete_account.py ===== */

# id_service/api/account/delete_account.py


import logging
import asyncio
from fastapi import APIRouter, Request, Depends, HTTPException, status, Response
from sqlalchemy.ext.asyncio import AsyncSession

from db.session import get_async_session
from schemas.account import DeleteAccountRequest, DeleteAccountResponse
from api.account.profile import get_current_user
from services.session_service import session_service
from services.backchannel_logout import backchannel_logout_service
from crud import user_crud
from core.security import security

logger = logging.getLogger(__name__)
router = APIRouter()


@router.delete("/delete", response_model=DeleteAccountResponse)
async def delete_account(
    request: Request,
    delete_data: DeleteAccountRequest,
    session: AsyncSession = Depends(get_async_session),
    current_user = Depends(get_current_user),
    response: Response = None,
):
    """Delete user account (soft delete)"""
    
    # Verify password
    if not security.verify_password(delete_data.current_password, current_user.password_hash):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid password"
        )
    
    # Verify confirmation
    if delete_data.confirmation != "DELETE":
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Please type DELETE to confirm"
        )
    
    # Revoke all sessions
    _ = await session_service.revoke_all_user_sessions(session, str(current_user.id))

    # Очистить SSO cookie
    if response is not None:
        session_service.clear_session_cookie(response)

    # Revoke all refresh tokens and notify clients
    from services.token_service import token_service
    affected = await token_service.revoke_all_refresh_tokens_for_user(
        session, str(current_user.id), reason="account_deleted"
    )

    for cid in affected:
        asyncio.create_task(
            backchannel_logout_service.initiate_backchannel_logout(
                session=None,
                user=current_user,
                session_id=None,
                reason="account_deleted",
                only_client_id=cid
            )
        )

    
    # Soft delete user
    await user_crud.soft_delete(session, current_user)
    
    logger.info(f"Account deleted for user {current_user.id}")
    
    return DeleteAccountResponse(
        message="Account has been deleted"
    )


/* ===== C:\Users\icipa\team-platform-public\id_service\api\account\email_change.py ===== */

# id_service/api/account/email_change.py

import logging
import asyncio
from fastapi import APIRouter, Request, Depends, HTTPException, status, Response
from sqlalchemy.ext.asyncio import AsyncSession

from db.session import get_async_session
from schemas.account import (
    ChangeEmailRequest, ChangeEmailResponse,
    ConfirmEmailChangeRequest, ConfirmEmailChangeResponse
)
from api.account.profile import get_current_user
from services.email_service import email_service
from services.session_service import session_service
from services.backchannel_logout import backchannel_logout_service
from crud import user_crud
from utils.otp import otp_service
from utils.rate_limit import rate_limiter
from models import EmailCodePurpose
from core.security import security

logger = logging.getLogger(__name__)
router = APIRouter()


@router.post("/change-email/request", response_model=ChangeEmailResponse)
async def request_email_change(
    request: Request,
    change_data: ChangeEmailRequest,
    session: AsyncSession = Depends(get_async_session),
    current_user = Depends(get_current_user)
):
    """Request email change - sends verification code to new email"""
    
    # Rate limit
    await rate_limiter.check_rate_limit(request, "email_change", max_requests=3)
    
    # Verify current password
    if not security.verify_password(change_data.password, current_user.password_hash):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid password"
        )
    
    # Check if new email already exists
    if await user_crud.check_email_exists(
        session, 
        change_data.new_email,
        exclude_user_id=str(current_user.id)
    ):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already in use"
        )
    
    # Generate and send verification code to NEW email
    try:
        otp_code, email_code = await otp_service.create_otp(
            session=session,
            user=current_user,
            purpose=EmailCodePurpose.CHANGE_EMAIL,
            new_email=change_data.new_email,
            ip_address=request.client.host,
            user_agent=request.headers.get("User-Agent")
        )
        
        # Send verification email to NEW address
        await email_service.send_verification_code(
            to_email=change_data.new_email,
            username=current_user.username,
            code=otp_code,
            purpose="change_email"
        )
        
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_429_TOO_MANY_REQUESTS,
            detail=str(e)
        )
    
    logger.info(f"Email change requested for user {current_user.id}")
    
    return ChangeEmailResponse(
        message="Verification code sent to new email address"
    )


@router.post("/change-email/confirm", response_model=ConfirmEmailChangeResponse)
async def confirm_email_change(
    request: Request,
    confirm_data: ConfirmEmailChangeRequest,
    session: AsyncSession = Depends(get_async_session),
    current_user = Depends(get_current_user),
    response: Response = None,
):
    """Confirm email change with verification code"""
    
    # Rate limit
    await rate_limiter.check_rate_limit(request, "email_confirm", max_requests=10)
    
    # Verify OTP
    success, email_code, error = await otp_service.verify_otp(
        session=session,
        user_id=str(current_user.id),
        code=confirm_data.code,
        purpose=EmailCodePurpose.CHANGE_EMAIL
    )
    
    if not success:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=error or "Invalid verification code"
        )
    
    # Verify the new email matches
    if email_code.new_email != confirm_data.new_email.lower():
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email mismatch"
        )
    
    # Update email
    from schemas.user import UserUpdate
    user_update = UserUpdate(
        email=confirm_data.new_email,
        email_verified=True
    )
    await user_crud.update(session, current_user, user_update)
    
    # Revoke SSO sessions
    _ = await session_service.revoke_all_user_sessions(session, str(current_user.id))

    # Очистить SSO cookie
    if response is not None:
        session_service.clear_session_cookie(response)

    # Revoke refresh tokens and notify clients
    from services.token_service import token_service
    affected = await token_service.revoke_all_refresh_tokens_for_user(
        session, str(current_user.id), reason="email_changed"
    )

    
    for cid in affected:
        asyncio.create_task(
            backchannel_logout_service.initiate_backchannel_logout(
                session=None,
                user=current_user,
                session_id=None,
                reason="email_changed",
                only_client_id=cid
            )
        )

    
    logger.info(f"Email changed for user {current_user.id}")
    
    return ConfirmEmailChangeResponse(
        message="Email address updated successfully"
    )


/* ===== C:\Users\icipa\team-platform-public\id_service\api\account\password_change.py ===== */

# id_service/api/account/password_change.py


import logging
import asyncio
from fastapi import APIRouter, Request, Depends, HTTPException, status, Response
from sqlalchemy.ext.asyncio import AsyncSession

from db.session import get_async_session
from schemas.account import ChangePasswordRequest, ChangePasswordResponse
from api.account.profile import get_current_user
from services.email_service import email_service
from services.session_service import session_service
from services.backchannel_logout import backchannel_logout_service
from crud import user_crud
from core.security import security

logger = logging.getLogger(__name__)
router = APIRouter()


@router.post("/change-password", response_model=ChangePasswordResponse)
async def change_password(
    request: Request,
    change_data: ChangePasswordRequest,
    session: AsyncSession = Depends(get_async_session),
    current_user = Depends(get_current_user),
    response: Response = None
):
    """Change password for authenticated user"""
    
    # Verify old password
    if not security.verify_password(change_data.old_password, current_user.password_hash):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Current password is incorrect"
        )
    
    # Check new password is different
    if change_data.old_password == change_data.new_password:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="New password must be different from current password"
        )
    
    # Update password
    await user_crud.update_password(session, current_user, change_data.new_password)
    
    # Revoke all sessions
    _ = await session_service.revoke_all_user_sessions(session, str(current_user.id))

    # Очистить SSO cookie
    if response is not None:
        session_service.clear_session_cookie(response)

        
    
    # Revoke all refresh tokens and notify clients
    from services.token_service import token_service
    affected = await token_service.revoke_all_refresh_tokens_for_user(
        session, str(current_user.id), reason="password_changed"
    )
    for cid in affected:

        asyncio.create_task(
            backchannel_logout_service.initiate_backchannel_logout(
                session=None, user=current_user, session_id=None, reason="password_changed", only_client_id=cid
            )
        )
    

    
    logger.info(f"Password changed for user {current_user.id}")
    
    return ChangePasswordResponse(
        message="Password changed successfully"
    )


/* ===== C:\Users\icipa\team-platform-public\id_service\api\account\profile.py ===== */

# id_service/api/account/profile.py

import logging
from fastapi import APIRouter, Request, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession

from db.session import get_async_session
from schemas.account import ProfileResponse
from services.session_service import session_service
from crud import user_crud

logger = logging.getLogger(__name__)
router = APIRouter()


async def get_current_user(
    request: Request,
    session: AsyncSession = Depends(get_async_session)
):
    """Dependency to get current authenticated user"""
    
    # Get session from cookie
    idp_session = await session_service.get_session_from_cookie(session, request)
    if not idp_session:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated"
        )
    
    # Get user
    user = await user_crud.get_by_id(session, idp_session.user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    return user


@router.get("/profile", response_model=ProfileResponse)
async def get_profile(
    request: Request,
    session: AsyncSession = Depends(get_async_session),
    current_user = Depends(get_current_user)
):
    """Get current user profile"""
    
    return ProfileResponse(
        email=current_user.email,
        username=current_user.username,
        email_verified=current_user.email_verified,
        created_at=current_user.created_at,
        last_login_at=current_user.last_login_at
    )


/* ===== C:\Users\icipa\team-platform-public\id_service\api\auth\__init__.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\api\auth\csrf.py ===== */

# id_service/api/auth/csrf.py

from fastapi import APIRouter
from fastapi.responses import JSONResponse
from core.config import settings
from utils.csrf import csrf_protection

router = APIRouter()

@router.get("/csrf")
async def get_csrf():
    token = csrf_protection.generate_token()
    resp = JSONResponse({"csrf_token": token})
    resp.set_cookie(
        key=csrf_protection.cookie_name,
        value=token,
        path="/",
        httponly=False,  # double-submit
        secure=(settings.APP_ENV == "production"),
        samesite="lax",
    )
    return resp


/* ===== C:\Users\icipa\team-platform-public\id_service\api\auth\email_verification.py ===== */

# id_service/api/auth/email_verification.py
"""
Подтверждение e-mail — JSON-only.

Изменения:
- Убраны любые RedirectResponse.
- При наличии валидного pending state в Redis формируем redirect_to строкой без 302.
- Всегда ставим SSO-cookie на JSON-ответ.
"""

import logging
import json
from urllib.parse import urlencode

from fastapi import APIRouter, Request, Response, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession

from db.session import get_async_session
from schemas.auth import VerifyEmailRequest, VerifyEmailResponse
from crud import user_crud, client_crud
from services.session_service import session_service
from services.token_service import token_service
from utils.otp import otp_service
from utils.rate_limit import rate_limiter
from utils.validators import validators
from models import EmailCodePurpose
from core.config import settings

logger = logging.getLogger(__name__)
router = APIRouter()


@router.post("/verify-email", response_model=VerifyEmailResponse)
async def verify_email(
    request: Request,
    response: Response,
    verify_data: VerifyEmailRequest,
    session: AsyncSession = Depends(get_async_session),
):
    """
    Подтверждение e-mail по OTP коду.
    Поведение:
      - Если есть pending /authorize по state и redirect валиден — выпускаем code,
        привязываем sid, удаляем pending, возвращаем JSON с redirect_to.
      - Иначе обычный JSON без redirect_to.
      - ВО ВСЕХ случаях ставим SSO-cookie на этот JSON-ответ.
    """
    # 1) Rate limit
    await rate_limiter.check_rate_limit(request, "verify_email", max_requests=10)

    # 2) Пользователь
    user = await user_crud.get_by_id(session, verify_data.user_id)
    if not user:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User not found")

    # 3) Проверка OTP
    success, email_code, error = await otp_service.verify_otp(
        session=session,
        user_id=verify_data.user_id,
        code=verify_data.code,
        purpose=EmailCodePurpose.REGISTER,
    )
    if not success:
        await rate_limiter.add_failed_attempt(verify_data.user_id, "otp_verify", max_attempts=5)
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=error or "Invalid verification code")

    # 4) Отметить e-mail как верифицированный и очистить счётчик
    await user_crud.verify_email(session, user)
    await rate_limiter.clear_failed_attempts(verify_data.user_id, "otp_verify")

    # 5) Создать IdP-сессию
    idp_session = await session_service.create_session(session=session, user=user, request=request)

    # 6) OIDC-продолжение: собрать redirect_to, если есть валидный pending по state
    redirect_to: str | None = None
    if verify_data.state and rate_limiter.redis_client:
        raw = await rate_limiter.redis_client.get(f"authreq:{verify_data.state}")
        if raw:
            data = json.loads(raw)
            client = await client_crud.get_by_client_id(session, data.get("client_id"))
            redirect_uri = data.get("redirect_uri")
            if client and validators.validate_redirect_uri(redirect_uri, client.redirect_uris or []):
                # Выпустить authorization code
                code = await token_service.create_auth_code(
                    session=session,
                    user=user,
                    client=client,
                    redirect_uri=redirect_uri,
                    scope=data.get("scope", ""),
                    state=verify_data.state,
                    nonce=data.get("nonce"),
                    code_challenge=data.get("code_challenge"),
                    ip_address=request.client.host,
                    user_agent=request.headers.get("User-Agent"),
                )
                # Привязать sid к коду и удалить pending
                await rate_limiter.redis_client.setex(
                    f"authcode_sid:{code}", settings.AUTH_CODE_TTL, idp_session.session_id
                )
                await rate_limiter.redis_client.delete(f"authreq:{verify_data.state}")

                params = {"code": code, "state": verify_data.state}
                redirect_to = f"{redirect_uri}?{urlencode(params)}"

    # 7) Кука SSO — на текущий JSON-ответ
    session_service.set_session_cookie(response, idp_session.session_id)

    logger.info(f"Email verified for user {user.id}")
    return VerifyEmailResponse(ok=True, message="Email verified successfully", redirect_to=redirect_to)



/* ===== C:\Users\icipa\team-platform-public\id_service\api\auth\login.py ===== */

# id_service/api/auth/login.py
"""
Логин по паролю — JSON-only.
Цели:
- Принимаем JSON (никаких Form(...)).
- Проверка CSRF уже в CSRFMiddleware по заголовку X-CSRF-Token.
- На успехе всегда ставим SSO-cookie на JSON-ответ.
- Если есть валидные state+client_id в Redis (pending /authorize) — создаём code и
  возвращаем redirect_to строкой без 302. Иначе redirect_to = null.
"""

import logging
import json
from datetime import datetime, timezone
from typing import Optional
from urllib.parse import urlencode

from fastapi import APIRouter, Request, Response, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession

from db.session import get_async_session
from schemas.auth import LoginPasswordRequest, LoginPasswordResponse
from crud import user_crud, client_crud
from services.session_service import session_service
from services.token_service import token_service
from utils.rate_limit import rate_limiter
from utils.validators import validators
from core.security import security
from core.config import settings

logger = logging.getLogger(__name__)
router = APIRouter()


@router.post("/login-password", response_model=LoginPasswordResponse)
async def login_password(
    request: Request,
    response: Response,
    login_data: LoginPasswordRequest,
    session: AsyncSession = Depends(get_async_session),
):
    """
    Логин по паролю с JSON-телом.
    Поведение:
      - Успех без state: { ok:true, redirect_to:null } + установка SSO-cookie.
      - Успех с валидными state+client_id (pending в Redis): выдаём code, удаляем pending,
        возвращаем { ok:true, redirect_to:"<redirect_uri>?code=...&state=..." } + cookie.
    Ошибки: через HTTPException, их перехватит глобальный хендлер.
    """

    # 1) Rate limit
    await rate_limiter.check_rate_limit(request, "login", max_requests=10)

    # 2) Поиск пользователя и базовые проверки
    user = await user_crud.get_by_email(session, login_data.email)
    if not user:
        await rate_limiter.add_failed_attempt(login_data.email, "login")
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid email or password")

    if not security.verify_password(login_data.password, user.password_hash):
        await user_crud.update_login_info(session, user, success=False)
        await rate_limiter.add_failed_attempt(login_data.email, "login")
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid email or password")

    # Опциональная тихая пере-вычисляемость хэша
    if security.needs_rehash(user.password_hash):
        await user_crud.rehash_password(session, user, login_data.password)

    if not user.email_verified:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Please verify your email first")

    # 3) Успешный вход: аудит и очистка счётчиков
    await rate_limiter.clear_failed_attempts(login_data.email, "login")
    await user_crud.update_login_info(session, user, success=True)

    # 4) Создать IdP-сессию
    idp_session = await session_service.create_session(
        session=session,
        user=user,
        request=request,
        remember_me=login_data.remember_me,
    )
    # Вычислить max_age для куки из hard-max TTL сессии
    max_age = int((idp_session.max_expires_at - datetime.now(timezone.utc)).total_seconds())

    # 5) OIDC-продолжение, если пришли client_id+state и в Redis есть pending authreq
    redirect_to: Optional[str] = None
    if login_data.client_id and login_data.state and rate_limiter.redis_client:
        raw = await rate_limiter.redis_client.get(f"authreq:{login_data.state}")
        if raw:
            data = json.loads(raw)

            # Валидация клиента и redirect_uri
            client = await client_crud.get_by_client_id(session, login_data.client_id)
            if client and data.get("client_id") == login_data.client_id and validators.validate_redirect_uri(
                data.get("redirect_uri"), client.redirect_uris or []
            ):
                # Выпускаем одноразовый authorization code
                code = await token_service.create_auth_code(
                    session=session,
                    user=user,
                    client=client,
                    redirect_uri=data["redirect_uri"],
                    scope=data["scope"],
                    state=login_data.state,
                    nonce=data.get("nonce"),
                    code_challenge=data.get("code_challenge"),
                    ip_address=request.client.host,
                    user_agent=request.headers.get("User-Agent"),
                )

                # Привяжем sid к коду на TTL кода и удалим pending
                await rate_limiter.redis_client.setex(f"authcode_sid:{code}", settings.AUTH_CODE_TTL, idp_session.session_id)
                await rate_limiter.redis_client.delete(f"authreq:{login_data.state}")

                # Сформировать redirect_to строку для фронта
                params = {"code": code, "state": login_data.state}
                redirect_to = f'{data["redirect_uri"]}?{urlencode(params)}'

    # 6) Установить SSO-cookie на сам JSON-ответ
    session_service.set_session_cookie(response, idp_session.session_id, max_age=max_age)

    # 7) Вернуть унифицированный JSON-ответ без 302
    return LoginPasswordResponse(ok=True, message="Login successful", redirect_to=redirect_to)



/* ===== C:\Users\icipa\team-platform-public\id_service\api\auth\password_reset.py ===== */

# id_service/api/auth/password_reset.py


import logging
import asyncio
import secrets
from fastapi import APIRouter, Request, Depends, HTTPException, status, Response
from sqlalchemy.ext.asyncio import AsyncSession

from db.session import get_async_session
from schemas.auth import (
    ForgotPasswordRequest, ForgotPasswordResponse,
    VerifyResetRequest, VerifyResetResponse,
    SetNewPasswordRequest, SetNewPasswordResponse
)
from utils.rate_limit import rate_limiter
from crud import user_crud
from services.email_service import email_service
from services.session_service import session_service
from services.backchannel_logout import backchannel_logout_service
from services.token_service import token_service
from utils.otp import otp_service
from models import EmailCodePurpose

logger = logging.getLogger(__name__)
router = APIRouter()


@router.post("/forgot-password", response_model=ForgotPasswordResponse)
async def forgot_password(
    request: Request,
    forgot_data: ForgotPasswordRequest,
    session: AsyncSession = Depends(get_async_session)
):
    """Request password reset"""
    
    # Rate limit
    await rate_limiter.check_rate_limit(request, "forgot_password", max_requests=3)
    
    # Always return same response for security
    response_message = "If an account exists with this email, a reset code has been sent"
    
    # Find user
    user = await user_crud.get_by_email(session, forgot_data.email)
    if user:
        try:
            # Generate and send reset code
            otp_code, email_code = await otp_service.create_otp(
                session=session,
                user=user,
                purpose=EmailCodePurpose.RESET_PASSWORD,
                ip_address=request.client.host,
                user_agent=request.headers.get("User-Agent")
            )
            
            # Send reset email
            await email_service.send_verification_code(
                to_email=user.email,
                username=user.username,
                code=otp_code,
                purpose="reset"
            )
            
            logger.info(f"Password reset requested for user {user.id}")
            
        except Exception as e:
            logger.error(f"Failed to process password reset: {e}")
    
    return ForgotPasswordResponse(message=response_message)


@router.post("/verify-reset", response_model=VerifyResetResponse)
async def verify_reset(
    request: Request,
    verify_data: VerifyResetRequest,
    session: AsyncSession = Depends(get_async_session)
):
    """Verify password reset code"""
    
    # Rate limit
    await rate_limiter.check_rate_limit(request, "verify_reset", max_requests=10)
    
    # Find user
    user = await user_crud.get_by_email(session, verify_data.email)
    if not user:
        # одинаковый ответ, без утечки наличия e-mail
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid email or code"
        )

    
    # Verify OTP
    success, email_code, error = await otp_service.verify_otp(
        session=session,
        user_id=str(user.id),
        code=verify_data.code,
        purpose=EmailCodePurpose.RESET_PASSWORD
    )
    
    if not success:
        await rate_limiter.add_failed_attempt(
            verify_data.email,
            "reset_verify",
            max_attempts=5
        )
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=error or "Invalid reset code"
        )
    
    # Generate temporary reset token
    reset_token = secrets.token_urlsafe(32)
    # Store reset token in Redis (15 минут)
    if rate_limiter.redis_client:
        await rate_limiter.redis_client.setex(
            f"pwdreset:{user.id}", 900, reset_token
        )  
    
    return VerifyResetResponse(
        user_id=str(user.id),
        reset_token=reset_token
    )


@router.post("/set-new-password", response_model=SetNewPasswordResponse)
async def set_new_password(
    request: Request,
    reset_data: SetNewPasswordRequest,
    session: AsyncSession = Depends(get_async_session),
    response: Response = None,
):
    """Set new password after reset"""
    
    # Rate limit
    await rate_limiter.check_rate_limit(request, "set_password", max_requests=5)
    
    # Verify reset token (one-time)
    if not rate_limiter.redis_client:
        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail="Reset not available")
    stored = await rate_limiter.redis_client.get(f"pwdreset:{reset_data.user_id}")
    if not stored or stored != reset_data.reset_token:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Invalid reset token")
    await rate_limiter.redis_client.delete(f"pwdreset:{reset_data.user_id}")

    
    # Get user
    user = await user_crud.get_by_id(session, reset_data.user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Invalid reset token"
        )
    
    # Update password
    await user_crud.update_password(session, user, reset_data.new_password)

    # Revoke all sessions
    _ = await session_service.revoke_all_user_sessions(session, str(user.id))

    # Очистить SSO cookie
    if response is not None:
        session_service.clear_session_cookie(response)

    # Revoke all refresh tokens and notify clients
    
    affected = await token_service.revoke_all_refresh_tokens_for_user(
        session, str(user.id), reason="password_reset"
    )
    
    for cid in affected:
        asyncio.create_task(
            backchannel_logout_service.initiate_backchannel_logout(
                session=None, user=user, session_id=None, reason="password_reset", only_client_id=cid
            )
        )


    
    logger.info(f"Password reset completed for user {user.id}")
    
    return SetNewPasswordResponse(
        message="Password has been reset successfully"
    )


/* ===== C:\Users\icipa\team-platform-public\id_service\api\auth\register.py ===== */

# id_service/api/auth/register.py

import logging
from fastapi import APIRouter, Request, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession

from db.session import get_async_session
from schemas.auth import RegisterRequest, RegisterResponse
from schemas.user import UserCreate
from crud import user_crud
from services.email_service import email_service
from utils.otp import otp_service
from utils.rate_limit import rate_limiter
from models import EmailCodePurpose

logger = logging.getLogger(__name__)
router = APIRouter()


@router.post("/register", response_model=RegisterResponse)
async def register(request: Request, register_data: RegisterRequest, session: AsyncSession = Depends(get_async_session)):
    await rate_limiter.check_rate_limit(request, "register", max_requests=5)

    # смотрим существующий email
    existing = await user_crud.get_by_email(session, register_data.email)
    if existing:
        if existing.email_verified:
            raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="Email already registered")
        # email есть, но не подтверждён — возвращаем user_id и (по возможности) переотправляем код
        try:
            otp_code, _ = await otp_service.create_otp(
                session=session,
                user=existing,
                purpose=EmailCodePurpose.REGISTER,
                ip_address=request.client.host if request.client else None,
                user_agent=request.headers.get("User-Agent"),
            )
            await email_service.send_verification_code(
                to_email=existing.email,
                username=existing.username,
                code=otp_code,
                purpose="registration",
            )
            msg = "Verification code sent"
        except ValueError:
            # кулдаун — всё равно возвращаем успешный ответ, чтобы фронт ушёл на страницу кода
            msg = "Verification code was sent recently. Please check your email."
        return RegisterResponse(
            user_id=str(existing.id),
            email=existing.email,
            requires_verification=True,
            message=msg,
        )

    # проверка уникальности username только для новых
    if await user_crud.check_username_exists(session, register_data.username):
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Username already taken")

    # создаём пользователя
    user = await user_crud.create(session, UserCreate(
        email=register_data.email,
        username=register_data.username,
        password=register_data.password,
        email_verified=False,
    ))

    # шлём код (ошибки отправки не валят регистрацию)
    msg = "Registration successful. Please check your email for verification code."
    try:
        otp_code, _ = await otp_service.create_otp(
            session=session,
            user=user,
            purpose=EmailCodePurpose.REGISTER,
            ip_address=request.client.host if request.client else None,
            user_agent=request.headers.get("User-Agent"),
        )
        await email_service.send_verification_code(
            to_email=user.email,
            username=user.username,
            code=otp_code,
            purpose="registration",
        )
    except Exception:
        pass

    return RegisterResponse(
        user_id=str(user.id),
        email=user.email,
        requires_verification=True,
        message=msg,
    )


/* ===== C:\Users\icipa\team-platform-public\id_service\api\health.py ===== */

# id_service/api/health.py

from fastapi import APIRouter, Depends
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text

from db.session import get_async_session
from utils.rate_limit import rate_limiter

from fastapi.responses import JSONResponse


router = APIRouter()


@router.get("/health")
async def health():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "service": "id-service"
    }


@router.get("/health/ready")
async def readiness(session: AsyncSession = Depends(get_async_session)):
    """Readiness check with database connection"""
    try:
        # Check database
        await session.execute(text("SELECT 1"))
        
        # Check Redis
        redis_healthy = False
        if rate_limiter.redis_client:
            try:
                await rate_limiter.redis_client.ping()
                redis_healthy = True
            except:
                pass
        
        return {
            "status": "ready",
            "database": "connected",
            "redis": "connected" if redis_healthy else "disconnected"
        }
    except Exception as e:
        return JSONResponse(
            {"status": "not_ready", "error": str(e)},
            status_code=503
        )


/* ===== C:\Users\icipa\team-platform-public\id_service\api\oidc\__init__.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\api\oidc\authorize.py ===== */

# id_service/api/oidc/authorize.py

import json
import logging
from typing import Optional
from urllib.parse import urlencode

from fastapi import APIRouter, Request, Depends, HTTPException, Query
from fastapi.responses import RedirectResponse, JSONResponse
from sqlalchemy.ext.asyncio import AsyncSession

from db.session import get_async_session
from core.config import settings
from crud import client_crud, user_crud
from services.session_service import session_service
from services.token_service import token_service
from utils.validators import validators
from utils.rate_limit import rate_limiter
from models import ClientType

logger = logging.getLogger(__name__)
router = APIRouter()


def _oauth_error_redirect(redirect_uri: Optional[str], state: Optional[str], error: str, desc: str):
    if redirect_uri:
        params = {"error": error, "error_description": desc}
        if state is not None:
            params["state"] = state
        return RedirectResponse(
            url=f"{redirect_uri}?{urlencode(params)}",
            status_code=302,
            headers={"Cache-Control": "no-store", "Pragma": "no-cache"},
        )
    # Fallback: JSON вместо HTML
    body = {"error": error, "error_description": desc}
    if state is not None:
        body["state"] = state
    return JSONResponse(body, status_code=400, headers={"Cache-Control": "no-store", "Pragma": "no-cache"})


@router.get("/authorize")
async def authorize(
    request: Request,
    session: AsyncSession = Depends(get_async_session),
    client_id: str = Query(...),
    response_type: str = Query(...),
    redirect_uri: str = Query(...),
    scope: str = Query(...),
    state: str = Query(..., min_length=1),
    nonce: Optional[str] = Query(None),
    code_challenge: Optional[str] = Query(None),
    code_challenge_method: Optional[str] = Query(None),
):
    # Базовая валидация запроса
    if response_type != "code":
        return _oauth_error_redirect(redirect_uri, state, "unsupported_response_type", "Only response_type=code is supported")

    client = await client_crud.get_by_client_id(session, client_id)
    if not client:
        return _oauth_error_redirect(redirect_uri, state, "unauthorized_client", "Unknown client_id")

    if not validators.validate_redirect_uri(redirect_uri, client.redirect_uris or []):
        return _oauth_error_redirect(redirect_uri, state, "invalid_request", "redirect_uri is not registered for client")

    ok, err = validators.validate_scope(scope)
    if not ok:
        return _oauth_error_redirect(redirect_uri, state, "invalid_scope", err)

    ok, err = validators.validate_state(state)
    if not ok:
        return _oauth_error_redirect(redirect_uri, state, "invalid_request", err)

    ok, err = validators.validate_nonce(nonce or "")
    if not ok:
        return _oauth_error_redirect(redirect_uri, state, "invalid_request", err)

    # PKCE требования
    require_pkce = client.type == ClientType.PUBLIC or (getattr(client, "pkce_required", True) is True)
    if require_pkce:
        if code_challenge is None or (code_challenge_method or "S256") != "S256":
            return _oauth_error_redirect(redirect_uri, state, "invalid_request", "PKCE S256 is required")

    # Если есть SSO — выдаем code и редиректим сразу
    idp_session = await session_service.get_session_from_cookie(session, request)
    if idp_session:
        user = await user_crud.get_by_id(session, idp_session.user_id)
        if not user:
            return _oauth_error_redirect(redirect_uri, state, "access_denied", "User not found")

        code = await token_service.create_auth_code(
            session=session,
            user=user,
            client=client,
            redirect_uri=redirect_uri,
            scope=scope,
            state=state,
            nonce=nonce,
            code_challenge=code_challenge,  # сохраняем как есть, верифицируем на /token
            ip_address=request.client.host,
            user_agent=request.headers.get("User-Agent"),
        )

        # Привяжем sid к коду через Redis, чтобы потом добавить в id_token
        if rate_limiter.redis_client:
            await rate_limiter.redis_client.setex(
                f"authcode_sid:{code}", settings.AUTH_CODE_TTL, idp_session.session_id
            )

        params = {"code": code, "state": state}
        return RedirectResponse(url=f"{redirect_uri}?{urlencode(params)}", status_code=302)

    # Нет SSO — сохраним pending и редиректим на SPA /login
    if not rate_limiter.redis_client:
        return _oauth_error_redirect(redirect_uri, state, "server_error", "Redis unavailable")

    payload = {
        "client_id": client_id,
        "redirect_uri": redirect_uri,
        "scope": scope,
        "state": state,
        "nonce": nonce,
        "code_challenge": code_challenge,
        "created_at": "now",
        "ip": request.client.host,
        "ua": validators.sanitize_user_agent(request.headers.get("User-Agent")),
    }
    await rate_limiter.redis_client.setex(f"authreq:{state}", settings.AUTH_CODE_TTL, json.dumps(payload))

    # базовый origin текущего хоста (id.localhost или id.asynq.ru)
    host = request.headers.get("host") or request.url.netloc
    origin = f"{request.url.scheme}://{host.split(',')[0].strip()}"
    login_qs = urlencode({
        "client_id": client_id,
        "redirect_uri": redirect_uri,
        "scope": scope,
        "state": state,
        **({"nonce": nonce} if nonce else {}),
        **({"code_challenge": code_challenge} if code_challenge else {}),
    })
    return RedirectResponse(url=f"{origin}/login?{login_qs}", status_code=302)


/* ===== C:\Users\icipa\team-platform-public\id_service\api\oidc\discovery.py ===== */

# id_service/api/oidc/discovery.py
"""
OIDC Discovery (.well-known/openid-configuration)

Обновлено:
- frontchannel_logout_supported = False, т.к. фронт-канал убран.
- backchannel_logout_supported = True (как и было).
"""

from fastapi import APIRouter, Request
from fastapi.responses import JSONResponse

from core.config import settings
from schemas.oidc import DiscoveryResponse

router = APIRouter()


@router.get("/.well-known/openid-configuration", response_model=DiscoveryResponse)
async def openid_configuration(request: Request):
    """OpenID Connect Discovery endpoint"""
    base_url = settings.ISSUER

    return DiscoveryResponse(
        issuer=base_url,
        authorization_endpoint=f"{base_url}/authorize",
        token_endpoint=f"{base_url}/token",
        userinfo_endpoint=f"{base_url}/userinfo",
        jwks_uri=f"{base_url}/.well-known/jwks.json",
        end_session_endpoint=f"{base_url}/logout",
        response_types_supported=["code"],
        grant_types_supported=["authorization_code", "refresh_token"],
        scopes_supported=["openid", "email", "profile", "offline_access"],
        id_token_signing_alg_values_supported=["RS256"],
        subject_types_supported=["public"],
        token_endpoint_auth_methods_supported=["none", "client_secret_post", "client_secret_basic"],
        code_challenge_methods_supported=["S256"],
        claims_supported=[
            "sub", "email", "email_verified", "preferred_username",
            "auth_time", "iss", "aud", "exp", "iat", "nonce", "at_hash", "sid"
        ],
        frontchannel_logout_supported=False,   # фронт-канал отключён
        backchannel_logout_supported=True,
        backchannel_logout_session_supported=True,
    )



/* ===== C:\Users\icipa\team-platform-public\id_service\api\oidc\jwks.py ===== */

# id_service/api/oidc/jwks.py

import logging
from fastapi import APIRouter
from fastapi.responses import JSONResponse
from services.jwk_service import jwk_service

logger = logging.getLogger(__name__)
router = APIRouter()

@router.get("/.well-known/jwks.json")
async def jwks():
    jwks_dict = await jwk_service.get_jwks()
    return JSONResponse(
        jwks_dict,
        headers={
            "Cache-Control": "public, max-age=300, must-revalidate",
            "Content-Type": "application/json",
        },
    )



/* ===== C:\Users\icipa\team-platform-public\id_service\api\oidc\logout.py ===== */

# id_service/api/oidc/logout.py
"""
OIDC RP-Initiated Logout.

Изменения:
- Добавлен JSON-логаут: POST /logout с телом LogoutRequest и ответом LogoutResponse.
- GET /logout упрощён: больше НЕТ HTML/iframes. Только:
    - 302 на валидный post_logout_redirect_uri (если он валиден для клиента из id_token_hint)
    - иначе 204 No Content.
- Back-channel остаётся. Фронт-канал удалён.
- Очистка cookie и отзыв IdP-сессии — только в POST-варианте (по ТЗ).
"""

import logging
import asyncio
from typing import Optional
from urllib.parse import urlencode

from fastapi import APIRouter, Request, Response, Depends, Query
from fastapi.responses import RedirectResponse
from sqlalchemy.ext.asyncio import AsyncSession
from jose import jwt, JWTError

from db.session import get_async_session
from services.session_service import session_service
from services.backchannel_logout import backchannel_logout_service
from services.jwk_service import jwk_service
from crud import client_crud, user_crud
from utils.validators import validators
from core.config import settings
from schemas.oidc import LogoutRequest, LogoutResponse

logger = logging.getLogger(__name__)
router = APIRouter()


async def _parse_id_token_hint(
    id_token_hint: Optional[str],
    session: AsyncSession,
) -> tuple[Optional[str], Optional[str]]:
    """
    Разбор id_token_hint.
    Возвращает (client_id, user_id) если токен корректен. Иначе (None, None).
    Аудиторию (aud) валидируем как строку одного клиента.
    """
    if not id_token_hint:
        return None, None
    try:
        hdr = jwt.get_unverified_header(id_token_hint)
        kid = hdr.get("kid")
        jwk = await jwk_service.get_key_by_kid(kid) if kid else None
        if not jwk:
            raise JWTError("unknown kid")
        public_key = jwk_service.load_public_key(jwk.public_pem)

        # aud проверять как hint: verify_aud=False, но issuer проверяем
        claims = jwt.decode(
            id_token_hint,
            public_key,
            algorithms=["RS256"],
            issuer=settings.ISSUER,
            options={"verify_aud": False},
        )
        aud = claims.get("aud")
        client_id = aud if isinstance(aud, str) else None
        user_id = claims.get("sub")
        return client_id, user_id
    except JWTError:
        logger.warning("Invalid id_token_hint provided")
        return None, None


def _build_redirect(redirect_uri: Optional[str], state: Optional[str]) -> Optional[str]:
    """Собирает redirect_to строку с ?state=... если задано."""
    if not redirect_uri:
        return None
    if state:
        return f"{redirect_uri}?{urlencode({'state': state})}"
    return redirect_uri


@router.post("/logout", response_model=LogoutResponse)
async def logout_post(
    request: Request,
    response: Response,
    body: LogoutRequest,
    session: AsyncSession = Depends(get_async_session),
):
    """
    JSON-логаут.
    Действия:
      - Если есть IdP-сессия: отозвать, очистить cookie, дернуть back-channel.
      - Валидация post_logout_redirect_uri идёт по клиенту из id_token_hint.
      - Возвращаем { ok: true, redirect_to: <uri>|null }. 302 нет.
    """
    # 1) Разобрать id_token_hint, чтобы понять клиента и пользователя (для back-channel)
    client_id_from_hint, user_id_from_hint = await _parse_id_token_hint(body.id_token_hint, session)

    # 2) Считать текущую IdP-сессию из cookie
    idp_session = await session_service.get_session_from_cookie(session, request)
    current_user = None

    # 3) Если сессия есть — отзываем и очищаем cookie
    if idp_session:
        # Если пользователя ещё не знаем — загрузим
        if not user_id_from_hint:
            user_id_from_hint = str(idp_session.user_id)
        current_user = await user_crud.get_by_id(session, user_id_from_hint) if user_id_from_hint else None

        await session_service.revoke_session(session, idp_session)
        session_service.clear_session_cookie(response)

        # 4) Back-channel для активных RP (как раньше)
        if current_user:
            asyncio.create_task(
                backchannel_logout_service.initiate_backchannel_logout(
                    session=None,  # сервис сам откроет сессию
                    user=current_user,
                    session_id=idp_session.session_id,
                    reason="rp_logout",
                )
            )

    # 5) Валидация post_logout_redirect_uri по клиенту из id_token_hint
    redirect_to: Optional[str] = None
    if body.post_logout_redirect_uri and client_id_from_hint:
        client = await client_crud.get_by_client_id(session, client_id_from_hint)
        if client and validators.validate_redirect_uri(body.post_logout_redirect_uri, client.post_logout_redirect_uris):
            redirect_to = _build_redirect(body.post_logout_redirect_uri, body.state)

    # 6) JSON-ответ
    return LogoutResponse(ok=True, redirect_to=redirect_to)


@router.get("/logout")
async def logout_get(
    request: Request,
    session: AsyncSession = Depends(get_async_session),
    id_token_hint: Optional[str] = Query(None),
    post_logout_redirect_uri: Optional[str] = Query(None),
    state: Optional[str] = Query(None),
):
    """
    Упрощённый GET-вариант.
    Никаких HTML/iframes. Без очистки cookie и без ревокации.
    Если redirect валиден по клиенту из id_token_hint — 302 туда (добавим state).
    Иначе — 204 No Content.
    """
    client_id_from_hint, _ = await _parse_id_token_hint(id_token_hint, session)

    if post_logout_redirect_uri and client_id_from_hint:
        client = await client_crud.get_by_client_id(session, client_id_from_hint)
        if client and validators.validate_redirect_uri(post_logout_redirect_uri, client.post_logout_redirect_uris):
            url = _build_redirect(post_logout_redirect_uri, state)
            return RedirectResponse(url=url, status_code=302)

    # Ничего не делаем, даём 204
    return Response(status_code=204)



/* ===== C:\Users\icipa\team-platform-public\id_service\api\oidc\revoke.py ===== */

# id_service/api/oidc/revoke.py

import logging
from typing import Optional

from fastapi import APIRouter, Request, Depends, Form
from fastapi.responses import JSONResponse
from sqlalchemy.ext.asyncio import AsyncSession

from db.session import get_async_session
from .token import _get_client_and_auth  # используем тот же helper
from services.token_service import token_service

logger = logging.getLogger(__name__)
router = APIRouter()

@router.post("/revoke")
async def revoke(
    request: Request,
    session: AsyncSession = Depends(get_async_session),
    token: str = Form(...),
    token_type_hint: Optional[str] = Form(None),
    client_id: Optional[str] = Form(None),
    client_secret: Optional[str] = Form(None),
):
    # Аутентифицируем клиента так же, как на /token
    client, err = await _get_client_and_auth(request, session, client_id, client_secret)
    if err:
        return err  # 401 invalid_client при ошибке

    # Поддерживаем только refresh_token (access — самодостаточный JWT)
    if token_type_hint and token_type_hint not in ("refresh_token", "access_token"):
        # по RFC просто игнорируем hint и продолжаем
        pass

    # По RFC: всегда 200 OK даже если токен невалиден/не найден
    try:
        await token_service.revoke_refresh_token(
            session=session,
            refresh_token=token,
            client_id=client.client_id,
            reason="revoked_by_client",
        )
    except Exception:
        # не палим детали наружу
        pass

    return JSONResponse({}, status_code=200, headers={"Cache-Control": "no-store", "Pragma": "no-cache"})



/* ===== C:\Users\icipa\team-platform-public\id_service\api\oidc\token.py ===== */

# id_service/api/oidc/token.py

import base64
import json
import logging
from typing import Optional, Tuple

from fastapi import APIRouter, Request, Depends, Form
from fastapi.responses import JSONResponse
from sqlalchemy.ext.asyncio import AsyncSession

from db.session import get_async_session
from utils.rate_limit import rate_limiter
from crud import client_crud
from models import TokenAuthMethod, ClientType, User
from services.token_service import token_service
from utils.validators import validators
from core.config import settings

logger = logging.getLogger(__name__)
router = APIRouter()


def _oauth_error(error: str, desc: str, status_code: int = 400):
    return JSONResponse(
        {"error": error, "error_description": desc},
        status_code=status_code,
        headers={"Cache-Control": "no-store", "Pragma": "no-cache"},
    )

def _basic_auth(header: Optional[str]) -> Tuple[Optional[str], Optional[str]]:
    if not header or not header.lower().startswith("basic "):
        return None, None
    try:
        raw = base64.b64decode(header.split(" ", 1)[1]).decode()
        client_id, client_secret = raw.split(":", 1)
        return client_id, client_secret
    except Exception:
        return None, None


async def _get_client_and_auth(request: Request, session: AsyncSession, form_client_id: Optional[str], form_client_secret: Optional[str]):
    auth_header = request.headers.get("Authorization")
    basic_id, basic_secret = _basic_auth(auth_header)
    client_id = basic_id or form_client_id
    client = await client_crud.get_by_client_id(session, client_id) if client_id else None
    if not client:
        return None, _oauth_error("invalid_client", "Unknown client_id", 401)

    # Determine how client authenticates
    method = client.token_endpoint_auth_method
    if method == TokenAuthMethod.NONE:
        # public client, no secret expected
        return client, None
    elif method == TokenAuthMethod.CLIENT_SECRET_BASIC:
        if basic_id is None:
            return None, _oauth_error("invalid_client", "client_secret_basic required", 401)
        if not await client_crud.verify_secret(client, basic_secret or ""):
            return None, _oauth_error("invalid_client", "Invalid client secret", 401)
        return client, None
    elif method == TokenAuthMethod.CLIENT_SECRET_POST:
        secret = form_client_secret or ""
        if not await client_crud.verify_secret(client, secret):
            return None, _oauth_error("invalid_client", "Invalid client secret", 401)
        return client, None
    else:
        return None, _oauth_error("invalid_client", "Unsupported auth method", 401)


@router.post("/token")
async def token(
    request: Request,
    session: AsyncSession = Depends(get_async_session),
    grant_type: str = Form(...),
    code: Optional[str] = Form(None),
    redirect_uri: Optional[str] = Form(None),
    code_verifier: Optional[str] = Form(None),
    refresh_token: Optional[str] = Form(None),
    client_id: Optional[str] = Form(None),
    client_secret: Optional[str] = Form(None),
):
    client, err = await _get_client_and_auth(request, session, client_id, client_secret)
    if err:
        return err

    if grant_type == "authorization_code":
        if not code or not redirect_uri:
            return _oauth_error("invalid_request", "code and redirect_uri are required")

        # PKCE: для public/required — обязателен корректный verifier
        require_pkce = client.type == ClientType.PUBLIC or (getattr(client, "pkce_required", True) is True)
        if require_pkce:
            ok, errtxt = validators.validate_pkce_verifier(code_verifier or "")
            if not ok:
                return _oauth_error("invalid_request", errtxt)

        auth_code, oauth_err = await token_service.exchange_auth_code(
            session=session,
            code=code,
            client_id=client.client_id,
            redirect_uri=redirect_uri,
            code_verifier=code_verifier,
        )
        if oauth_err or not auth_code:
            return _oauth_error("invalid_grant", "invalid authorization code")

        # ЯВНО загружаем пользователя
        user = await session.get(User, auth_code.user_id)
        if not user:
            return _oauth_error("invalid_grant", "user not found")

        # Получаем sid из Redis (могут вернуться bytes -> декодируем)
        sid = None
        if rate_limiter.redis_client:
            sid = await rate_limiter.redis_client.get(f"authcode_sid:{code}")
            if isinstance(sid, (bytes, bytearray)):
                sid = sid.decode("utf-8")

        tokens = await token_service.create_tokens(
            session=session,
            user=user,
            client=client,
            scope=auth_code.scope,
            nonce=auth_code.nonce,
            auth_time=auth_code.auth_time,
            session_id=sid,
            ip_address=(request.client.host if request.client else None),
            user_agent=request.headers.get("User-Agent"),
        )

        return JSONResponse(tokens, headers={"Cache-Control": "no-store", "Pragma": "no-cache"})

    elif grant_type == "refresh_token":
        if not refresh_token:
            return _oauth_error("invalid_request", "refresh_token is required")

        new_tokens, oauth_err = await token_service.rotate_refresh_token(
            session=session,
            refresh_token=refresh_token,
            client_id=client.client_id,
            ip_address=request.client.host,
            user_agent=request.headers.get("User-Agent"),
        )
        if oauth_err:
            return _oauth_error(oauth_err, "cannot rotate refresh token")
        return JSONResponse(new_tokens, headers={"Cache-Control": "no-store", "Pragma": "no-cache"})


    else:
        return _oauth_error("unsupported_grant_type", "Only authorization_code and refresh_token are supported")



/* ===== C:\Users\icipa\team-platform-public\id_service\api\oidc\userinfo.py ===== */

# id_service/api/oidc/userinfo.py

import logging
from fastapi import APIRouter, Request, Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.ext.asyncio import AsyncSession

from db.session import get_async_session
from schemas.oidc import UserInfoResponse
from services.token_service import token_service
from crud import user_crud

logger = logging.getLogger(__name__)
router = APIRouter()

security = HTTPBearer()


@router.get("/userinfo", response_model=UserInfoResponse)
@router.post("/userinfo", response_model=UserInfoResponse)
async def userinfo(
    request: Request,
    session: AsyncSession = Depends(get_async_session),
    credentials: HTTPAuthorizationCredentials = Depends(security)
):
    """OpenID Connect UserInfo endpoint"""
    
    # Verify access token
    token_claims = await token_service.verify_access_token(credentials.credentials)
    
    if not token_claims:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid access token",
            headers={"WWW-Authenticate": "Bearer"}
        )
    
    # Check scope
    scopes = token_claims.get("scope", "").split()
    
    # Get user
    user = await user_crud.get_by_id(session, token_claims["sub"])
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    # Build response based on scopes
    response_data = {
        "sub": str(user.id)
    }
    
    if "email" in scopes:
        response_data["email"] = user.email
        response_data["email_verified"] = user.email_verified
    
    if "profile" in scopes:
        response_data["preferred_username"] = user.username
        if user.updated_at:
            response_data["updated_at"] = int(user.updated_at.timestamp())
    
    return UserInfoResponse(**response_data)


/* ===== C:\Users\icipa\team-platform-public\id_service\core\__init__.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\core\config.py ===== */

# id_service/core/config.py
from typing import List
from pydantic_settings import BaseSettings, SettingsConfigDict
from pydantic import Field


class Settings(BaseSettings):
    # App
    APP_NAME: str = "ID Service"
    APP_ENV: str = "development"  # development|production
    ISSUER: str = "http://localhost:8000"
    CORS_ORIGINS: List[str] = []

    # DB / Redis
    DATABASE_URL: str = "postgresql+asyncpg://postgres:password@localhost:5432/id_service"
    DB_ECHO: bool = False
    REDIS_URL: str = "redis://localhost:6379/1"

    # Security / Secrets
    SECRET_KEY: str = "dev-secret"
    PEPPER_SECRET: str = "dev-pepper"
    COOKIE_SECRET: str = "dev-cookie-secret"
    JWT_PRIVATE_KEY_PASSWORD: str = "dev-jwt-password"

    # Token TTLs (seconds)
    ACCESS_TOKEN_TTL: int = 600
    REFRESH_TOKEN_TTL: int = 2592000
    AUTH_CODE_TTL: int = 600
    SSO_IDLE_TTL: int = 1800
    SSO_MAX_TTL: int = 86400

    # OTP
    OTP_TTL: int = 300
    OTP_RESEND_SECONDS: int = 60
    OTP_MAX_ATTEMPTS: int = 5

    # SMTP
    SMTP_HOST: str = "smtp.gmail.com"
    SMTP_PORT: int = 587
    SMTP_USER: str = ""
    SMTP_PASSWORD: str = ""
    SMTP_TLS: bool = True
    EMAIL_FROM: str = "Asynq ID <noreply@example.com>"

    # Rate limit
    RATE_LIMIT_ENABLED: bool = True
    RATE_LIMIT_REQUESTS_PER_MINUTE: int = 60

    # Password policy
    PASSWORD_MIN_LENGTH: int = 8
    PASSWORD_REQUIRE_UPPERCASE: bool = True
    PASSWORD_REQUIRE_LOWERCASE: bool = True
    PASSWORD_REQUIRE_DIGIT: bool = True
    PASSWORD_REQUIRE_SPECIAL: bool = False

    # Dev client IDs
    TEACH_CLIENT_ID: str = "teach-service"
    RUN_CLIENT_ID: str = "run-service"
    LEARN_CLIENT_ID: str = "learn-service"
    CATALOG_CLIENT_ID: str = "catalog-service"
    ADMIN_CLIENT_ID: str = "admin-service"

    # Argon2id tuning (can be overridden via .env)
    ARGON2_TIME_COST: int = 3
    ARGON2_MEMORY_COST: int = 65536  # KiB (64 MiB)
    ARGON2_PARALLELISM: int = 2
    ARGON2_HASH_LEN: int = 32
    ARGON2_SALT_LEN: int = 16

    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        case_sensitive=False,
    )


settings = Settings()



/* ===== C:\Users\icipa\team-platform-public\id_service\core\constants.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\core\security.py ===== */

# id_service/core/security.py

import base64
import hashlib
import hmac
import secrets
import string
from typing import Tuple

from argon2 import PasswordHasher, Type
from argon2.exceptions import VerifyMismatchError
from core.config import settings


class SecurityService:

    def __init__(self) -> None:
        self.pepper = settings.PEPPER_SECRET
        self.ph = PasswordHasher(
            time_cost=settings.ARGON2_TIME_COST,
            memory_cost=settings.ARGON2_MEMORY_COST,
            parallelism=settings.ARGON2_PARALLELISM,
            hash_len=settings.ARGON2_HASH_LEN,
            salt_len=settings.ARGON2_SALT_LEN,
            type=Type.ID,
        )
    # -------- Password hashing (Argon2id + pepper) --------
    def hash_password(self, password: str) -> str:
        return self.ph.hash(f"{password}{self.pepper}")

    def is_argon2id_hash(self, stored: str) -> bool:
        return stored.startswith("$argon2id$")


    def verify_password(self, password: str, stored: str) -> bool:
        if not self.is_argon2id_hash(stored):
            return False
        try:
            self.ph.verify(stored, f"{password}{self.pepper}")
            return True
        except VerifyMismatchError:
            return False
        except Exception:
            return False

    def needs_rehash(self, stored: str) -> bool:
        if not self.is_argon2id_hash(stored):
            return False
        try:
            return self.ph.check_needs_rehash(stored)
        except Exception:
            return True

    # -------- OTP (email codes) --------
    def generate_otp(self, length: int = 4) -> str:
        digits = string.digits
        return "".join(secrets.choice(digits) for _ in range(length))

    def hash_otp(self, code: str) -> str:
        digest = hmac.new(self.pepper.encode("utf-8"), code.encode("utf-8"), hashlib.sha256).digest()
        return base64.urlsafe_b64encode(digest).decode().rstrip("=")

    def constant_time_compare(self, a: str, b: str) -> bool:
        return hmac.compare_digest(a, b)

    # -------- Password policy --------
    def validate_password_strength(self, password: str) -> Tuple[bool, str]:
        if len(password) < int(getattr(settings, "PASSWORD_MIN_LENGTH", 8)):
            return False, f"Password must be at least {settings.PASSWORD_MIN_LENGTH} characters"
        if getattr(settings, "PASSWORD_REQUIRE_UPPERCASE", True) and not any(c.isupper() for c in password):
            return False, "Password must contain an uppercase letter"
        if getattr(settings, "PASSWORD_REQUIRE_LOWERCASE", True) and not any(c.islower() for c in password):
            return False, "Password must contain a lowercase letter"
        if getattr(settings, "PASSWORD_REQUIRE_DIGIT", True) and not any(c.isdigit() for c in password):
            return False, "Password must contain a digit"
        if getattr(settings, "PASSWORD_REQUIRE_SPECIAL", False) and not any(c in "!@#$%^&*()-_=+[]{};:,.?/\\|" for c in password):
            return False, "Password must contain a special character"
        return True, ""

    # -------- PKCE S256 --------
    def verify_code_challenge(self, code_verifier: str, stored_challenge: str) -> bool:
        if not code_verifier or not stored_challenge:
            return False
        if len(code_verifier) < 43 or len(code_verifier) > 128:
            return False
        allowed = set(string.ascii_letters + string.digits + "-._~")
        if any(c not in allowed for c in code_verifier):
            return False
        digest = hashlib.sha256(code_verifier.encode()).digest()
        computed = base64.urlsafe_b64encode(digest).decode().rstrip("=")
        return hmac.compare_digest(computed, stored_challenge)


security = SecurityService()



/* ===== C:\Users\icipa\team-platform-public\id_service\crud\__init__.py ===== */

# id_service/crud/__init__.py

from .user import user_crud
from .client import client_crud
from .idp_session import idp_session_crud

__all__ = [
    "user_crud",
    "client_crud",
    "idp_session_crud"
]


/* ===== C:\Users\icipa\team-platform-public\id_service\crud\auth_code.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\crud\client.py ===== */

# id_service/crud/client.py

from typing import Optional, List
from datetime import datetime, timezone
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_

from models import Client, ClientType, TokenAuthMethod
from core.security import security

import logging
logger = logging.getLogger(__name__)


class ClientCRUD:
    """CRUD operations for Client model"""
    
    async def get_by_client_id(
        self,
        session: AsyncSession,
        client_id: str
    ) -> Optional[Client]:
        """Get client by client_id"""
        result = await session.execute(
            select(Client).where(Client.client_id == client_id)
        )
        return result.scalar_one_or_none()
    
    async def create(
        self,
        session: AsyncSession,
        client_id: str,
        name: str,
        client_type: ClientType = ClientType.PUBLIC,
        redirect_uris: List[str] = None,
        post_logout_redirect_uris: List[str] = None,
        backchannel_logout_uri: Optional[str] = None,
        frontchannel_logout_uri: Optional[str] = None,
        scopes: List[str] = None,
        client_secret: Optional[str] = None,
        pkce_required: bool = True
    ) -> Client:
        """Create new client"""
        
        # Hash client secret if provided
        client_secret_hash = None
        if client_secret:
            client_secret_hash = security.hash_password(client_secret)
        
        client = Client(
            client_id=client_id,
            name=name,
            type=client_type,
            token_endpoint_auth_method=(
                TokenAuthMethod.CLIENT_SECRET_POST 
                if client_type == ClientType.CONFIDENTIAL 
                else TokenAuthMethod.NONE
            ),
            pkce_required=pkce_required,
            redirect_uris=redirect_uris or [],
            post_logout_redirect_uris=post_logout_redirect_uris or [],
            backchannel_logout_uri=backchannel_logout_uri,
            frontchannel_logout_uri=frontchannel_logout_uri,
            scopes=scopes or ["openid", "email", "profile"],
            client_secret_hash=client_secret_hash,
            created_at=datetime.now(timezone.utc)
        )
        
        session.add(client)
        await session.flush()
        
        logger.info(f"Created client {client_id}")
        return client
    
    async def update(
        self,
        session: AsyncSession,
        client: Client,
        **kwargs
    ) -> Client:
        """Update client"""
        for key, value in kwargs.items():
            if hasattr(client, key):
                setattr(client, key, value)
        
        client.updated_at = datetime.now(timezone.utc)
        await session.flush()
        
        logger.info(f"Updated client {client.client_id}")
        return client
    
    async def rotate_secret(
        self,
        session: AsyncSession,
        client: Client,
        new_secret: str
    ) -> Client:
        """Rotate client secret"""
        client.client_secret_hash = security.hash_password(new_secret)
        client.secret_rotated_at = datetime.now(timezone.utc)
        client.updated_at = datetime.now(timezone.utc)
        
        await session.flush()
        
        logger.info(f"Rotated secret for client {client.client_id}")
        return client
    
    async def verify_secret(
        self,
        client: Client,
        secret: str
    ) -> bool:
        """Verify client secret"""
        if not client.client_secret_hash:
            return False
        
        return security.verify_password(secret, client.client_secret_hash)
    
    async def list_all(
        self,
        session: AsyncSession,
        limit: int = 100,
        offset: int = 0
    ) -> List[Client]:
        """List all clients"""
        result = await session.execute(
            select(Client)
            .order_by(Client.created_at.desc())
            .limit(limit)
            .offset(offset)
        )
        return result.scalars().all()


client_crud = ClientCRUD()


/* ===== C:\Users\icipa\team-platform-public\id_service\crud\email_code.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\crud\idp_session.py ===== */

# id_service/crud/idp_session.py

from typing import Optional, List
from datetime import datetime, timezone, timedelta
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_

from models import IDPSession

import logging
logger = logging.getLogger(__name__)


class IDPSessionCRUD:
    """CRUD operations for IDP Session model"""
    
    async def get_active_session(
        self,
        session: AsyncSession,
        session_id: str
    ) -> Optional[IDPSession]:
        """Get active session by ID"""
        now = datetime.now(timezone.utc)
        
        result = await session.execute(
            select(IDPSession).where(
                and_(
                    IDPSession.session_id == session_id,
                    IDPSession.revoked_at.is_(None),
                    IDPSession.idle_expires_at > now,
                    IDPSession.max_expires_at > now
                )
            )
        )
        return result.scalar_one_or_none()
    
    async def get_user_sessions(
        self,
        session: AsyncSession,
        user_id: str,
        only_active: bool = True
    ) -> List[IDPSession]:
        """Get all sessions for a user"""
        query = select(IDPSession).where(IDPSession.user_id == user_id)
        
        if only_active:
            now = datetime.now(timezone.utc)
            query = query.where(
                and_(
                    IDPSession.revoked_at.is_(None),
                    IDPSession.max_expires_at > now
                )
            )
        
        query = query.order_by(IDPSession.created_at.desc())
        
        result = await session.execute(query)
        return result.scalars().all()
    
    async def cleanup_expired(
        self,
        session: AsyncSession
    ) -> int:
        """Clean up expired sessions"""
        now = datetime.now(timezone.utc)
        cutoff = now - timedelta(days=7)  # Keep for 7 days after expiry
        
        result = await session.execute(
            select(IDPSession).where(
                or_(
                    IDPSession.max_expires_at < cutoff,
                    and_(
                        IDPSession.revoked_at.is_not(None),
                        IDPSession.revoked_at < cutoff
                    )
                )
            )
        )
        
        expired_sessions = result.scalars().all()
        
        for idp_session in expired_sessions:
            session.delete(idp_session)
        
        await session.flush()
        
        count = len(expired_sessions)
        if count > 0:
            logger.info(f"Cleaned up {count} expired sessions")
        
        return count


idp_session_crud = IDPSessionCRUD()


/* ===== C:\Users\icipa\team-platform-public\id_service\crud\jwk_key.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\crud\refresh_token.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\crud\user.py ===== */

# id_service/crud/user.py

from typing import Optional, List
from datetime import datetime, timezone
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, func, or_
from sqlalchemy.exc import IntegrityError

from models import User
from schemas.user import UserCreate, UserUpdate
from core.security import security

from datetime import datetime, timezone
from sqlalchemy.ext.asyncio import AsyncSession
from models import User
from core.security import security

import logging
logger = logging.getLogger(__name__)


class UserCRUD:
    """CRUD operations for User model"""
    
    async def create(
        self,
        session: AsyncSession,
        user_create: UserCreate
    ) -> Optional[User]:
        """Create new user"""
        try:
            # Hash password
            password_hash = security.hash_password(user_create.password)
            
            # Create user
            user = User(
                email=user_create.email.lower(),
                username=user_create.username,
                password_hash=password_hash,
                email_verified=user_create.email_verified,
                created_at=datetime.now(timezone.utc)
            )
            
            session.add(user)
            await session.flush()
            
            logger.info(f"Created user with ID {user.id}")
            return user
            
        except IntegrityError as e:
            logger.warning(f"Failed to create user: {e}")
            await session.rollback()
            return None
    
    async def get_by_id(
        self,
        session: AsyncSession,
        user_id: str
    ) -> Optional[User]:
        """Get user by ID"""
        result = await session.execute(
            select(User).where(
                and_(
                    User.id == user_id,
                    User.deleted_at.is_(None)
                )
            )
        )
        return result.scalar_one_or_none()
    
    async def get_by_email(
        self,
        session: AsyncSession,
        email: str
    ) -> Optional[User]:
        """Get user by email (case-insensitive)"""
        result = await session.execute(
            select(User).where(
                and_(
                    func.lower(User.email) == email.lower(),
                    User.deleted_at.is_(None)
                )
            )
        )
        return result.scalar_one_or_none()
    
    async def get_by_username(
        self,
        session: AsyncSession,
        username: str
    ) -> Optional[User]:
        """Get user by username"""
        result = await session.execute(
            select(User).where(
                and_(
                    User.username == username,
                    User.deleted_at.is_(None)
                )
            )
        )
        return result.scalar_one_or_none()
    
    async def get_by_email_or_username(
        self,
        session: AsyncSession,
        identifier: str
    ) -> Optional[User]:
        """Get user by email or username"""
        result = await session.execute(
            select(User).where(
                and_(
                    or_(
                        func.lower(User.email) == identifier.lower(),
                        User.username == identifier
                    ),
                    User.deleted_at.is_(None)
                )
            )
        )
        return result.scalar_one_or_none()
    
    async def update(
        self,
        session: AsyncSession,
        user: User,
        user_update: UserUpdate
    ) -> User:
        """Update user"""
        update_data = user_update.model_dump(exclude_unset=True)
        
        for field, value in update_data.items():
            if field == "email" and value:
                value = value.lower()
            setattr(user, field, value)
        
        user.updated_at = datetime.now(timezone.utc)
        await session.flush()
        
        logger.info(f"Updated user {user.id}")
        return user
    
    async def update_password(
        self,
        session: AsyncSession,
        user: User,
        new_password: str
    ) -> User:
        """Update user password"""
        user.password_hash = security.hash_password(new_password)
        user.last_password_change_at = datetime.now(timezone.utc)
        user.updated_at = datetime.now(timezone.utc)
        user.failed_login_attempts = 0  # Reset failed attempts
        
        await session.flush()
        
        logger.info(f"Updated password for user {user.id}")
        return user
    
    async def verify_email(
        self,
        session: AsyncSession,
        user: User
    ) -> User:
        """Mark user email as verified"""
        user.email_verified = True
        user.updated_at = datetime.now(timezone.utc)
        
        await session.flush()
        
        logger.info(f"Verified email for user {user.id}")
        return user
    
    async def update_login_info(
        self,
        session: AsyncSession,
        user: User,
        success: bool = True
    ) -> User:
        """Update login information"""
        now = datetime.now(timezone.utc)
        
        if success:
            user.last_login_at = now
            user.failed_login_attempts = 0
        else:
            user.failed_login_attempts += 1
        
        user.updated_at = now
        await session.flush()
        
        return user
    
    async def soft_delete(
        self,
        session: AsyncSession,
        user: User
    ) -> User:
        """Soft delete user"""
        now = datetime.now(timezone.utc)
        user.deleted_at = now
        user.updated_at = now
        
        # Anonymize personal data
        user.email = f"deleted_{user.id}@deleted.local"
        user.username = f"deleted_{user.id}"
        
        await session.flush()
        
        logger.info(f"Soft deleted user {user.id}")
        return user
    
    async def check_email_exists(
        self,
        session: AsyncSession,
        email: str,
        exclude_user_id: Optional[str] = None
    ) -> bool:
        """Check if email already exists"""
        query = select(User).where(
            and_(
                func.lower(User.email) == email.lower(),
                User.deleted_at.is_(None)
            )
        )
        
        if exclude_user_id:
            query = query.where(User.id != exclude_user_id)
        
        result = await session.execute(query.exists().select())
        return result.scalar()
    
    async def check_username_exists(
        self,
        session: AsyncSession,
        username: str,
        exclude_user_id: Optional[str] = None
    ) -> bool:
        """Check if username already exists"""
        query = select(User).where(
            and_(
                User.username == username,
                User.deleted_at.is_(None)
            )
        )
        
        if exclude_user_id:
            query = query.where(User.id != exclude_user_id)
        
        result = await session.execute(query.exists().select())
        return result.scalar()
    
    async def rehash_password(
        self,
        session: AsyncSession,
        user: User,
        raw_password: str
    ) -> User:
        """
        Тихий ре-хэш пароля (без пометки last_password_change_at).
        Меняет только password_hash/updated_at/failed_login_attempts.
        """
        user.password_hash = security.hash_password(raw_password)
        user.updated_at = datetime.now(timezone.utc)
        user.failed_login_attempts = 0
        await session.flush()
        return user


user_crud = UserCRUD()


/* ===== C:\Users\icipa\team-platform-public\id_service\db\__init__.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\db\base.py ===== */

# id_service/db/base.py
from __future__ import annotations

from sqlalchemy import MetaData
from sqlalchemy.orm import DeclarativeBase

# Строгая схема имен — важно для Alembic и воспроизводимости миграций
naming_convention = {
    "ix": "ix_%(table_name)s_%(column_0_N_name)s",
    "uq": "uq_%(table_name)s_%(column_0_N_name)s",
    "ck": "ck_%(table_name)s_%(constraint_name)s",
    "fk": "fk_%(table_name)s_%(column_0_N_name)s_%(referred_table_name)s",
    "pk": "pk_%(table_name)s",
}


class Base(DeclarativeBase):
    """Базовый класс моделей SQLAlchemy с единым MetaData и конвенцией имен."""
    metadata = MetaData(naming_convention=naming_convention)

    def __repr__(self) -> str:
        mapper = self.__class__.__mapper__
        pk_cols = [c.key for c in mapper.primary_key]
        pk_vals = ", ".join(f"{k}={getattr(self, k)!r}" for k in pk_cols)
        return f"<{self.__class__.__name__} {pk_vals}>"



/* ===== C:\Users\icipa\team-platform-public\id_service\db\init_db.py ===== */

# id_service/db/init_db.py

import logging
from datetime import datetime, timezone
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from core.config import settings
from core.security import security
from models import Client, ClientType, User, TokenAuthMethod


logger = logging.getLogger(__name__)


async def init_db(session: AsyncSession) -> None:
    """Seed только для dev. В проде — миграции Alembic и никакого create_all."""
    if settings.APP_ENV != "development":
        return

    result = await session.execute(select(Client).limit(1))
    if result.scalar_one_or_none():
        logger.info("Database already initialized")
        return

    logger.info("Creating initial data for development...")
    
    # Create local development clients
    clients_data = [
        {
            "client_id": settings.TEACH_CLIENT_ID,
            "name": "Teach Service (Local)",
            "type": ClientType.PUBLIC,
            "token_endpoint_auth_method": TokenAuthMethod.NONE,
            "redirect_uris": [
                "http://localhost:3001/callback",
                "http://teach.localhost:3001/callback",
            ],
            "post_logout_redirect_uris": [
                "http://localhost:3001",
                "http://teach.localhost:3001",
            ],
            "backchannel_logout_uri": "http://localhost:3001/backchannel-logout",
            "frontchannel_logout_uri": "http://localhost:3001/frontchannel-logout",
            "scopes": ["openid", "email", "profile", "offline_access"],
        },
        {
            "client_id": settings.RUN_CLIENT_ID,
            "name": "Run Service (Local)",
            "type": ClientType.PUBLIC,
            "token_endpoint_auth_method": TokenAuthMethod.NONE,
            "redirect_uris": [
                "http://localhost:3002/callback",
                "http://run.localhost:3002/callback"
            ],
            "post_logout_redirect_uris": [
                "http://localhost:3002",
                "http://run.localhost:3002"
            ],
            "backchannel_logout_uri": "http://localhost:3002/backchannel-logout",
            "frontchannel_logout_uri": "http://localhost:3002/frontchannel-logout",
            "scopes": ["openid", "email", "profile", "offline_access"]
        },
        {
            "client_id": settings.LEARN_CLIENT_ID,
            "name": "Learn Service (Local)",
            "type": ClientType.PUBLIC,
            "token_endpoint_auth_method": TokenAuthMethod.NONE,
            "redirect_uris": [
                "http://localhost:3003/callback",
                "http://learn.localhost:3003/callback"
            ],
            "post_logout_redirect_uris": [
                "http://localhost:3003",
                "http://learn.localhost:3003"
            ],
            "backchannel_logout_uri": "http://localhost:3003/backchannel-logout",
            "frontchannel_logout_uri": "http://localhost:3003/frontchannel-logout",
            "scopes": ["openid", "email", "profile", "offline_access"]
        }
    ]
    
    for client_data in clients_data:
        session.add(Client(**client_data))
    
    test_user = User(
        email="test@asynq.ru",
        username="testuser",
        password_hash=security.hash_password("Test123!"),
        email_verified=True,
        created_at=datetime.now(timezone.utc)
    )
    session.add(test_user)

    await session.commit()
    logger.info("Dev data created")


/* ===== C:\Users\icipa\team-platform-public\id_service\db\session.py ===== */

# id_service/db/session.py
from __future__ import annotations

from typing import AsyncGenerator

from sqlalchemy.ext.asyncio import (
    AsyncEngine,
    AsyncSession,
    async_sessionmaker,
    create_async_engine,
)

from core.config import settings

# Async SQLAlchemy engine
engine: AsyncEngine = create_async_engine(
    settings.DATABASE_URL,
    echo=settings.DB_ECHO,
    pool_pre_ping=True,
    pool_size=10,
    max_overflow=20,
    future=True,
)

# Session factory
async_session_maker = async_sessionmaker(
    bind=engine,
    class_=AsyncSession,
    expire_on_commit=False,
    autoflush=False,
)

# FastAPI dependency
async def get_async_session() -> AsyncGenerator[AsyncSession, None]:
    async with async_session_maker() as session:
        try:
            yield session
            await session.commit()
        except Exception:
            await session.rollback()
            raise



/* ===== C:\Users\icipa\team-platform-public\id_service\Dockerfile ===== */

# id_service/Dockerfile

FROM python:3.11-slim

ENV PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    PYTHONPATH=/id_service \
    DEBIAN_FRONTEND=noninteractive

WORKDIR /id_service

# Install system dependencies
RUN set -eux; \
    if [ -f /etc/apt/sources.list ]; then \
      sed -i -E 's|http://deb.debian.org|https://deb.debian.org|g' /etc/apt/sources.list; \
    fi; \
    if [ -f /etc/apt/sources.list.d/debian.sources ]; then \
      sed -i -E 's|http://deb.debian.org|https://deb.debian.org|g' /etc/apt/sources.list.d/debian.sources; \
    fi; \
    printf 'Acquire::Retries "5";\n' > /etc/apt/apt.conf.d/80-retries; \
    apt-get update; \
    apt-get install -y --no-install-recommends ca-certificates curl postgresql-client \
    || (sleep 2; apt-get update && apt-get install -y --no-install-recommends --fix-missing ca-certificates curl postgresql-client); \
    rm -rf /var/lib/apt/lists/*

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

# Make init script executable
RUN [ -f ./init_db.sh ] && sed -i 's/\r$//' ./init_db.sh && chmod +x ./init_db.sh || true

# Install package if setup.py exists
RUN if [ -f pyproject.toml ] || [ -f setup.py ]; then pip install -e .; fi

CMD ["sh","-lc","alembic upgrade head && uvicorn main:app --host 0.0.0.0 --port 8000 --workers 4 --proxy-headers --forwarded-allow-ips='*'"]



/* ===== C:\Users\icipa\team-platform-public\id_service\main.py ===== */

# id_service/main.py
"""
Главный модуль FastAPI.

Добавлено:
- Глобальные JSON-хендлеры ошибок:
  * HTTPException → {"error":{"code", "message", "details?"}}
  * RequestValidationError → {"error":{"code":422, "message":"Validation error", "details":[...]}}
- JSONContentTypeMiddleware: для небезопасных методов под /auth/** и /account/** требуем Content-Type: application/json
  (исключение: /auth/csrf).
- AuthCacheHeadersMiddleware: на /auth/** и /oidc/** выставляем Cache-Control: no-store и Pragma: no-cache
  (исключения: discovery и jwks).
Порядок middleware: SecurityHeaders → JSONContentType → CSRF → AuthCacheHeaders → CORS → TrustedHost(prod).
"""

import logging
from contextlib import asynccontextmanager

from fastapi import FastAPI, Request, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from starlette.middleware.base import BaseHTTPMiddleware

from utils.csrf import csrf_protection
from core.config import settings
from db.init_db import init_db
from db.session import async_session_maker, engine
from db.base import Base
from services.jwk_service import jwk_service
from services.backchannel_logout import backchannel_logout_service
from utils import rate_limiter, setup_logging

# Routers
from api.oidc import discovery, authorize, token, userinfo, logout, jwks, revoke
from api.auth import register, login, password_reset, email_verification
from api.auth import csrf as csrf_api
from api.account import profile, email_change, password_change, delete_account
from api import health

from pydantic import ValidationError

# Logging
logger = setup_logging()


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Инициализация приложения на старте."""
    logger.info("Starting ID Service...")

    # Инициализация БД/сервисов
    async with async_session_maker() as session:
        await init_db(session)
    await jwk_service.ensure_active_key()
    await rate_limiter.init()

    yield

    # Cleanup
    logger.info("Shutting down ID Service...")
    await backchannel_logout_service.cleanup()
    await rate_limiter.close()
    await engine.dispose()


app = FastAPI(
    title="ID Service",
    description="OpenID Connect Identity Provider for asynq.ru",
    version="1.0.0",
    docs_url="/docs" if settings.APP_ENV == "development" else None,
    redoc_url="/redoc" if settings.APP_ENV == "development" else None,
    lifespan=lifespan,
)

# ---------------------------
# Global middlewares
# ---------------------------

class SecurityHeadersMiddleware(BaseHTTPMiddleware):
    """Базовые security-заголовки на все ответы."""
    async def dispatch(self, request, call_next):
        resp = await call_next(request)
        resp.headers.setdefault("X-Frame-Options", "DENY")
        resp.headers.setdefault("X-Content-Type-Options", "nosniff")
        resp.headers.setdefault("Referrer-Policy", "no-referrer")
        if settings.APP_ENV == "production":
            resp.headers.setdefault("Strict-Transport-Security", "max-age=31536000; includeSubDomains; preload")
        return resp


class JSONContentTypeMiddleware(BaseHTTPMiddleware):
    """Для /auth/** и /account/** требуем JSON на небезопасных методах."""
    def _needs_json(self, path: str) -> bool:
        if path in ("/auth/csrf", "/api/auth/csrf"):
            return False
        return (
            path.startswith("/auth/")
            or path.startswith("/api/auth/")
            or path.startswith("/account/")
            or path.startswith("/api/account/")
        )

    async def dispatch(self, request: Request, call_next):
        if request.method in {"POST", "PUT", "PATCH", "DELETE"} and self._needs_json(request.url.path):
            ct = request.headers.get("content-type", "")
            if "application/json" not in ct.lower():
                # 415 Unsupported Media Type — явный сигнал клиенту
                return JSONResponse(
                    {"error": {"code": 415, "message": "Content-Type must be application/json", "details": {"required": "application/json"}}},
                    status_code=415,
                )
        return await call_next(request)


class CSRFMiddleware(BaseHTTPMiddleware):
    """Проверка CSRF по заголовку X-CSRF-Token (double-submit cookie)."""
    async def dispatch(self, request, call_next):
        if csrf_protection.should_check_csrf(request):
            await csrf_protection.validate_token(request)
        return await call_next(request)


class AuthCacheHeadersMiddleware(BaseHTTPMiddleware):
    """Отключаем кэш для /auth/** и OIDC-эндпоинтов.
    Исключения: discovery и jwks.
    """
    OIDC_PATHS = {"/authorize", "/token", "/userinfo", "/logout", "/revoke"}
    DISCOVERY = "/.well-known/openid-configuration"
    JWKS = "/.well-known/jwks.json"

    async def dispatch(self, request, call_next):
        resp = await call_next(request)
        p = request.url.path
        is_auth = p.startswith(("/auth/","/api/auth/","/account/","/api/account/"))
        is_oidc = p in self.OIDC_PATHS
        is_static = p in {self.DISCOVERY, self.JWKS}
        if (is_auth or is_oidc) and not is_static:
            resp.headers.setdefault("Cache-Control","no-store")
            resp.headers.setdefault("Pragma","no-cache")
        return resp



# Порядок имеет значение
app.add_middleware(SecurityHeadersMiddleware)
app.add_middleware(JSONContentTypeMiddleware)
app.add_middleware(CSRFMiddleware)
app.add_middleware(AuthCacheHeadersMiddleware)
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.CORS_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
if settings.APP_ENV == "production":
    app.add_middleware(TrustedHostMiddleware, allowed_hosts=["id.asynq.ru", "*.asynq.ru"])


# ---------------------------
# Routers
# ---------------------------

# OIDC endpoints
app.include_router(discovery.router, tags=["OIDC Discovery"])
app.include_router(jwks.router, tags=["OIDC JWKS"])
app.include_router(authorize.router, tags=["OIDC Authorization"])
app.include_router(token.router, tags=["OIDC Token"])
app.include_router(userinfo.router, tags=["OIDC UserInfo"])
app.include_router(logout.router, tags=["OIDC Logout"])
app.include_router(revoke.router, tags=["OIDC Token"])

# Auth endpoints
app.include_router(register.router,          prefix="/api/auth", tags=["Authentication"])
app.include_router(login.router,             prefix="/api/auth", tags=["Authentication"])
app.include_router(password_reset.router,    prefix="/api/auth", tags=["Authentication"])
app.include_router(email_verification.router,prefix="/api/auth", tags=["Authentication"])
app.include_router(csrf_api.router,          prefix="/api/auth", tags=["Authentication"])

# Account management endpoints
app.include_router(profile.router,           prefix="/api/account", tags=["Account"])
app.include_router(email_change.router,      prefix="/api/account", tags=["Account"])
app.include_router(password_change.router,   prefix="/api/account", tags=["Account"])
app.include_router(delete_account.router,    prefix="/api/account", tags=["Account"])

# Health
app.include_router(health.router, tags=["Health"])


@app.get("/")
async def root():
    return {"service": "ID Service", "version": "1.0.0", "issuer": settings.ISSUER}


# ---------------------------
# Global exception handlers
# ---------------------------

@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    """
    Унифицированные JSON-ошибки для всех не-OAuth ручек.
    /oidc/token и /oidc/revoke сами формируют RFC-ошибки и сюда не попадут,
    т.к. возвращают JSONResponse напрямую.
    """
    payload = {"error": {"code": exc.status_code, "message": exc.detail}}
    return JSONResponse(payload, status_code=exc.status_code)


@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    """Валидационные ошибки Pydantic/FastAPI → единый формат."""
    details = exc.errors()
    payload = {"error": {"code": 422, "message": "Validation error", "details": details}}
    return JSONResponse(payload, status_code=422)

@app.exception_handler(ValidationError)
async def pydantic_validation_handler(request: Request, exc: ValidationError):
    return JSONResponse(
        {"error": {"code": 422, "message": "Validation error", "details": exc.errors()}},
        status_code=422,
    )

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        reload=settings.APP_ENV == "development",
        log_level="debug" if settings.APP_ENV == "development" else "info",
    )



/* ===== C:\Users\icipa\team-platform-public\id_service\models\__init__.py ===== */

# id_service/models/__init__.py

from .user import User
from .client import Client, ClientType, TokenAuthMethod
from .auth_code import AuthCode
from .refresh_token import RefreshToken
from .email_code import EmailCode, EmailCodePurpose
from .jwk_key import JWKKey
from .idp_session import IDPSession

__all__ = [
    "User",
    "Client",
    "ClientType",
    "TokenAuthMethod",
    "AuthCode",
    "RefreshToken",
    "EmailCode",
    "EmailCodePurpose",
    "JWKKey",
    "IDPSession",
]


/* ===== C:\Users\icipa\team-platform-public\id_service\models\auth_code.py ===== */

# id_service/models/auth_code.py

from datetime import datetime
from sqlalchemy import Column, String, DateTime, ForeignKey, Text, Boolean
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
import uuid

from db.base import Base


class AuthCode(Base):
    __tablename__ = "auth_codes"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    code_hash = Column(String(255), unique=True, nullable=False, index=True)
    
    # Relations
    client_id = Column(String(255), ForeignKey("clients.client_id"), nullable=False)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    
    # OIDC parameters
    redirect_uri = Column(Text, nullable=False)
    scope = Column(String(500), nullable=False)
    code_challenge_hash = Column(String(255), nullable=True)  # For PKCE
    nonce = Column(String(255), nullable=True)
    state = Column(String(500), nullable=True)
    
    # Security
    auth_time = Column(DateTime(timezone=True), nullable=False)
    expires_at = Column(DateTime(timezone=True), nullable=False, index=True)
    used_at = Column(DateTime(timezone=True), nullable=True)
    
    # Request info
    ip_address = Column(String(45), nullable=True)
    user_agent = Column(Text, nullable=True)
    
    # Relations
    client = relationship("Client", backref="auth_codes", lazy="joined")
    user = relationship("User", backref="auth_codes", lazy="joined")


/* ===== C:\Users\icipa\team-platform-public\id_service\models\client.py ===== */

# id_service/models/client.py

from datetime import datetime
from typing import Optional
import enum

from sqlalchemy import Column, String, Text, Boolean, DateTime, Index, func, Enum as SAEnum
from sqlalchemy.dialects.postgresql import UUID, JSONB
import uuid

from db.base import Base


class ClientType(str, enum.Enum):
    PUBLIC = "public"
    CONFIDENTIAL = "confidential"


class TokenAuthMethod(str, enum.Enum):
    NONE = "none"
    CLIENT_SECRET_POST = "client_secret_post"
    CLIENT_SECRET_BASIC = "client_secret_basic"


class Client(Base):
    __tablename__ = "clients"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)

    client_id = Column(String(255), unique=True, nullable=False, index=True)
    name = Column(String(255), nullable=False)

    type = Column(
        SAEnum(
            ClientType,
            name="clienttype",
            values_callable=lambda e: [i.value for i in e],
        ),
        nullable=False,
    )
    
    token_endpoint_auth_method = Column(
        SAEnum(
            TokenAuthMethod,
            name="tokenauthmethod",
            values_callable=lambda e: [i.value for i in e],
        ),
        nullable=False,
    )
    
    pkce_required = Column(Boolean, nullable=False, default=True)

    redirect_uris = Column(JSONB, nullable=False, default=list)
    post_logout_redirect_uris = Column(JSONB, nullable=False, default=list)
    backchannel_logout_uri = Column(Text, nullable=True)
    frontchannel_logout_uri = Column(Text, nullable=True)

    scopes = Column(JSONB, nullable=False, default=lambda: ["openid", "email", "profile"])

    client_secret_hash = Column(Text, nullable=True)
    secret_rotated_at = Column(DateTime(timezone=True), nullable=True)

    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now(),
        nullable=False,
    )

    __table_args__ = (
        Index("ux_clients_client_id", "client_id", unique=True),
    )



/* ===== C:\Users\icipa\team-platform-public\id_service\models\email_code.py ===== */

# id_service/models/email_code.py

from datetime import datetime
from sqlalchemy import Column, Text, Index, String, DateTime, ForeignKey, Integer
from sqlalchemy import Enum as SAEnum
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
import uuid
import enum

from db.base import Base


class EmailCodePurpose(str, enum.Enum):
    REGISTER = "register"
    RESET_PASSWORD = "reset"
    CHANGE_EMAIL = "change_email"


class EmailCode(Base):
    __tablename__ = "email_codes"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    
    # Relations
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    
    # Code details
    purpose = Column(
        SAEnum(
            EmailCodePurpose,
            name="emailcodepurpose",
            values_callable=lambda e: [i.value for i in e],
        ),
        nullable=False,
    )
    code_hash = Column(String(255), nullable=False)
    new_email = Column(String(255), nullable=True)  # For email change
    
    # Security
    expires_at = Column(DateTime(timezone=True), nullable=False, index=True)
    attempts = Column(Integer, default=0, nullable=False)
    resend_after = Column(DateTime(timezone=True), nullable=False)
    used_at = Column(DateTime(timezone=True), nullable=True)
    
    # Request info
    ip_address = Column(String(45), nullable=True)
    user_agent = Column(Text, nullable=True)
    
    # Relations
    user = relationship("User", backref="email_codes", lazy="joined")
    
    __table_args__ = (
        Index('ix_email_codes_user_purpose', 'user_id', 'purpose', 'expires_at'),
    )


/* ===== C:\Users\icipa\team-platform-public\id_service\models\idp_session.py ===== */

# id_service/models/idp_session.py

from datetime import datetime
from sqlalchemy import Column, String, DateTime, ForeignKey, Text, Index
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
import uuid

from db.base import Base


class IDPSession(Base):
    __tablename__ = "idp_sessions"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    session_id = Column(String(255), unique=True, nullable=False, index=True)  # sid for OIDC
    
    # Relations
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    
    # Session tracking
    last_seen_at = Column(DateTime(timezone=True), nullable=False)
    idle_expires_at = Column(DateTime(timezone=True), nullable=False, index=True)
    max_expires_at = Column(DateTime(timezone=True), nullable=False, index=True)
    
    # Request info
    ip_address = Column(String(45), nullable=True)
    user_agent = Column(Text, nullable=True)
    
    # Status
    created_at = Column(DateTime(timezone=True), nullable=False)
    revoked_at = Column(DateTime(timezone=True), nullable=True)
    
    # Relations
    user = relationship("User", backref="idp_sessions", lazy="joined")
    
    __table_args__ = (
        Index('ix_idp_sessions_user_revoked', 'user_id', 'revoked_at'),
    )


/* ===== C:\Users\icipa\team-platform-public\id_service\models\jwk_key.py ===== */

# id_service/models/jwk_key.py

from datetime import datetime
from sqlalchemy import Column, String, Text, Boolean, DateTime, Index, func
from sqlalchemy.dialects.postgresql import UUID
import uuid

from db.base import Base


class JWKKey(Base):
    __tablename__ = "jwk_keys"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    kid = Column(String(255), unique=True, nullable=False, index=True)  # Key ID
    alg = Column(String(10), nullable=False, default="RS256")
    
    # Key material
    public_pem = Column(Text, nullable=False)
    private_pem_encrypted = Column(Text, nullable=False)  # Encrypted with app secret
    
    # Status
    active = Column(Boolean, default=True, nullable=False)
    
    # Timestamps
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    rotated_at = Column(DateTime(timezone=True), nullable=True)
    expires_at = Column(DateTime(timezone=True), nullable=True)
    
    __table_args__ = (
        Index('ix_jwk_keys_active_kid', 'active', 'kid'),
    )


/* ===== C:\Users\icipa\team-platform-public\id_service\models\refresh_token.py ===== */

# id_service/models/refresh_token.py

from datetime import datetime
from sqlalchemy import Column, String, DateTime, ForeignKey, Text, Index
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
import uuid

from db.base import Base


class RefreshToken(Base):
    __tablename__ = "refresh_tokens"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    jti = Column(String(255), unique=True, nullable=False, index=True)  # JWT ID
    
    # Relations
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    client_id = Column(String(255), ForeignKey("clients.client_id"), nullable=False)
    
    # Token chain (for rotation)
    parent_jti = Column(String(255), nullable=True, index=True)  # Parent token that created this
    prev_jti = Column(String(255), nullable=True)  # Previous token in rotation chain
    
    # Scope
    scope = Column(String(500), nullable=False)
    
    # Timestamps
    created_at = Column(DateTime(timezone=True), nullable=False)
    expires_at = Column(DateTime(timezone=True), nullable=False, index=True)
    rotated_at = Column(DateTime(timezone=True), nullable=True)
    revoked_at = Column(DateTime(timezone=True), nullable=True)
    revoked_reason = Column(String(255), nullable=True)
    
    # Request info
    ip_address = Column(String(45), nullable=True)
    user_agent = Column(Text, nullable=True)
    
    # Relations
    user = relationship("User", backref="refresh_tokens", lazy="joined")
    client = relationship("Client", backref="refresh_tokens", lazy="joined")
    
    __table_args__ = (
        Index('ix_refresh_tokens_user_client', 'user_id', 'client_id', 'revoked_at', 'expires_at'),
    )


/* ===== C:\Users\icipa\team-platform-public\id_service\models\user.py ===== */

# id_service/models/user.py
from __future__ import annotations

import uuid
from sqlalchemy import Column, String, Text, Boolean, Integer, DateTime, Index, func
from sqlalchemy.dialects.postgresql import UUID
from db.base import Base


class User(Base):
    __tablename__ = "users"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)

    # Логинные поля
    email = Column(String(255), nullable=False)          # храним в lower на уровне приложения
    username = Column(String(50), nullable=False)

    # Безопасность
    password_hash = Column(Text, nullable=False)
    email_verified = Column(Boolean, nullable=False, default=False)
    failed_login_attempts = Column(Integer, nullable=False, default=0)

    # Аудит
    last_login_at = Column(DateTime(timezone=True), nullable=True)
    last_password_change_at = Column(DateTime(timezone=True), nullable=True)

    # Таймстемпы и soft-delete
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)
    deleted_at = Column(DateTime(timezone=True), nullable=True)

    __table_args__ = (
        # case-insensitive уникальность e-mail
        Index("ux_users_email_lower", func.lower(email), unique=True),
        Index("ux_users_username", "username", unique=True),
    )



/* ===== C:\Users\icipa\team-platform-public\id_service\requirements.txt ===== */

# id_service/requirements.txt

# Core
fastapi==0.115.0
uvicorn[standard]==0.32.0
pydantic==2.9.2
pydantic-settings==2.6.0

# Database
sqlalchemy==2.0.35
asyncpg==0.30.0
alembic==1.14.0

# Redis
redis==5.2.0

# Security & Auth
authlib==1.3.2
python-jose[cryptography]==3.3.0
argon2-cffi==23.1.0
cryptography==43.0.3

# HTTP & Forms
python-multipart==0.0.12
httpx==0.27.2

# Email
aiosmtplib==3.0.2
email-validator==2.2.0
jinja2==3.1.4

# Utilities
python-dotenv==1.0.1
itsdangerous==2.2.0

# Development (optional)
pytest==8.3.3
pytest-asyncio==0.24.0
black==24.10.0
ruff==0.7.4


/* ===== C:\Users\icipa\team-platform-public\id_service\schemas\__init__.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\schemas\account.py ===== */

# id_service/schemas/account.py

from pydantic import BaseModel, Field, EmailStr, field_validator, ConfigDict
from pydantic import FieldValidationInfo
from typing import Optional, List
from datetime import datetime

from core.security import security


class ProfileResponse(BaseModel):
    """User profile response schema"""
    email: str
    username: str
    email_verified: bool
    created_at: datetime
    last_login_at: Optional[datetime] = None
    
    model_config = ConfigDict(from_attributes=True)


class ChangeEmailRequest(BaseModel):
    """Change email request schema"""
    new_email: EmailStr = Field(..., description="New email address")
    password: str = Field(..., description="Current password for verification")
    
    model_config = ConfigDict(str_strip_whitespace=True)
    
    @field_validator('new_email')
    @classmethod
    def normalize_email(cls, v: str) -> str:
        return v.lower()


class ChangeEmailResponse(BaseModel):
    """Change email response schema"""
    message: str = "Verification code sent to new email address"


class ConfirmEmailChangeRequest(BaseModel):
    new_email: EmailStr
    code: str = Field(..., pattern=r'^\d{4}$', description="4-digit verification code")
  
    model_config = ConfigDict(str_strip_whitespace=True)
  
    @field_validator('new_email')
    @classmethod
    def normalize_email(cls, v: str) -> str:
        return v.lower()


class ConfirmEmailChangeResponse(BaseModel):
    """Confirm email change response schema"""
    message: str = "Email address updated successfully"


class ChangePasswordRequest(BaseModel):
    """Change password request schema"""
    old_password: str = Field(..., description="Current password")
    new_password: str = Field(..., min_length=8, description="New password")
    new_password_confirm: str = Field(..., description="New password confirmation")
    
    @field_validator('new_password')
    @classmethod
    def validate_password(cls, v: str) -> str:
        valid, error = security.validate_password_strength(v)
        if not valid:
            raise ValueError(error)
        return v
    
    @field_validator('new_password_confirm')
    @classmethod
    def passwords_match(cls, v: str, info: FieldValidationInfo) -> str:
        if info.data.get('new_password') and v != info.data['new_password']:
            raise ValueError('Passwords do not match')
        return v


class ChangePasswordResponse(BaseModel):
    """Change password response schema"""
    message: str = "Password changed successfully"


class DeleteAccountRequest(BaseModel):
    """Delete account request schema"""
    current_password: str
    confirmation: str = Field(..., pattern=r'^DELETE$', description="Type DELETE to confirm")


class DeleteAccountResponse(BaseModel):
    """Delete account response schema"""
    message: str = "Account has been deleted"


/* ===== C:\Users\icipa\team-platform-public\id_service\schemas\auth.py ===== */

# id_service/schemas/auth.py
"""
Схемы (Pydantic v2) для auth-флоу.
Важно:
- Все ручки, кроме /oidc/token и /oidc/revoke, работают в JSON.
- Здесь описываем только структуры запросов/ответов и валидацию полей.
"""

from pydantic import BaseModel, EmailStr, ConfigDict
from typing import Optional
from datetime import datetime
from pydantic import field_validator, FieldValidationInfo, Field

from utils.validators import validators
from core.security import security


# ---------------------------
# Регистрация
# ---------------------------

class RegisterRequest(BaseModel):
    """Запрос на регистрацию."""
    username: str = Field(..., min_length=3, max_length=30, description="Username")
    email: EmailStr = Field(..., description="Email address")
    password: str = Field(..., min_length=8, description="Password")
    password_confirm: str = Field(..., description="Password confirmation")

    # Общие настройки модели
    model_config = ConfigDict(str_strip_whitespace=True)

    @field_validator('username')
    @classmethod
    def validate_username(cls, v: str) -> str:
        ok, err = validators.validate_username(v)
        if not ok:
            raise ValueError(err)
        return v

    @field_validator('email')
    @classmethod
    def normalize_email(cls, v: str) -> str:
        return v.lower()

    @field_validator('password')
    @classmethod
    def validate_password(cls, v: str) -> str:
        ok, err = security.validate_password_strength(v)
        if not ok:
            raise ValueError(err)
        return v

    @field_validator('password_confirm')
    @classmethod
    def passwords_match(cls, v: str, info: FieldValidationInfo) -> str:
        if info.data.get('password') and v != info.data['password']:
            raise ValueError('Passwords do not match')
        return v
    

class RegisterResponse(BaseModel):
    """Ответ на регистрацию."""
    user_id: str
    email: EmailStr
    requires_verification: bool = True
    message: str = "Registration successful. Please check your email for verification code."
    
# ---------------------------
# Подтверждение e-mail (OTP)
# ---------------------------

class VerifyEmailRequest(BaseModel):
    """Подтверждение e-mail по OTP-коду.
    Дополнительно поддерживает state для завершения pending /authorize.
    """
    user_id: str = Field(..., description="User ID from registration")
    code: str = Field(..., pattern=r'^\d{4}$', description="4-digit verification code")
    state: Optional[str] = None

    model_config = ConfigDict(str_strip_whitespace=True)


class VerifyEmailResponse(BaseModel):
    """Ответ на верификацию e-mail."""
    ok: bool = True
    message: str = "Email verified successfully"
    redirect_to: Optional[str] = None  # для SPA-редиректа без 302


# ---------------------------
# Логин по паролю (JSON-only)
# ---------------------------

class LoginPasswordRequest(BaseModel):
    """Запрос логина по паролю.
    JSON-only. Формы не используются.
    Если переданы client_id+state и в Redis есть pending authreq — вернём redirect_to.
    """
    email: EmailStr = Field(..., description="Email address")
    password: str = Field(..., description="Password")
    remember_me: bool = Field(default=False, description="Extended session duration")
    # Дополнительно для OIDC продолжения (опционально):
    client_id: Optional[str] = Field(default=None, description="OIDC client_id for pending /authorize")
    state: Optional[str] = Field(default=None, description="State from pending /authorize")

    model_config = ConfigDict(str_strip_whitespace=True)

    @field_validator('email')
    @classmethod
    def normalize_email(cls, v: str) -> str:
        return v.lower()


class LoginPasswordResponse(BaseModel):
    """Ответ на логин по паролю."""
    ok: bool = True
    message: str = "Login successful"
    redirect_to: Optional[str] = None  # SPA-редирект без 302, либо null


# ---------------------------
# Сброс пароля (OTP → reset_token)
# ---------------------------

class ForgotPasswordRequest(BaseModel):
    """Запрос на отправку кода для сброса пароля."""
    email: EmailStr = Field(..., description="Email address")

    model_config = ConfigDict(str_strip_whitespace=True)

    @field_validator('email')
    @classmethod
    def normalize_email(cls, v: str) -> str:
        return v.lower()


class ForgotPasswordResponse(BaseModel):
    """Ответ на запрос сброса пароля.
    Текст одинаковый, чтобы не раскрывать наличие аккаунта.
    """
    message: str = "If an account exists with this email, a reset code has been sent"


class VerifyResetRequest(BaseModel):
    """Подтверждение кода для сброса пароля."""
    email: EmailStr = Field(..., description="Email address")
    code: str = Field(..., pattern=r'^\d{4}$', description="4-digit reset code")

    model_config = ConfigDict(str_strip_whitespace=True)

    @field_validator('email')
    @classmethod
    def normalize_email(cls, v: str) -> str:
        return v.lower()


class VerifyResetResponse(BaseModel):
    """Ответ с reset_token для установки нового пароля."""
    user_id: str
    reset_token: str


class SetNewPasswordRequest(BaseModel):
    """Установка нового пароля после успешной верификации сброса."""
    user_id: str = Field(..., description="User ID from reset verification")
    reset_token: str = Field(..., description="Reset token from verification")
    new_password: str = Field(..., min_length=8, description="New password")
    new_password_confirm: str = Field(..., description="New password confirmation")

    @field_validator('new_password')
    @classmethod
    def validate_password(cls, v: str) -> str:
        ok, err = security.validate_password_strength(v)
        if not ok:
            raise ValueError(err)
        return v

    @field_validator('new_password_confirm')
    @classmethod
    def passwords_match(cls, v: str, info: FieldValidationInfo) -> str:
        if info.data.get('new_password') and v != info.data['new_password']:
            raise ValueError('Passwords do not match')
        return v


class SetNewPasswordResponse(BaseModel):
    """Ответ на успешную установку нового пароля."""
    message: str = "Password has been reset successfully"



/* ===== C:\Users\icipa\team-platform-public\id_service\schemas\oidc.py ===== */

# id_service/schemas/oidc.py
"""
Схемы (Pydantic v2) для OIDC.
Важно:
- /oidc/logout теперь имеет JSON-вариант (POST) с телом/ответом ниже.
- /oidc/token и /oidc/revoke остаются RFC-совместимыми и свои ошибки формируют сами.
"""

from __future__ import annotations

from typing import List, Optional
from pydantic import BaseModel, ConfigDict, Field


# ---------------------------
# OIDC Discovery
# ---------------------------

class DiscoveryResponse(BaseModel):
    issuer: str
    authorization_endpoint: str
    token_endpoint: str
    userinfo_endpoint: str
    jwks_uri: str
    end_session_endpoint: str

    response_types_supported: List[str]
    grant_types_supported: List[str]
    scopes_supported: List[str]
    id_token_signing_alg_values_supported: List[str]
    subject_types_supported: List[str]
    token_endpoint_auth_methods_supported: List[str]
    code_challenge_methods_supported: List[str]
    claims_supported: List[str]

    frontchannel_logout_supported: bool
    backchannel_logout_supported: bool
    backchannel_logout_session_supported: bool


# ---------------------------
# UserInfo
# ---------------------------

class UserInfoResponse(BaseModel):
    sub: str
    email: Optional[str] = None
    email_verified: Optional[bool] = None
    preferred_username: Optional[str] = None
    updated_at: Optional[int] = None

    model_config = ConfigDict(from_attributes=True)


# ---------------------------
# RP-Initiated Logout (JSON)
# ---------------------------

class LogoutRequest(BaseModel):
    """JSON-запрос на логаут по OIDC.
    Примечание: post_logout_redirect_uri валидируется по клиенту из id_token_hint.
    """
    id_token_hint: Optional[str] = Field(
        default=None,
        description="ID Token пользователя для определения клиента и валидации post_logout_redirect_uri"
    )
    post_logout_redirect_uri: Optional[str] = Field(
        default=None,
        description="Куда редиректить после логаута, если валиден для клиента"
    )
    state: Optional[str] = Field(
        default=None,
        description="Опциональное состояние, вернётся как параметр в redirect_to"
    )


class LogoutResponse(BaseModel):
    """JSON-ответ логаута.
    redirect_to: абсолютный URL или null. Фронт сам выполнит переход, 302 нет.
    """
    ok: bool = True
    redirect_to: Optional[str] = None



/* ===== C:\Users\icipa\team-platform-public\id_service\schemas\token.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\schemas\user.py ===== */

# id_service/schemas/user.py
from __future__ import annotations

from typing import Optional
from datetime import datetime

from pydantic import BaseModel, EmailStr, Field, field_validator, ConfigDict, FieldValidationInfo

from utils.validators import validators
from core.security import security


class UserBase(BaseModel):
    email: EmailStr
    username: str = Field(min_length=3, max_length=30)

    model_config = ConfigDict(str_strip_whitespace=True)

    @field_validator("email")
    @classmethod
    def normalize_email(cls, v: str) -> str:
        return v.lower()

    @field_validator("username")
    @classmethod
    def validate_username(cls, v: str) -> str:
        ok, err = validators.validate_username(v)
        if not ok:
            raise ValueError(err)
        return v


class UserCreate(UserBase):
    password: str = Field(min_length=8)
    email_verified: bool = False

    @field_validator("password")
    @classmethod
    def validate_password(cls, v: str) -> str:
        ok, err = security.validate_password_strength(v)
        if not ok:
            raise ValueError(err)
        return v


class UserUpdate(BaseModel):
    email: Optional[EmailStr] = None
    username: Optional[str] = Field(default=None, min_length=3, max_length=30)
    email_verified: Optional[bool] = None

    model_config = ConfigDict(str_strip_whitespace=True)

    @field_validator("email")
    @classmethod
    def normalize_email(cls, v: Optional[str]) -> Optional[str]:
        return v.lower() if v else v

    @field_validator("username")
    @classmethod
    def validate_username(cls, v: Optional[str]) -> Optional[str]:
        if v is None:
            return v
        ok, err = validators.validate_username(v)
        if not ok:
            raise ValueError(err)
        return v


class UserRead(BaseModel):
    id: str
    email: str
    username: str
    email_verified: bool
    created_at: datetime
    updated_at: Optional[datetime] = None
    last_login_at: Optional[datetime] = None

    model_config = ConfigDict(from_attributes=True)



/* ===== C:\Users\icipa\team-platform-public\id_service\services\__init__.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\services\auth_service.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\services\backchannel_logout.py ===== */

# id_service/services/backchannel_logout.py

import asyncio
import logging
import secrets
from datetime import datetime, timezone
from typing import List, Optional, Dict, Any
from jose import jwt
import httpx
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_
from db.session import async_session_maker

from models import Client, RefreshToken, User
from core.config import settings
from services.jwk_service import jwk_service

logger = logging.getLogger(__name__)


class BackchannelLogoutService:
    """Service for handling back-channel logout notifications"""
    
    def __init__(self):
        self.http_client = httpx.AsyncClient(
            timeout=httpx.Timeout(10.0),
            limits=httpx.Limits(max_keepalive_connections=5, max_connections=10)
        )
    
    async def __aenter__(self):
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.http_client.aclose()
    
    async def initiate_backchannel_logout(
        self,
        session: Optional[AsyncSession],
        user: User,
        session_id: Optional[str] = None,
        reason: str = "user_logout",
        only_client_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """Initiate back-channel logout for all user's active sessions"""
        owns_session = False
        if session is None:
            owns_session = True
            session_ctx = async_session_maker()
            session = await session_ctx.__aenter__()
        try:
            active_clients = await self._get_user_active_clients(session, user.id, session_id, only_client_id)
            
            if not active_clients:
                logger.info(f"No active clients found for user {user.id}")
                return {"notified_clients": [], "failed_clients": []}
            
            # Create logout tasks for each client
            tasks = []
            for client in active_clients:
                if client.backchannel_logout_uri:
                    task = self._send_logout_notification(
                        client=client,
                        user=user,
                        session_id=session_id,
                        reason=reason
                    )
                    tasks.append((client.client_id, task))
            
            # Execute all logout notifications concurrently
            notified_clients = []
            failed_clients = []
            
            if tasks:
                results = await asyncio.gather(
                    *[task for _, task in tasks],
                    return_exceptions=True
                )
                
                for (client_id, _), result in zip(tasks, results):
                    if isinstance(result, Exception):
                        logger.error(f"Failed to notify client {client_id}: {result}")
                        failed_clients.append(client_id)
                    elif result:
                        notified_clients.append(client_id)
                    else:
                        failed_clients.append(client_id)
            
            logger.info(
                f"Back-channel logout completed for user {user.id}. "
                f"Notified: {len(notified_clients)}, Failed: {len(failed_clients)}"
            )
        
            return {
                "notified_clients": notified_clients,
                "failed_clients": failed_clients,
                "reason": reason
            }
        finally:
            if owns_session:
                await session_ctx.__aexit__(None, None, None)

    async def _get_user_active_clients(
        self,
        session: AsyncSession,
        user_id: str,
        session_id: Optional[str] = None,
        only_client_id: Optional[str] = None
    ) -> List[Client]:
        """Get all clients with active sessions or tokens for a user.
        Если передан only_client_id — вернуть клиента даже без активных токенов."""
        if only_client_id:
            cres = await session.execute(select(Client).where(Client.client_id == only_client_id))
            client = cres.scalar_one_or_none()
            return [client] if client else []
        client_ids: set[str] = set()
        clients: list[Client] = []

        q = select(RefreshToken).where(
            and_(
                RefreshToken.user_id == user_id,
                RefreshToken.revoked_at.is_(None),
                RefreshToken.expires_at > datetime.now(timezone.utc)
            )
        )
        if only_client_id:
            q = q.where(RefreshToken.client_id == only_client_id)

        result = await session.execute(q)
        tokens = result.scalars().all()
        for token in tokens:
            if token.client_id not in client_ids:
                cres = await session.execute(select(Client).where(Client.client_id == token.client_id))
                client = cres.scalar_one_or_none()
                if client:
                    client_ids.add(client.client_id)
                    clients.append(client)

        return clients

    
    async def _send_logout_notification(
        self,
        client: Client,
        user: User,
        session_id: Optional[str] = None,
        reason: str = "user_logout"
    ) -> bool:
        """Send logout notification to a single client"""
        
        if not client.backchannel_logout_uri:
            logger.warning(f"Client {client.client_id} has no backchannel logout URI")
            return False
        
        try:
            # Create logout token
            logout_token = await self._create_logout_token(
                client=client,
                user=user,
                session_id=session_id
            )
            
            # Send POST request to client's backchannel logout URI
            response = await self.http_client.post(
                client.backchannel_logout_uri,
                data={"logout_token": logout_token},
                headers={"Content-Type": "application/x-www-form-urlencoded"},
                follow_redirects=False
            )
            
            # Check response
            if response.status_code == 200:
                logger.info(
                    f"Successfully notified client {client.client_id} "
                    f"for user {user.id} logout (reason: {reason})"
                )
                return True
            else:
                logger.warning(
                    f"Client {client.client_id} returned {response.status_code} "
                    f"for logout notification"
                )
                return False
                
        except httpx.TimeoutException:
            logger.error(f"Timeout notifying client {client.client_id}")
            return False
        except Exception as e:
            logger.error(f"Error notifying client {client.client_id}: {e}")
            return False
    
    async def _create_logout_token(
        self,
        client: Client,
        user: User,
        session_id: Optional[str] = None
    ) -> str:
        """Create a logout token according to OIDC Back-Channel Logout spec"""
        
        # Get active JWK key
        jwk_key = await jwk_service.get_active_key()
        if not jwk_key:
            raise RuntimeError("No active JWK key available")
        
        # Decrypt private key
        private_key_pem = jwk_service.decrypt_private_key(jwk_key.private_pem_encrypted)
        
        now = datetime.now(timezone.utc)
        
        # Create logout token claims
        claims = {
            "iss": settings.ISSUER,
            "aud": client.client_id,
            "iat": int(now.timestamp()),
            "jti": secrets.token_urlsafe(16),
            "events": {
                "http://schemas.openid.net/event/backchannel_logout": {}
            }
        }
        
        # Add either sub or sid (or both)
        if session_id:
            claims["sid"] = session_id
        
        claims["sub"] = str(user.id)
        
        # Sign the token
        logout_token = jwt.encode(
            claims,
            private_key_pem,
            algorithm="RS256",
            headers={"kid": jwk_key.kid}
        )
        
        return logout_token
    
    async def cleanup(self):
        """Cleanup HTTP client"""
        await self.http_client.aclose()


# Global instance
backchannel_logout_service = BackchannelLogoutService()


/* ===== C:\Users\icipa\team-platform-public\id_service\services\email_service.py ===== */

# id_service/services/email_service.py

import logging
import aiosmtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from typing import Optional, Dict, Any
from jinja2 import Template

from core.config import settings

logger = logging.getLogger(__name__)


class EmailService:
    """Service for sending emails"""
    
    def __init__(self):
        self.smtp_host = settings.SMTP_HOST
        self.smtp_port = int(settings.SMTP_PORT)
        self.smtp_user = settings.SMTP_USER
        self.smtp_password = settings.SMTP_PASSWORD
        self.smtp_tls = settings.SMTP_TLS
        self.from_email = settings.EMAIL_FROM
    
    async def send_email(
        self,
        to_email: str,
        subject: str,
        html_content: str,
        text_content: Optional[str] = None
    ) -> bool:
        """Send email using SMTP"""
        try:
            # Create message
            message = MIMEMultipart("alternative")
            message["From"] = self.from_email
            message["To"] = to_email
            message["Subject"] = subject
            
            # Add text and HTML parts
            if text_content:
                text_part = MIMEText(text_content, "plain")
                message.attach(text_part)
            
            html_part = MIMEText(html_content, "html")
            message.attach(html_part)
            
            # Send email
            use_tls = int(self.smtp_port) == 465
            async with aiosmtplib.SMTP(
                hostname=self.smtp_host,
                port=self.smtp_port,
                use_tls=use_tls,
                start_tls=bool(self.smtp_tls) and not use_tls,
            ) as smtp:

                await smtp.login(self.smtp_user, self.smtp_password)
                await smtp.send_message(message)

            logger.info(f"Email sent successfully to {to_email}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to send email to {to_email}: {e}")
            return False
    
    async def send_verification_code(
        self,
        to_email: str,
        username: str,
        code: str,
        purpose: str = "registration"
    ) -> bool:
        """Send verification code email"""
        
        subject_map = {
            "registration": "Подтверждение регистрации на Asynq",
            "reset": "Сброс пароля на Asynq",
            "change_email": "Подтверждение смены email на Asynq"
        }
        
        subject = subject_map.get(purpose, "Код подтверждения Asynq")
        
        html_template = """
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <style>
                body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
                .container { max-width: 600px; margin: 0 auto; padding: 20px; }
                .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; border-radius: 10px 10px 0 0; }
                .content { background: #f7f7f7; padding: 30px; border-radius: 0 0 10px 10px; }
                .code-box { background: white; border: 2px solid #667eea; border-radius: 8px; padding: 20px; text-align: center; margin: 20px 0; }
                .code { font-size: 32px; font-weight: bold; letter-spacing: 8px; color: #667eea; }
                .footer { margin-top: 30px; padding-top: 20px; border-top: 1px solid #e0e0e0; font-size: 12px; color: #666; }
            </style>
        </head>
        <body>
            <div class="container">
                <div class="header">
                    <h1 style="margin: 0;">Asynq ID</h1>
                </div>
                <div class="content">
                    <h2>Здравствуйте, {{ username }}!</h2>
                    
                    {% if purpose == 'registration' %}
                        <p>Спасибо за регистрацию на платформе Asynq! Для завершения регистрации введите код подтверждения:</p>
                    {% elif purpose == 'reset' %}
                        <p>Вы запросили сброс пароля. Используйте этот код для подтверждения:</p>
                    {% elif purpose == 'change_email' %}
                        <p>Вы запросили смену email адреса. Используйте этот код для подтверждения нового адреса:</p>
                    {% endif %}
                    
                    <div class="code-box">
                        <div class="code">{{ code }}</div>
                    </div>
                    
                    <p>Код действителен в течение 5 минут.</p>
                    
                    <p style="color: #666; font-size: 14px;">
                        Если вы не запрашивали этот код, просто проигнорируйте это письмо.
                    </p>
                    
                    <div class="footer">
                        <p>С уважением,<br>Команда Asynq</p>
                        <p>Это автоматическое сообщение, пожалуйста, не отвечайте на него.</p>
                    </div>
                </div>
            </div>
        </body>
        </html>
        """
        
        text_template = """
        Здравствуйте, {{ username }}!
        
        {% if purpose == 'registration' %}
        Спасибо за регистрацию на платформе Asynq! Для завершения регистрации введите код подтверждения:
        {% elif purpose == 'reset' %}
        Вы запросили сброс пароля. Используйте этот код для подтверждения:
        {% elif purpose == 'change_email' %}
        Вы запросили смену email адреса. Используйте этот код для подтверждения нового адреса:
        {% endif %}
        
        Код: {{ code }}
        
        Код действителен в течение 5 минут.
        
        Если вы не запрашивали этот код, просто проигнорируйте это письмо.
        
        С уважением,
        Команда Asynq
        """
        
        # Render templates
        html_content = Template(html_template).render(
            username=username,
            code=code,
            purpose=purpose
        )
        
        text_content = Template(text_template).render(
            username=username,
            code=code,
            purpose=purpose
        )
        
        return await self.send_email(
            to_email=to_email,
            subject=subject,
            html_content=html_content,
            text_content=text_content
        )
    
    async def send_password_changed_notification(
        self,
        to_email: str,
        username: str
    ) -> bool:
        """Send notification about password change"""
        
        subject = "Ваш пароль был изменен"
        
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <style>
                body {{ font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }}
                .container {{ max-width: 600px; margin: 0 auto; padding: 20px; }}
                .header {{ background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; border-radius: 10px 10px 0 0; }}
                .content {{ background: #f7f7f7; padding: 30px; border-radius: 0 0 10px 10px; }}
                .alert {{ background: #fff3cd; border: 1px solid #ffc107; border-radius: 8px; padding: 15px; margin: 20px 0; }}
            </style>
        </head>
        <body>
            <div class="container">
                <div class="header">
                    <h1 style="margin: 0;">Asynq ID</h1>
                </div>
                <div class="content">
                    <h2>Здравствуйте, {username}!</h2>
                    
                    <div class="alert">
                        <strong>⚠️ Важное уведомление о безопасности</strong>
                        <p>Ваш пароль был успешно изменен.</p>
                    </div>
                    
                    <p>Если вы не меняли пароль, немедленно свяжитесь с нашей службой поддержки.</p>
                    
                    <p>Для вашей безопасности все активные сессии были завершены. Вам потребуется войти заново на всех устройствах.</p>
                    
                    <div class="footer" style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e0e0e0; font-size: 12px; color: #666;">
                        <p>С уважением,<br>Команда Asynq</p>
                        <p>Это автоматическое сообщение, пожалуйста, не отвечайте на него.</p>
                    </div>
                </div>
            </div>
        </body>
        </html>
        """
        
        text_content = f"""
        Здравствуйте, {username}!
        
        Важное уведомление о безопасности:
        Ваш пароль был успешно изменен.
        
        Если вы не меняли пароль, немедленно свяжитесь с нашей службой поддержки.
        
        Для вашей безопасности все активные сессии были завершены. Вам потребуется войти заново на всех устройствах.
        
        С уважением,
        Команда Asynq
        """
        
        return await self.send_email(
            to_email=to_email,
            subject=subject,
            html_content=html_content,
            text_content=text_content
        )


email_service = EmailService()


/* ===== C:\Users\icipa\team-platform-public\id_service\services\jwk_service.py ===== */

# id_service/services/jwk_service.py

import json
import base64
import logging
from datetime import datetime, timezone, timedelta
from typing import Optional, Dict, Any, List
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.backends import default_backend
from cryptography.fernet import Fernet
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_

from models import JWKKey
from core.config import settings
from db.session import async_session_maker

logger = logging.getLogger(__name__)


class JWKService:
    """Service for managing JSON Web Keys"""
    
    def __init__(self):
        # Create encryption key from settings
        key = base64.urlsafe_b64encode(settings.JWT_PRIVATE_KEY_PASSWORD.encode()[:32].ljust(32, b'0'))
        self.cipher = Fernet(key)
    
    async def ensure_active_key(self) -> JWKKey:
        """Ensure there's an active JWK key, create if not exists"""
        async with async_session_maker() as session:
            # Check for active key
            result = await session.execute(
                select(JWKKey).where(JWKKey.active == True)
            )
            active_key = result.scalar_one_or_none()
            
            if not active_key:
                logger.info("No active JWK key found, generating new one...")
                active_key = await self.generate_new_key(session)
                await session.commit()
            
            return active_key
    
    async def generate_new_key(self, session: AsyncSession) -> JWKKey:
        """Generate new RSA key pair"""
        # Generate RSA key pair
        private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048,
            backend=default_backend()
        )
        
        # Get PEM representations
        private_pem = private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption()
        )
        
        public_pem = private_key.public_key().public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        )
        
        # Encrypt private key
        encrypted_private = self.cipher.encrypt(private_pem)
        
        # Generate kid
        import secrets
        kid = secrets.token_urlsafe(16)
        
        # Create key record
        jwk_key = JWKKey(
            kid=kid,
            alg="RS256",
            public_pem=public_pem.decode('utf-8'),
            private_pem_encrypted=encrypted_private.decode('utf-8'),
            active=True,
            created_at=datetime.now(timezone.utc)
        )
        
        # Deactivate old keys
        await session.execute(
            select(JWKKey).where(JWKKey.active == True).with_for_update()
        )
        result = await session.execute(
            select(JWKKey).where(JWKKey.active == True)
        )
        old_keys = result.scalars().all()
        for old_key in old_keys:
            old_key.active = False
            old_key.rotated_at = datetime.now(timezone.utc)
        
        session.add(jwk_key)
        return jwk_key
    
    async def get_active_key(self) -> Optional[JWKKey]:
        """Get current active key"""
        async with async_session_maker() as session:
            result = await session.execute(
                select(JWKKey).where(JWKKey.active == True)
            )
            return result.scalar_one_or_none()
    
    async def get_jwks(self) -> Dict[str, Any]:
        async with async_session_maker() as session:
            # держим предыдущие ключи минимум до истечения access/id токенов
            retention = timedelta(seconds=settings.ACCESS_TOKEN_TTL)
            cutoff = datetime.now(timezone.utc) - retention

            res = await session.execute(
                select(JWKKey).where(
                    or_(
                        JWKKey.active == True,
                        JWKKey.rotated_at >= cutoff
                    )
                )
            )
            keys = res.scalars().all()

            jwks = {"keys": []}
            for key in keys:
                public_key = serialization.load_pem_public_key(
                    key.public_pem.encode("utf-8"),
                    backend=default_backend()
                )
                numbers = public_key.public_numbers()
                def b64u(n: int) -> str:
                    b = n.to_bytes((n.bit_length() + 7) // 8, "big")
                    return base64.urlsafe_b64encode(b).decode().rstrip("=")
                jwks["keys"].append({
                    "kty": "RSA",
                    "use": "sig",
                    "kid": key.kid,
                    "alg": key.alg,
                    "n": b64u(numbers.n),
                    "e": b64u(numbers.e),
                })
            return jwks
        
    def decrypt_private_key(self, encrypted_pem: str) -> bytes:
        """Decrypt private key"""
        return self.cipher.decrypt(encrypted_pem.encode('utf-8'))

    async def get_key_by_kid(self, kid: str) -> Optional[JWKKey]:
        async with async_session_maker() as session:
            res = await session.execute(select(JWKKey).where(JWKKey.kid == kid))
            return res.scalar_one_or_none()
        
    
    def load_public_key(self, public_pem: str):
        return serialization.load_pem_public_key(public_pem.encode("utf-8"))

jwk_service = JWKService()


/* ===== C:\Users\icipa\team-platform-public\id_service\services\session_service.py ===== */

# id_service/services/session_service.py


import secrets
import logging
from datetime import datetime, timezone, timedelta
from typing import Optional, List
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_
from fastapi import Request, Response, Cookie

from models import IDPSession, User
from core.config import settings
from core.security import security

logger = logging.getLogger(__name__)


class SessionService:
    """Service for managing SSO sessions"""
    
    def __init__(self):
        self.cookie_name = "id_session"
        self.cookie_domain = "id.asynq.ru" if settings.APP_ENV == "production" else None
    
    async def create_session(
        self,
        session: AsyncSession,
        user: User,
        request: Request,
        remember_me: bool = False,   # <— добавили
    ) -> IDPSession:
        session_id = secrets.token_urlsafe(32)
        now = datetime.now(timezone.utc)

        max_ttl = settings.SSO_MAX_TTL if not remember_me else 30*24*3600

        idp_session = IDPSession(
            session_id=session_id,
            user_id=user.id,
            last_seen_at=now,
            idle_expires_at=now + timedelta(seconds=settings.SSO_IDLE_TTL),
            max_expires_at=now + timedelta(seconds=max_ttl),  # <— было SSO_MAX_TTL
            ip_address=request.client.host,
            user_agent=request.headers.get("User-Agent"),
            created_at=now
        )
        session.add(idp_session)
        await session.flush()
        return idp_session

    
    async def get_session(
        self,
        session: AsyncSession,
        session_id: str
    ) -> Optional[IDPSession]:
        """Get valid session by ID"""
        now = datetime.now(timezone.utc)
        
        result = await session.execute(
            select(IDPSession).where(
                and_(
                    IDPSession.session_id == session_id,
                    IDPSession.revoked_at.is_(None),
                    IDPSession.idle_expires_at > now,
                    IDPSession.max_expires_at > now
                )
            )
        )
        
        idp_session = result.scalar_one_or_none()
        
        if idp_session:
            # Update last seen and idle timeout
            idp_session.last_seen_at = now
            idp_session.idle_expires_at = now + timedelta(seconds=settings.SSO_IDLE_TTL)
            await session.flush()
        
        return idp_session
    
    async def get_session_from_cookie(
        self,
        session: AsyncSession,
        request: Request
    ) -> Optional[IDPSession]:
        """Get session from request cookie"""
        session_cookie = request.cookies.get(self.cookie_name)
        if not session_cookie:
            return None
        
        return await self.get_session(session, session_cookie)
    
    def set_session_cookie(
        self,
        response: Response,
        session_id: str,
        max_age: int | None = None,
    ) -> None:
        response.set_cookie(
            key=self.cookie_name,
            value=session_id,
            domain=self.cookie_domain,
            path="/",
            secure=settings.APP_ENV == "production",
            httponly=True,
            samesite="lax",
            max_age=max_age or settings.SSO_MAX_TTL,
        )
    
    def clear_session_cookie(self, response: Response) -> None:
        """Clear SSO session cookie"""
        response.delete_cookie(
            key=self.cookie_name,
            domain=self.cookie_domain,
            path="/"
        )
    
    async def revoke_session(
        self,
        session: AsyncSession,
        idp_session: IDPSession
    ) -> None:
        """Revoke SSO session"""
        idp_session.revoked_at = datetime.now(timezone.utc)
        await session.flush()
    
    async def revoke_all_user_sessions(
        self,
        session: AsyncSession,
        user_id: str
    ) -> List[IDPSession]:
        """Revoke all sessions for a user"""
        result = await session.execute(
            select(IDPSession).where(
                and_(
                    IDPSession.user_id == user_id,
                    IDPSession.revoked_at.is_(None)
                )
            )
        )
        
        sessions = result.scalars().all()
        now = datetime.now(timezone.utc)
        
        for idp_session in sessions:
            idp_session.revoked_at = now
        
        await session.flush()
        return sessions
    
    async def get_active_user_sessions(
        self,
        session: AsyncSession,
        user_id: str
    ) -> List[IDPSession]:
        """Get all active sessions for a user"""
        now = datetime.now(timezone.utc)
        
        result = await session.execute(
            select(IDPSession).where(
                and_(
                    IDPSession.user_id == user_id,
                    IDPSession.revoked_at.is_(None),
                    IDPSession.max_expires_at > now
                )
            )
        )
        
        return result.scalars().all()


session_service = SessionService()


/* ===== C:\Users\icipa\team-platform-public\id_service\services\token_service.py ===== */

# id_service/services/token_service.py

import secrets
import hashlib
import logging
from datetime import datetime, timezone, timedelta
from typing import Optional, Dict, Any, Tuple

from jose import jwt, JWTError
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_
from sqlalchemy.orm import noload
from cryptography.hazmat.primitives import serialization

from db.session import async_session_maker
from models import AuthCode, RefreshToken, User, Client, JWKKey
from core.config import settings
from core.security import security
from services.jwk_service import jwk_service
from services.backchannel_logout import backchannel_logout_service
from services.session_service import session_service

logger = logging.getLogger(__name__)


def _load_public_key(pem: str):
    """Загрузка публичного ключа из PEM."""
    return serialization.load_pem_public_key(pem.encode("utf-8"))


class TokenService:
    """Service for managing OAuth2/OIDC tokens"""

    async def create_auth_code(
        self,
        session: AsyncSession,
        user: User,
        client: Client,
        redirect_uri: str,
        scope: str,
        state: Optional[str] = None,
        nonce: Optional[str] = None,
        code_challenge: Optional[str] = None,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
    ) -> str:
        """
        Создать одноразовый authorization code с биндингами (PKCE, redirect_uri, scope, nonce, state).
        Храним только sha256 от кода.
        """
        code = secrets.token_urlsafe(32)
        code_hash = hashlib.sha256(code.encode()).hexdigest()
        now = datetime.now(timezone.utc)

        code_challenge_hash = code_challenge
        
        auth_code = AuthCode(
            code_hash=code_hash,
            client_id=client.client_id,
            user_id=user.id,
            redirect_uri=redirect_uri,
            scope=scope,
            code_challenge_hash=code_challenge_hash,
            nonce=nonce,
            state=state,
            auth_time=now,
            expires_at=now + timedelta(seconds=settings.AUTH_CODE_TTL),
            ip_address=ip_address,
            user_agent=user_agent,
        )
        session.add(auth_code)
        await session.flush()
        return code

    async def exchange_auth_code(
        self,
        session: AsyncSession,
        code: str,
        client_id: str,
        redirect_uri: str,
        code_verifier: Optional[str] = None,
    ) -> Tuple[Optional[AuthCode], Optional[str]]:
        """
        Обмен authorization code → проверка срока, one-time, PKCE и биндингов.
        Возвращает найденный AuthCode или ошибку OAuth.
        """
        code_hash = hashlib.sha256(code.encode()).hexdigest()
        now = datetime.now(timezone.utc)

        result = await session.execute(
            select(AuthCode)
            .options(noload("*"))                      # отключаем eager-join всех связей
            .where(
                and_(
                    AuthCode.code_hash == code_hash,
                    AuthCode.client_id == client_id,
                    AuthCode.redirect_uri == redirect_uri,
                    AuthCode.expires_at > now,
                    AuthCode.used_at.is_(None),
                )
            )
            .with_for_update(of=AuthCode)              # блокируем только auth_codes
        )
        auth_code = result.scalar_one_or_none()
        if not auth_code:
            logger.warning("Invalid code exchange. client_id=%s", client_id)
            return None, "invalid_grant"

        # PKCE проверяем, если был челендж
        if auth_code.code_challenge_hash:
            if not code_verifier:
                return None, "invalid_request"
            if not security.verify_code_challenge(code_verifier, auth_code.code_challenge_hash):
                logger.warning("PKCE failed. client_id=%s", client_id)
                return None, "invalid_grant"

        # помечаем код использованным в транзакции
        auth_code.used_at = now
        await session.flush()
        return auth_code, None

    async def create_tokens(
        self,
        session: AsyncSession,
        user: User,
        client: Client,
        scope: str,
        nonce: Optional[str] = None,
        auth_time: Optional[datetime] = None,
        session_id: Optional[str] = None,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
    ) -> Dict[str, Any]:
        """
        Выпуск access/id/refresh токенов.
        RS256 с текущим активным ключом. exp/iat — unix time.
        """
        now = datetime.now(timezone.utc)
        auth_time = auth_time or now
        ts = lambda dt: int(dt.timestamp())
        scopes = set(scope.split())

        # активный JWK
        jwk_key = await jwk_service.get_active_key()
        if not jwk_key:
            raise RuntimeError("No active JWK key available")

        private_key_pem = jwk_service.decrypt_private_key(jwk_key.private_pem_encrypted)

        # jti
        access_jti = secrets.token_urlsafe(16)
        refresh_jti = secrets.token_urlsafe(16)

        # access token
        access_claims = {
            "iss": settings.ISSUER,
            "sub": str(user.id),
            "aud": client.client_id,
            "exp": ts(now + timedelta(seconds=settings.ACCESS_TOKEN_TTL)),
            "iat": ts(now),
            "jti": access_jti,
            "scope": scope,
            "client_id": client.client_id,
        }
        if session_id:
            access_claims["sid"] = session_id

        access_token = jwt.encode(
            access_claims,
            private_key_pem,
            algorithm="RS256",
            headers={"kid": jwk_key.kid},
        )

        # id token при scope openid
        id_token: Optional[str] = None
        if "openid" in scopes:
            id_claims = {
                "iss": settings.ISSUER,
                "sub": str(user.id),
                "aud": client.client_id,
                "exp": ts(now + timedelta(seconds=settings.ACCESS_TOKEN_TTL)),
                "iat": ts(now),
                "auth_time": ts(auth_time),
            }
            if "email" in scopes:
                id_claims["email"] = user.email
                id_claims["email_verified"] = user.email_verified
            if "profile" in scopes:
                id_claims["preferred_username"] = user.username
            if nonce:
                id_claims["nonce"] = nonce
            if session_id:
                id_claims["sid"] = session_id

            # at_hash = left-most 128 bits of SHA-256(access_token), base64url без '='
            at_hash = hashlib.sha256(access_token.encode()).digest()[:16]
            import base64
            id_claims["at_hash"] = base64.urlsafe_b64encode(at_hash).decode().rstrip("=")

            id_token = jwt.encode(
                id_claims,
                private_key_pem,
                algorithm="RS256",
                headers={"kid": jwk_key.kid},
            )


        # refresh при offline_access
        refresh_token: Optional[str] = None
        if "offline_access" in scopes:
            refresh_token_obj = RefreshToken(
                jti=refresh_jti,
                user_id=user.id,
                client_id=client.client_id,
                scope=scope,
                created_at=now,
                expires_at=now + timedelta(seconds=settings.REFRESH_TOKEN_TTL),
                ip_address=ip_address,
                user_agent=user_agent,
            )
            session.add(refresh_token_obj)
            await session.flush()

            refresh_claims = {
                "iss": settings.ISSUER,
                "sub": str(user.id),
                "aud": client.client_id,
                "exp": ts(now + timedelta(seconds=settings.REFRESH_TOKEN_TTL)),
                "iat": ts(now),
                "jti": refresh_jti,
                "scope": scope,
                "token_type": "refresh",
            }
            refresh_token = jwt.encode(
                refresh_claims,
                private_key_pem,
                algorithm="RS256",
                headers={"kid": jwk_key.kid},
            )

        return {
            "access_token": access_token,
            "id_token": id_token,
            "refresh_token": refresh_token,
            "token_type": "Bearer",
            "expires_in": settings.ACCESS_TOKEN_TTL,
            "scope": scope,
        }

    async def rotate_refresh_token(
        self,
        session: AsyncSession,
        refresh_token: str,
        client_id: str,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
    ) -> Tuple[Optional[Dict[str, Any]], Optional[str]]:
        try:
            unverified = jwt.get_unverified_header(refresh_token)
            kid = unverified.get("kid")
            if not kid:
                return None, "invalid_grant"

            # Берём ключ по kid
            result = await session.execute(select(JWKKey).where(JWKKey.kid == kid))
            jwk_key = result.scalar_one_or_none()
            if not jwk_key:
                return None, "invalid_grant"

            # Верифицируем токен
            private_key_pem = jwk_service.decrypt_private_key(jwk_key.private_pem_encrypted)
            claims = jwt.decode(
                refresh_token,
                private_key_pem,  # допустимо, ключ RSA приватный содержит публичную часть
                algorithms=["RS256"],
                audience=client_id,
                issuer=settings.ISSUER,
            )
            if claims.get("token_type") != "refresh":
                return None, "invalid_grant"

            jti = claims.get("jti")
            user_id = claims.get("sub")

            # Лочим запись рефреша
            result = await session.execute(
                select(RefreshToken)
                .where(
                    and_(
                        RefreshToken.jti == jti,
                        RefreshToken.client_id == client_id,
                        RefreshToken.revoked_at.is_(None),
                    )
                )
                .with_for_update()
            )
            refresh_token_obj = result.scalar_one_or_none()

            if not refresh_token_obj:
                # Проверка reuse
                result = await session.execute(select(RefreshToken).where(RefreshToken.jti == jti))
                used_token = result.scalar_one_or_none()
                if used_token:
                    logger.critical("Refresh reuse detected. user_id=%s client_id=%s", user_id, client_id)
                    await self._revoke_token_chain(session, used_token)
                    return None, "invalid_grant"
                return None, "invalid_grant"

            now = datetime.now(timezone.utc)

            # Протух
            if refresh_token_obj.expires_at < now:
                refresh_token_obj.revoked_at = now
                refresh_token_obj.revoked_reason = "expired"
                await session.flush()
                return None, "invalid_grant"

            # Получаем сущности корректно
            user = await session.get(User, user_id)
            # ВАЖНО: Client ищем по client_id, а не по PK
            cres = await session.execute(select(Client).where(Client.client_id == client_id))
            client = cres.scalar_one_or_none()
            if not user or not client:
                return None, "invalid_grant"

            # Жёсткая ротация: старый сразу недействителен
            refresh_token_obj.rotated_at = now
            refresh_token_obj.revoked_at = now
            refresh_token_obj.revoked_reason = "rotated"


            # Выпускаем новую пачку
            new_tokens = await self.create_tokens(
                session=session,
                user=user,
                client=client,
                scope=refresh_token_obj.scope,
                ip_address=ip_address,
                user_agent=user_agent,
            )

            # Связываем цепочку
            if new_tokens.get("refresh_token"):
                try:
                    new_jti = jwt.get_unverified_claims(new_tokens["refresh_token"]).get("jti")
                except Exception:
                    new_jti = None
                res2 = await session.execute(select(RefreshToken).where(RefreshToken.jti == new_jti))
                new_refresh_obj = res2.scalar_one()
                new_refresh_obj.parent_jti = refresh_token_obj.jti
                new_refresh_obj.prev_jti = refresh_token_obj.jti

            await session.flush()
            return new_tokens, None

        except JWTError as e:
            logger.warning("JWT error during refresh: %s", e)
            return None, "invalid_grant"
        except Exception as e:
            logger.error("Error rotating refresh token: %s", e)
            return None, "server_error"

    async def revoke_refresh_token(
        self,
        session: AsyncSession,
        refresh_token: str,
        client_id: str,
        reason: str = "revoked_by_client",
    ) -> None:
        """
        RFC 7009: отзыв refresh токена. Безболезненно возвращает 200 даже если токен невалиден.
        Мы отзывем сам токен и всех его потомков по цепочке parent_jti.
        """
        try:
            # Вычисляем ключ по kid и валидируем токен
            unverified = jwt.get_unverified_header(refresh_token)
            kid = unverified.get("kid")
            if not kid:
                return

            res = await session.execute(select(JWKKey).where(JWKKey.kid == kid))
            jwk_key = res.scalar_one_or_none()
            if not jwk_key:
                return

            private_key_pem = jwk_service.decrypt_private_key(jwk_key.private_pem_encrypted)
            claims = jwt.decode(
                refresh_token,
                private_key_pem,  # валидно: приватный ключ содержит публичную часть
                algorithms=["RS256"],
                audience=client_id,
                issuer=settings.ISSUER,
            )
            jti = claims.get("jti")
            if not jti:
                return

            # Находим сам токен
            result = await session.execute(
                select(RefreshToken)
                .where(
                    and_(
                        RefreshToken.jti == jti,
                        RefreshToken.client_id == client_id,
                    )
                )
                .with_for_update(of=RefreshToken)
            )
            root = result.scalar_one_or_none()
            if not root:
                return

            now = datetime.now(timezone.utc)

            # Собираем всех потомков (широкий поиск по parent_jti)
            to_revoke = [root]
            queue = [root.jti]
            seen = set([root.jti])
            while queue:
                cur = queue.pop(0)
                res = await session.execute(select(RefreshToken).where(RefreshToken.parent_jti == cur))
                children = res.scalars().all()
                for c in children:
                    if c.jti not in seen:
                        seen.add(c.jti)
                        to_revoke.append(c)
                        queue.append(c.jti)

            # Отзываем
            for t in to_revoke:
                if not t.revoked_at:
                    t.revoked_at = now
                    t.revoked_reason = reason

            await session.flush()

        except JWTError:
            return
        except Exception:
            logger.exception("Error during refresh token revocation")
            return


    async def _revoke_token_chain(self, session: AsyncSession, token: RefreshToken) -> None:
        """
        Отозвать всю цепочку refresh при reuse. Плюс SSO и back-channel для соответствующего клиента.
        """
        now = datetime.now(timezone.utc)

        # собираем всю цепочку вверх по parent_jti
        tokens_to_revoke = []
        current = token
        while current.parent_jti:
            result = await session.execute(select(RefreshToken).where(RefreshToken.jti == current.parent_jti))
            parent = result.scalar_one_or_none()
            if parent:
                tokens_to_revoke.append(parent)
                current = parent
            else:
                break

        # и вниз по потомкам
        result = await session.execute(select(RefreshToken).where(RefreshToken.parent_jti == token.jti))
        children = result.scalars().all()
        tokens_to_revoke.extend(children)

        tokens_to_revoke.append(token)
        for t in tokens_to_revoke:
            if not t.revoked_at:
                t.revoked_at = now
                t.revoked_reason = "token_reuse_detected"
        await session.flush()

        # отзывает все IdP-сессии пользователя (пока глобально)
        await session_service.revoke_all_user_sessions(session, token.user_id)

        # back-channel точечно по клиенту токена
        user = await session.get(User, token.user_id)
        try:
            await backchannel_logout_service.initiate_backchannel_logout(
                session=session,
                user=user,
                session_id=None,
                reason="refresh_reuse",
                only_client_id=token.client_id,
            )
        except Exception as e:
            logger.error("Back-channel during revoke chain failed: %s", e)

    async def verify_access_token(
        self,
        token: str,
        required_scope: Optional[str] = None,
    ) -> Optional[Dict[str, Any]]:
        """
        Верификация access: подпись, iss. aud опционально. Проверка требуемого scope.
        """
        try:
            hdr = jwt.get_unverified_header(token)
            kid = hdr.get("kid")
            async with async_session_maker() as s:
                res = await s.execute(select(JWKKey).where(JWKKey.kid == kid))
                jwk_key = res.scalar_one_or_none()
                if not jwk_key:
                    return None
                public_key = _load_public_key(jwk_key.public_pem)
                claims = jwt.decode(
                    token,
                    public_key,
                    algorithms=["RS256"],
                    issuer=settings.ISSUER,
                    options={"verify_aud": False},
                )
            if required_scope and required_scope not in claims.get("scope", "").split():
                return None
            return claims
        except JWTError:
            return None

    async def revoke_all_refresh_tokens_for_user(
        self,
        session: AsyncSession,
        user_id: str,
        client_id: Optional[str] = None,
        reason: str = "user_action",
    ) -> list[str]:
        """
        Отозвать все активные refresh токены пользователя.
        Возвращает список client_id, у которых были активные токены.
        """
        now = datetime.now(timezone.utc)
        q = select(RefreshToken).where(
            and_(
                RefreshToken.user_id == user_id,
                RefreshToken.revoked_at.is_(None),
                RefreshToken.expires_at > now,
            )
        )
        if client_id:
            q = q.where(RefreshToken.client_id == client_id)

        res = await session.execute(q)
        tokens = res.scalars().all()

        affected = set()
        for t in tokens:
            t.revoked_at = now
            t.revoked_reason = reason
            affected.add(t.client_id)

        await session.flush()
        return list(affected)


token_service = TokenService()



/* ===== C:\Users\icipa\team-platform-public\id_service\utils\__init__.py ===== */

# id_service/utils/__init__.py

from .validators import validators
from .rate_limit import rate_limiter
from .otp import otp_service
from .csrf import csrf_protection
from .logging_config import setup_logging

__all__ = [
    "validators",
    "rate_limiter", 
    "otp_service",
    "csrf_protection",
    "setup_logging"
]


/* ===== C:\Users\icipa\team-platform-public\id_service\utils\csrf.py ===== */

# id_service/utils/csrf.py

import hmac
import hashlib
import secrets
from typing import Optional

from fastapi import Request, HTTPException, status


class CSRFProtection:
    """CSRF protection using double-submit cookie pattern"""

    def __init__(self):
        self.cookie_name = "csrf_token"
        self.header_name = "X-CSRF-Token"
        self.form_field = "csrf_token"

    def generate_token(self) -> str:
        """Generate CSRF token"""
        return secrets.token_urlsafe(32)

    async def validate_token(
        self,
        request: Request,
        cookie_token: Optional[str] = None,
        submitted_token: Optional[str] = None,
    ) -> bool:
        """
        Validate CSRF token (double-submit: cookie vs header/form)
        Raises HTTPException(403) if invalid, returns True if valid.
        """

        # 1) token from cookie
        if cookie_token is None:
            cookie_token = request.cookies.get(self.cookie_name)

        if not cookie_token:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN, detail="CSRF cookie not found"
            )

        # 2) token from header (preferred) or form field (fallback)
        if submitted_token is None:
            submitted_token = request.headers.get(self.header_name)

            if not submitted_token and request.method in {"POST", "PUT", "PATCH", "DELETE"}:
                try:
                    form = await request.form()
                    submitted_token = form.get(self.form_field)
                except Exception:
                    submitted_token = None

        if not submitted_token:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN, detail="CSRF token not provided"
            )

        # 3) constant-time compare
        if not hmac.compare_digest(cookie_token, submitted_token):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN, detail="Invalid CSRF token"
            )

        return True

    def should_check_csrf(self, request: Request) -> bool:
        """
        Decide if the current request must pass CSRF check.

        Safe methods are skipped. We explicitly *protect*:
        - /api/auth/**
        - /api/account/**
        - (на всякий случай совместимость с неполным префиксом)
          /auth/** и /account/**
        - /oauth/authorize**   (включая /oauth/authorize/consent)

        Exclusions:
        - /api/auth/csrf (и /auth/csrf)
        - /.well-known/*
        - /oauth/token, /oauth/revoke, а также корневые /token, /revoke
        - /health, /health/ready
        - Любые запросы с Authorization: Bearer*, КРОМЕ явных protected путей.
        """
        method = request.method.upper()
        if method in {"GET", "HEAD", "OPTIONS"}:
            return False

        path = request.url.path

        # --- explicit exclusions ---
        if path in {
            "/api/auth/csrf",
            "/auth/csrf",
            "/.well-known/openid-configuration",
            "/.well-known/jwks.json",
            "/health",
            "/health/ready",
            "/oauth/token",
            "/oauth/revoke",
            "/token",
            "/revoke",
        }:
            return False

        # --- explicit protected areas ---
        is_protected = (
            path.startswith("/api/auth/")
            or path.startswith("/api/account/")
            or path.startswith("/auth/")
            or path.startswith("/account/")
            or path.startswith("/oauth/authorize")  # covers /oauth/authorize/consent
            or path == "/logout"  # POST /logout гасит cookie-сессию — защищаем
        )
        if is_protected:
            return True

        # Bearer requests (API calls with JWT) usually don't need CSRF
        # (keep AFTER explicit protected check so consent stays protected)
        auth_header = request.headers.get("Authorization", "")
        if auth_header.startswith("Bearer "):
            return False

        # default
        return False


csrf_protection = CSRFProtection()



/* ===== C:\Users\icipa\team-platform-public\id_service\utils\email_sender.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\utils\jwt_utils.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\utils\logging_config.py ===== */

# id_service/utils/logging_config.py

import logging
import sys
from typing import Any, Dict
import json
from datetime import datetime

from core.config import settings


class JSONFormatter(logging.Formatter):
    """JSON log formatter for structured logging"""
    
    def format(self, record: logging.LogRecord) -> str:
        log_obj = {
            "timestamp": datetime.utcnow().isoformat(),
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage(),
            "module": record.module,
            "function": record.funcName,
            "line": record.lineno
        }
        
        # Add extra fields
        if hasattr(record, 'user_id'):
            log_obj['user_id'] = record.user_id
        if hasattr(record, 'client_id'):
            log_obj['client_id'] = record.client_id
        if hasattr(record, 'ip_address'):
            log_obj['ip_address'] = record.ip_address
        if hasattr(record, 'trace_id'):
            log_obj['trace_id'] = record.trace_id
        
        # Add exception info if present
        if record.exc_info:
            log_obj['exception'] = self.formatException(record.exc_info)
        
        return json.dumps(log_obj)


def setup_logging():
    """Configure application logging"""
    
    # Set log level based on environment
    log_level = logging.DEBUG if settings.APP_ENV == "development" else logging.INFO
    
    # Create handlers
    console_handler = logging.StreamHandler(sys.stdout)
    
    # Set formatter based on environment
    if settings.APP_ENV == "production":
        formatter = JSONFormatter()
    else:
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
    
    console_handler.setFormatter(formatter)
    
    # Configure root logger
    root_logger = logging.getLogger()
    root_logger.setLevel(log_level)
    root_logger.addHandler(console_handler)
    
    # Silence noisy libraries
    logging.getLogger("uvicorn.access").setLevel(logging.WARNING)
    logging.getLogger("httpx").setLevel(logging.WARNING)
    
    return root_logger


/* ===== C:\Users\icipa\team-platform-public\id_service\utils\otp.py ===== */

# id_service/utils/otp.py

from datetime import datetime, timezone, timedelta
from typing import Optional, Tuple
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_
from sqlalchemy.orm import noload

from models import EmailCode, EmailCodePurpose, User
from core.config import settings
from core.security import security

import logging
logger = logging.getLogger(__name__)


class OTPService:
    """Service for managing OTP codes"""
    
    async def create_otp(
        self,
        session: AsyncSession,
        user: User,
        purpose: EmailCodePurpose,
        new_email: Optional[str] = None,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None
    ) -> Tuple[str, EmailCode]:
        """Create new OTP code"""
        
        # Check for existing active code
        now = datetime.now(timezone.utc)
        result = await session.execute(
            select(EmailCode).where(
                and_(
                    EmailCode.user_id == user.id,
                    EmailCode.purpose == purpose,
                    EmailCode.expires_at > now,
                    EmailCode.used_at.is_(None)
                )
            )
        )
        existing_code = result.scalar_one_or_none()
        
        if existing_code:
            # Check resend cooldown
            if existing_code.resend_after > now:
                seconds_left = int((existing_code.resend_after - now).total_seconds())
                raise ValueError(f"Please wait {seconds_left} seconds before requesting a new code")
            
            # Invalidate old code
            existing_code.used_at = now
        
        # Generate new OTP
        otp = security.generate_otp(4)
        otp_hash = security.hash_otp(otp)
        
        # Create email code record
        email_code = EmailCode(
            user_id=user.id,
            purpose=purpose,
            code_hash=otp_hash,
            new_email=new_email,
            expires_at=now + timedelta(seconds=settings.OTP_TTL),
            resend_after=now + timedelta(seconds=settings.OTP_RESEND_SECONDS),
            attempts=0,
            ip_address=ip_address,
            user_agent=user_agent
        )
        
        session.add(email_code)
        await session.flush()
        
        logger.info(f"Created OTP for user {user.id} with purpose {purpose}")
        return otp, email_code
    
    async def verify_otp(
        self,
        session: AsyncSession,
        user_id: str,
        code: str,
        purpose: EmailCodePurpose
    ) -> Tuple[bool, Optional[EmailCode], Optional[str]]:
        """
        Verify OTP code
        
        Returns:
            Tuple of (success, email_code if valid, error_message if invalid)
        """
        now = datetime.now(timezone.utc)
        
        # Find active code
        stmt = (
            select(EmailCode)
            .options(noload(EmailCode.user))  # опционально: уберёт LEFT OUTER JOIN
            .where(
                and_(
                    EmailCode.user_id == user_id,
                    EmailCode.purpose == purpose,
                    EmailCode.expires_at > now,
                    EmailCode.used_at.is_(None),
                )
            )
            .order_by(EmailCode.expires_at.desc())
            .with_for_update(of=[EmailCode])
        )
        result = await session.execute(stmt)
        email_code = result.scalar_one_or_none()
        
        if not email_code:
            return False, None, "No valid code found"
        
        # Check attempts
        email_code.attempts += 1
        
        if email_code.attempts > settings.OTP_MAX_ATTEMPTS:
            email_code.used_at = now  # Invalidate code
            await session.flush()
            return False, None, "Too many attempts. Please request a new code"
        
        # Verify code with constant time comparison
        code_hash = security.hash_otp(code)
        if not security.constant_time_compare(code_hash, email_code.code_hash):
            await session.flush()
            attempts_left = settings.OTP_MAX_ATTEMPTS - email_code.attempts
            return False, None, f"Invalid code. {attempts_left} attempts remaining"
        
        # Mark as used
        email_code.used_at = now
        await session.flush()
        
        logger.info(f"Successfully verified OTP for user {user_id} with purpose {purpose}")
        return True, email_code, None
    
    async def cleanup_expired_codes(
        self,
        session: AsyncSession
    ) -> int:
        """Clean up expired OTP codes (for maintenance)"""
        cutoff_date = datetime.now(timezone.utc) - timedelta(days=1)
        
        result = await session.execute(
            select(EmailCode).where(
                EmailCode.expires_at < cutoff_date
            )
        )
        expired_codes = result.scalars().all()
        
        for code in expired_codes:
            session.delete(code)
        
        await session.flush()
        
        count = len(expired_codes)
        if count > 0:
            logger.info(f"Cleaned up {count} expired OTP codes")
        
        return count


otp_service = OTPService()


/* ===== C:\Users\icipa\team-platform-public\id_service\utils\pkce.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\utils\rate_limit.py ===== */

# id_service/utils/rate_limit.py

import hashlib
import logging
from typing import Optional
from fastapi import Request, HTTPException, status
import redis.asyncio as redis
from datetime import timedelta

from core.config import settings

logger = logging.getLogger(__name__)


class RateLimiter:
    """Rate limiting implementation using Redis"""
    
    def __init__(self):
        self.redis_client: Optional[redis.Redis] = None
        self.enabled = settings.RATE_LIMIT_ENABLED
        
    async def init(self):
        """Initialize Redis connection"""
        if self.enabled:
            try:
                self.redis_client = redis.from_url(
                    settings.REDIS_URL,
                    encoding="utf-8",
                    decode_responses=True
                )
                await self.redis_client.ping()
                logger.info("Rate limiter initialized")
            except Exception as e:
                logger.error(f"Failed to initialize rate limiter: {e}")
                self.enabled = False
    
    async def close(self):
        """Close Redis connection"""
        if self.redis_client:
            await self.redis_client.close()
    
    def _get_key(self, request: Request, action: str) -> str:
        """Generate rate limit key"""
        client_ip = request.client.host
        # Include action in key for different limits per action
        raw_key = f"rate_limit:{action}:{client_ip}"
        # Hash for privacy
        return hashlib.sha256(raw_key.encode()).hexdigest()
    
    async def check_rate_limit(
        self,
        request: Request,
        action: str = "general",
        max_requests: Optional[int] = None,
        window_seconds: int = 60
    ) -> bool:
        """
        Check if request should be rate limited
        
        Args:
            request: FastAPI request
            action: Action identifier (login, register, etc.)
            max_requests: Maximum requests allowed
            window_seconds: Time window in seconds
            
        Returns:
            True if request is allowed, raises HTTPException if limited
        """
        if not self.enabled or not self.redis_client:
            return True
        
        max_requests = max_requests or settings.RATE_LIMIT_REQUESTS_PER_MINUTE
        key = self._get_key(request, action)
        
        try:
            # Use Redis pipeline for atomic operations
            async with self.redis_client.pipeline() as pipe:
                # Get current count
                current_count = await self.redis_client.get(key)
                
                if current_count is None:
                    # First request, set key with expiry
                    await pipe.setex(key, window_seconds, 1)
                    await pipe.execute()
                    return True
                
                current_count = int(current_count)
                
                if current_count >= max_requests:
                    # Rate limit exceeded
                    ttl = await self.redis_client.ttl(key)
                    raise HTTPException(
                        status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                        detail=f"Rate limit exceeded. Try again in {ttl} seconds.",
                        headers={"Retry-After": str(ttl)}
                    )
                
                # Increment counter
                await self.redis_client.incr(key)
                return True
                
        except HTTPException:
            raise
        except Exception as e:
            logger.error(f"Rate limit check failed: {e}")
            # Fail open - allow request if rate limiting fails
            return True
    
    async def add_failed_attempt(
        self,
        identifier: str,
        action: str = "login",
        max_attempts: int = 5,
        lockout_seconds: int = 900  # 15 minutes
    ) -> None:
        """
        Track failed attempts for an identifier (email, username, etc.)
        
        Args:
            identifier: Unique identifier to track
            action: Type of action (login, otp_verify, etc.)
            max_attempts: Maximum attempts before lockout
            lockout_seconds: Lockout duration in seconds
        """
        if not self.enabled or not self.redis_client:
            return
        
        key = f"failed_attempts:{action}:{hashlib.sha256(identifier.encode()).hexdigest()}"
        lockout_key = f"{key}:locked"
        
        try:
            # Check if already locked out
            is_locked = await self.redis_client.get(lockout_key)
            if is_locked:
                ttl = await self.redis_client.ttl(lockout_key)
                raise HTTPException(
                    status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                    detail=f"Account temporarily locked. Try again in {ttl} seconds.",
                    headers={"Retry-After": str(ttl)}
                )
            
            # Increment failed attempts
            attempts = await self.redis_client.incr(key)
            
            # Set expiry on first attempt
            if attempts == 1:
                await self.redis_client.expire(key, lockout_seconds)
            
            # Check if should lock out
            if attempts >= max_attempts:
                await self.redis_client.setex(lockout_key, lockout_seconds, "1")
                await self.redis_client.delete(key)
                
                raise HTTPException(
                    status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                    detail=f"Too many failed attempts. Account locked for {lockout_seconds // 60} minutes.",
                    headers={"Retry-After": str(lockout_seconds)}
                )
                
        except HTTPException:
            raise
        except Exception as e:
            logger.error(f"Failed to track failed attempt: {e}")
    
    async def clear_failed_attempts(
        self,
        identifier: str,
        action: str = "login"
    ) -> None:
        """Clear failed attempts for an identifier after successful action"""
        if not self.enabled or not self.redis_client:
            return
        
        key = f"failed_attempts:{action}:{hashlib.sha256(identifier.encode()).hexdigest()}"
        lockout_key = f"{key}:locked"
        
        try:
            await self.redis_client.delete(key, lockout_key)
        except Exception as e:
            logger.error(f"Failed to clear failed attempts: {e}")


# Global instance
rate_limiter = RateLimiter()


/* ===== C:\Users\icipa\team-platform-public\id_service\utils\validators.py ===== */

# id_service/utils/validators.py

import re
import secrets
import string
from typing import Optional, Tuple, List
from email_validator import validate_email, EmailNotValidError
from urllib.parse import urlparse

from core.config import settings


class Validators:
    """Input validation utilities"""
    
    @staticmethod
    def validate_email(email: str) -> Tuple[bool, Optional[str]]:
        """Validate email address"""
        try:
            # Validate and normalize
            validation = validate_email(email)
            return True, validation.email.lower()
        except EmailNotValidError as e:
            return False, str(e)
    
    @staticmethod
    def validate_username(username: str) -> Tuple[bool, str]:
        """
        Validate username
        - 3-30 characters
        - Alphanumeric, underscore, hyphen
        - Must start with letter
        """
        if not username:
            return False, "Username is required"
        
        if len(username) < 3:
            return False, "Username must be at least 3 characters"
        
        if len(username) > 30:
            return False, "Username must be at most 30 characters"
        
        if not username[0].isalpha():
            return False, "Username must start with a letter"
        
        if not re.match(r'^[a-zA-Z][a-zA-Z0-9_-]*$', username):
            return False, "Username can only contain letters, numbers, underscore and hyphen"
        
        # Check for reserved usernames
        reserved = ['admin', 'root', 'api', 'oauth', 'oidc', 'auth', 'account', 'id', 'login', 'register']
        if username.lower() in reserved:
            return False, "This username is reserved"
        
        return True, ""
    
    @staticmethod
    def validate_redirect_uri(uri: str, allowed_uris: List[str]) -> bool:
        """
        Validate redirect URI against whitelist
        Exact match required for security
        """
        if not uri or not allowed_uris:
            return False
        
        # Exact match required
        return uri in allowed_uris
    
    @staticmethod
    def validate_scope(scope: str) -> Tuple[bool, str]:
        """Validate OAuth2 scope"""
        if not scope:
            return False, "Scope is required"
        
        allowed_scopes = ["openid", "email", "profile", "offline_access"]
        requested_scopes = scope.split()
        
        for s in requested_scopes:
            if s not in allowed_scopes:
                return False, f"Invalid scope: {s}"
        
        return True, ""
    
    @staticmethod
    def validate_pkce_verifier(verifier: str) -> Tuple[bool, str]:
        """
        Validate PKCE code verifier
        - 43-128 characters
        - URL-safe characters only
        """
        if not verifier:
            return False, "Code verifier is required"
        
        if len(verifier) < 43:
            return False, "Code verifier too short (min 43 characters)"
        
        if len(verifier) > 128:
            return False, "Code verifier too long (max 128 characters)"
        
        # Check characters (RFC 7636)
        allowed = string.ascii_letters + string.digits + '-._~'
        if not all(c in allowed for c in verifier):
            return False, "Code verifier contains invalid characters"
        
        return True, ""
    
    @staticmethod
    def validate_state(state: str) -> Tuple[bool, str]:
        """Validate OAuth2 state parameter"""
        if not state:
            return True, ""  # State is optional
        
        if len(state) > 500:
            return False, "State parameter too long"
        
        # Check for potentially malicious content
        if '<' in state or '>' in state or 'javascript:' in state.lower():
            return False, "Invalid state parameter"
        
        return True, ""
    
    @staticmethod
    def validate_nonce(nonce: str) -> Tuple[bool, str]:
        """Validate OIDC nonce parameter"""
        if not nonce:
            return True, ""  # Nonce is optional
        
        if len(nonce) > 255:
            return False, "Nonce too long"
        
        # Should be unguessable
        if len(nonce) < 8:
            return False, "Nonce too short for security"
        
        return True, ""
    
    @staticmethod
    def sanitize_user_agent(user_agent: Optional[str]) -> str:
        """Sanitize user agent string for storage"""
        if not user_agent:
            return ""
        
        # Truncate if too long
        if len(user_agent) > 500:
            user_agent = user_agent[:500]
        
        # Remove any control characters
        return ''.join(c for c in user_agent if c.isprintable())
    
    @staticmethod
    def is_safe_url(url: str, allowed_hosts: Optional[List[str]] = None) -> bool:
        """Check if URL is safe for redirect"""
        if not url:
            return False
        
        try:
            parsed = urlparse(url)
            
            # Reject URLs with potentially dangerous schemes
            if parsed.scheme and parsed.scheme not in ['http', 'https']:
                return False
            
            # If no host specified, it's a relative URL (safe)
            if not parsed.netloc:
                return True
            
            # Check against allowed hosts if provided
            if allowed_hosts:
                return parsed.netloc in allowed_hosts
            
            return True
            
        except Exception:
            return False


validators = Validators()
