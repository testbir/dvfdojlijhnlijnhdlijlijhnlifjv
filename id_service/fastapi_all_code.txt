

/* ===== C:\Users\icipa\team-platform-public\id_service\.env ===== */

# id_service/.env

# Application
APP_NAME=ID Service
APP_ENV=development
ISSUER=http://localhost:8000
CORS_ORIGINS=["http://localhost:3000","http://localhost:3001","http://localhost:5174","http://localhost:8001","http://localhost:8002","http://localhost:8003","http://localhost:8010"]

# Database - РёСЃРїРѕР»СЊР·СѓРµРј СЃСѓС‰РµСЃС‚РІСѓСЋС‰СѓСЋ Р‘Р” РёР· docker-compose
DATABASE_URL=postgresql+asyncpg://postgres:siperup44rQVr8@postgres_team:5432/team_platform_id
DB_ECHO=false

# Redis - РёСЃРїРѕР»СЊР·СѓРµРј СЃСѓС‰РµСЃС‚РІСѓСЋС‰РёР№ Redis
REDIS_URL=redis://redis:6379/1

# Security
SECRET_KEY=dev-secret-key-pepTkzpoJ20y6gM6EsGVoQe8rFa9OO6PJnnViahsC_RN2W8Cszqe0CmYHIScj8Wd6Q
PEPPER_SECRET=dev-pepper-secret-Jn2W8Cszqe0CmYHIScj8Wd6Q
COOKIE_SECRET=dev-cookie-secret-aB3dE5fG7hI9jK1lM3nO5pQ7
JWT_PRIVATE_KEY_PASSWORD=dev-jwt-password-xY9zA1bC3dE5fG7h

# Token TTL (seconds)
ACCESS_TOKEN_TTL=600
REFRESH_TOKEN_TTL=2592000
AUTH_CODE_TTL=600
SSO_IDLE_TTL=1800
SSO_MAX_TTL=86400

# OTP Settings
OTP_TTL=300
OTP_RESEND_SECONDS=60
OTP_MAX_ATTEMPTS=5

# Email - РёСЃРїРѕР»СЊР·СѓРµРј РІР°С€ Gmail
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=asyncteach.auth@gmail.com
SMTP_PASSWORD=hbhwgatkxikpxaqm
SMTP_TLS=true
EMAIL_FROM=Asynq ID <asyncteach.auth@gmail.com>

# Rate Limiting
RATE_LIMIT_ENABLED=true
RATE_LIMIT_REQUESTS_PER_MINUTE=60

# Password Policy
PASSWORD_MIN_LENGTH=8
PASSWORD_REQUIRE_UPPERCASE=true
PASSWORD_REQUIRE_LOWERCASE=true
PASSWORD_REQUIRE_DIGIT=true
PASSWORD_REQUIRE_SPECIAL=false

# Local development clients - РґР»СЏ РёРЅС‚РµРіСЂР°С†РёРё СЃ РґСЂСѓРіРёРјРё СЃРµСЂРІРёСЃР°РјРё
TEACH_CLIENT_ID=teach-service
RUN_CLIENT_ID=run-service
LEARN_CLIENT_ID=learn-service
CATALOG_CLIENT_ID=catalog-service
ADMIN_CLIENT_ID=admin-service


/* ===== C:\Users\icipa\team-platform-public\id_service\alembic.ini ===== */

# A generic, single database configuration.

[alembic]
# path to migration scripts
script_location = alembic

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
# Uncomment the line below if you want the files to be prepended with date and time
file_template = %%(year)d%%(month).2d%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.
prepend_sys_path = .

# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the python-dateutil library
# one of: postgresql, mysql, sqlite, mssql
# leave blank for auto-detection
sqlalchemy.url = postgresql://postgres:password@localhost/id_service

# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S


/* ===== C:\Users\icipa\team-platform-public\id_service\alembic\env.py ===== */

# id_service/alembic/env.py
from __future__ import annotations

import asyncio
from logging.config import fileConfig

from alembic import context
from sqlalchemy import pool
from sqlalchemy.engine import Connection
from sqlalchemy.ext.asyncio import AsyncEngine, create_async_engine

from core.config import settings
from db.base import Base

config = context.config
if config.config_file_name:
    fileConfig(config.config_file_name)

target_metadata = Base.metadata

def run_migrations_offline() -> None:
    url = settings.DATABASE_URL.replace("+asyncpg", "")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
        compare_type=True,
        compare_server_default=True,
        version_table="alembic_version",
    )
    with context.begin_transaction():
        context.run_migrations()

def do_run_migrations(connection: Connection) -> None:
    context.configure(
        connection=connection,
        target_metadata=target_metadata,
        compare_type=True,
        compare_server_default=True,
        version_table="alembic_version",
    )
    with context.begin_transaction():
        context.run_migrations()

async def run_migrations_online() -> None:
    engine: AsyncEngine = create_async_engine(
        settings.DATABASE_URL,
        poolclass=pool.NullPool,
        future=True,
    )
    async with engine.connect() as conn:
        await conn.run_sync(do_run_migrations)
    await engine.dispose()

if context.is_offline_mode():
    run_migrations_offline()
else:
    asyncio.run(run_migrations_online())



/* ===== C:\Users\icipa\team-platform-public\id_service\alembic\versions\20250101_000000_initial.py ===== */

# id_service/alembic/versions/20250101_000000_initial.py

"""initial

Revision ID: 0001_initial
Revises:
Create Date: 2025-01-01 00:00:00
"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql as psql

# revision identifiers, used by Alembic.
revision = "0001_initial"
down_revision = None
branch_labels = None
depends_on = None


def upgrade() -> None:
    # --- ENUM types: СЃРѕР·РґР°С‘Рј РѕРґРёРЅ СЂР°Р· РІСЂСѓС‡РЅСѓСЋ Рё РїРµСЂРµРёСЃРїРѕР»СЊР·СѓРµРј ---
   
    client_type = psql.ENUM("public", "confidential", name="clienttype", create_type=False)
    token_auth_method = psql.ENUM("none", "client_secret_post", "client_secret_basic", name="tokenauthmethod", create_type=False)
    
    email_code_purpose = psql.ENUM(
        "register", "reset", "change_email",
        name="emailcodepurpose",
        create_type=False,
    )

    bind = op.get_bind()
    client_type.create(bind, checkfirst=True)
    token_auth_method.create(bind, checkfirst=True)
    email_code_purpose.create(bind, checkfirst=True)

    # --- users ---
    op.create_table(
        "users",
        sa.Column("id", psql.UUID(as_uuid=True), primary_key=True, nullable=False),
        sa.Column("email", sa.String(length=255), nullable=False),
        sa.Column("username", sa.String(length=50), nullable=False),
        sa.Column("password_hash", sa.Text(), nullable=False),
        sa.Column("email_verified", sa.Boolean(), nullable=False, server_default=sa.text("false")),
        sa.Column("failed_login_attempts", sa.Integer(), nullable=False, server_default=sa.text("0")),
        sa.Column("last_login_at", sa.DateTime(timezone=True), nullable=True),
        sa.Column("last_password_change_at", sa.DateTime(timezone=True), nullable=True),
        sa.Column("created_at", sa.DateTime(timezone=True), nullable=False, server_default=sa.text("now()")),
        sa.Column("updated_at", sa.DateTime(timezone=True), nullable=False, server_default=sa.text("now()")),
        sa.Column("deleted_at", sa.DateTime(timezone=True), nullable=True),
    )
    op.create_index("ux_users_email_lower", "users", [sa.text("lower(email)")], unique=True)
    op.create_index("ux_users_username", "users", ["username"], unique=True)

    # --- clients ---
    op.create_table(
        "clients",
        sa.Column("id", psql.UUID(as_uuid=True), primary_key=True, nullable=False),
        sa.Column("client_id", sa.String(length=255), nullable=False),
        sa.Column("name", sa.String(length=255), nullable=False),
        sa.Column("type", client_type, nullable=False, server_default=sa.text("'public'::clienttype")),
        sa.Column("token_endpoint_auth_method", token_auth_method, nullable=False, server_default=sa.text("'none'::tokenauthmethod")),
        sa.Column("pkce_required", sa.Boolean(), nullable=False, server_default=sa.text("true")),
        sa.Column("redirect_uris", psql.JSONB(astext_type=sa.Text()), nullable=False, server_default=sa.text("'[]'::jsonb")),
        sa.Column("post_logout_redirect_uris", psql.JSONB(astext_type=sa.Text()), nullable=False, server_default=sa.text("'[]'::jsonb")),
        sa.Column("backchannel_logout_uri", sa.Text(), nullable=True),
        sa.Column("frontchannel_logout_uri", sa.Text(), nullable=True),
        sa.Column("scopes", psql.JSONB(astext_type=sa.Text()), nullable=False, server_default=sa.text("'[\"openid\",\"email\",\"profile\"]'::jsonb")),
        sa.Column("client_secret_hash", sa.Text(), nullable=True),
        sa.Column("secret_rotated_at", sa.DateTime(timezone=True), nullable=True),
        sa.Column("created_at", sa.DateTime(timezone=True), nullable=False, server_default=sa.text("now()")),
        sa.Column("updated_at", sa.DateTime(timezone=True), nullable=False, server_default=sa.text("now()")),
        sa.UniqueConstraint("client_id", name="ux_clients_client_id"),
    )

    # --- jwk_keys ---
    op.create_table(
        "jwk_keys",
        sa.Column("id", psql.UUID(as_uuid=True), primary_key=True, nullable=False),
        sa.Column("kid", sa.String(length=255), nullable=False),
        sa.Column("alg", sa.String(length=10), nullable=False, server_default="RS256"),
        sa.Column("public_pem", sa.Text(), nullable=False),
        sa.Column("private_pem_encrypted", sa.Text(), nullable=False),
        sa.Column("active", sa.Boolean(), nullable=False, server_default=sa.text("true")),
        sa.Column("created_at", sa.DateTime(timezone=True), nullable=False, server_default=sa.text("now()")),
        sa.Column("rotated_at", sa.DateTime(timezone=True), nullable=True),
        sa.Column("expires_at", sa.DateTime(timezone=True), nullable=True),
    )
    op.create_index("ix_jwk_keys_active_kid", "jwk_keys", ["active", "kid"])
    op.create_index(op.f("ix_jwk_keys_kid"), "jwk_keys", ["kid"], unique=True)

    # --- auth_codes ---
    op.create_table(
        "auth_codes",
        sa.Column("id", psql.UUID(as_uuid=True), primary_key=True, nullable=False),
        sa.Column("code_hash", sa.String(length=255), nullable=False),
        sa.Column("client_id", sa.String(length=255), sa.ForeignKey("clients.client_id"), nullable=False),
        sa.Column("user_id", psql.UUID(as_uuid=True), sa.ForeignKey("users.id"), nullable=False),
        sa.Column("redirect_uri", sa.Text(), nullable=False),
        sa.Column("scope", sa.String(length=500), nullable=False),
        sa.Column("code_challenge_hash", sa.String(length=255), nullable=True),
        sa.Column("nonce", sa.String(length=255), nullable=True),
        sa.Column("state", sa.String(length=500), nullable=True),
        sa.Column("auth_time", sa.DateTime(timezone=True), nullable=False),
        sa.Column("expires_at", sa.DateTime(timezone=True), nullable=False),
        sa.Column("used_at", sa.DateTime(timezone=True), nullable=True),
        sa.Column("ip_address", sa.String(length=45), nullable=True),
        sa.Column("user_agent", sa.Text(), nullable=True),
        sa.UniqueConstraint("code_hash"),
    )
    op.create_index(op.f("ix_auth_codes_code_hash"), "auth_codes", ["code_hash"])
    op.create_index(op.f("ix_auth_codes_expires_at"), "auth_codes", ["expires_at"])

    # --- email_codes ---
    op.create_table(
        "email_codes",
        sa.Column("id", psql.UUID(as_uuid=True), primary_key=True, nullable=False),
        sa.Column("user_id", psql.UUID(as_uuid=True), sa.ForeignKey("users.id"), nullable=False),
        sa.Column("purpose", email_code_purpose, nullable=False),
        sa.Column("code_hash", sa.String(length=255), nullable=False),
        sa.Column("new_email", sa.String(length=255), nullable=True),
        sa.Column("expires_at", sa.DateTime(timezone=True), nullable=False),
        sa.Column("attempts", sa.Integer(), nullable=False, server_default=sa.text("0")),
        sa.Column("resend_after", sa.DateTime(timezone=True), nullable=False),
        sa.Column("used_at", sa.DateTime(timezone=True), nullable=True),
        sa.Column("ip_address", sa.String(length=45), nullable=True),
        sa.Column("user_agent", sa.Text(), nullable=True),
    )
    op.create_index("ix_email_codes_user_purpose", "email_codes", ["user_id", "purpose", "expires_at"])

    # --- refresh_tokens ---
    op.create_table(
        "refresh_tokens",
        sa.Column("id", psql.UUID(as_uuid=True), primary_key=True, nullable=False),
        sa.Column("jti", sa.String(length=255), nullable=False),
        sa.Column("user_id", psql.UUID(as_uuid=True), sa.ForeignKey("users.id"), nullable=False),
        sa.Column("client_id", sa.String(length=255), sa.ForeignKey("clients.client_id"), nullable=False),
        sa.Column("parent_jti", sa.String(length=255), nullable=True),
        sa.Column("prev_jti", sa.String(length=255), nullable=True),
        sa.Column("scope", sa.String(length=500), nullable=False),
        sa.Column("created_at", sa.DateTime(timezone=True), nullable=False),
        sa.Column("expires_at", sa.DateTime(timezone=True), nullable=False),
        sa.Column("rotated_at", sa.DateTime(timezone=True), nullable=True),
        sa.Column("revoked_at", sa.DateTime(timezone=True), nullable=True),
        sa.Column("revoked_reason", sa.String(length=255), nullable=True),
        sa.Column("ip_address", sa.String(length=45), nullable=True),
        sa.Column("user_agent", sa.Text(), nullable=True),
        sa.UniqueConstraint("jti"),
    )
    op.create_index("ix_refresh_tokens_user_client", "refresh_tokens", ["user_id", "client_id", "revoked_at", "expires_at"])
    op.create_index(op.f("ix_refresh_tokens_parent_jti"), "refresh_tokens", ["parent_jti"])
    op.create_index(op.f("ix_refresh_tokens_expires_at"), "refresh_tokens", ["expires_at"])
    op.create_index(op.f("ix_refresh_tokens_jti"), "refresh_tokens", ["jti"], unique=True)

    # --- idp_sessions ---
    op.create_table(
        "idp_sessions",
        sa.Column("id", psql.UUID(as_uuid=True), primary_key=True, nullable=False),
        sa.Column("session_id", sa.String(length=255), nullable=False),
        sa.Column("user_id", psql.UUID(as_uuid=True), sa.ForeignKey("users.id"), nullable=False),
        sa.Column("last_seen_at", sa.DateTime(timezone=True), nullable=False),
        sa.Column("idle_expires_at", sa.DateTime(timezone=True), nullable=False),
        sa.Column("max_expires_at", sa.DateTime(timezone=True), nullable=False),
        sa.Column("ip_address", sa.String(length=45), nullable=True),
        sa.Column("user_agent", sa.Text(), nullable=True),
        sa.Column("created_at", sa.DateTime(timezone=True), nullable=False),
        sa.Column("revoked_at", sa.DateTime(timezone=True), nullable=True),
        sa.UniqueConstraint("session_id"),
    )
    op.create_index("ix_idp_sessions_user_revoked", "idp_sessions", ["user_id", "revoked_at"])
    op.create_index(op.f("ix_idp_sessions_idle_expires_at"), "idp_sessions", ["idle_expires_at"])
    op.create_index(op.f("ix_idp_sessions_max_expires_at"), "idp_sessions", ["max_expires_at"])
    op.create_index(op.f("ix_idp_sessions_session_id"), "idp_sessions", ["session_id"], unique=True)


def downgrade() -> None:
    op.drop_table("idp_sessions")
    op.drop_table("refresh_tokens")
    op.drop_table("email_codes")
    op.drop_table("auth_codes")
    op.drop_index("ix_jwk_keys_active_kid", table_name="jwk_keys")
    op.drop_index(op.f("ix_jwk_keys_kid"), table_name="jwk_keys")
    op.drop_table("jwk_keys")
    op.drop_table("clients")
    op.drop_index("ux_users_email_lower", table_name="users")
    op.drop_index("ux_users_username", table_name="users")
    op.drop_table("users")

    # enums (РґСЂРѕРїР°РµРј РІ РєРѕРЅС†Рµ)
    bind = op.get_bind()
    psql.ENUM(name="emailcodepurpose").drop(bind, checkfirst=True)
    psql.ENUM(name="tokenauthmethod").drop(bind, checkfirst=True)
    psql.ENUM(name="clienttype").drop(bind, checkfirst=True)



/* ===== C:\Users\icipa\team-platform-public\id_service\alembic\versions\20250822_1640-624ce4ceb2ee_rename_enum_values_to_lowercase_fix_.py ===== */

"""rename enum values to lowercase & fix defaults

Revision ID: 624ce4ceb2ee
Revises: f94c88b39bdb
Create Date: 2025-08-22 16:40:42.534939

"""

# id_service/alembic/versions/20250822_1640-624ce4ceb2ee_rename_enum_values_to_lowercase_fix_.py
from alembic import op
import sqlalchemy as sa

revision = "624ce4ceb2ee"
down_revision = "f94c88b39bdb"
branch_labels = None
depends_on = None

def upgrade() -> None:
    # СѓР±СЂР°С‚СЊ РґРµС„РѕР»С‚С‹ РЅР° РІСЂРµРјСЏ РёР·РјРµРЅРµРЅРёСЏ enum
    op.alter_column("clients", "type", server_default=None)
    op.alter_column("clients", "token_endpoint_auth_method", server_default=None)

    # clienttype
    op.execute("""
    DO $$
    BEGIN
      IF EXISTS (
        SELECT 1 FROM pg_type t
        JOIN pg_enum e ON e.enumtypid = t.oid
        WHERE t.typname = 'clienttype' AND e.enumlabel = 'PUBLIC'
      ) THEN
        ALTER TYPE clienttype RENAME VALUE 'PUBLIC' TO 'public';
      END IF;

      IF EXISTS (
        SELECT 1 FROM pg_type t
        JOIN pg_enum e ON e.enumtypid = t.oid
        WHERE t.typname = 'clienttype' AND e.enumlabel = 'CONFIDENTIAL'
      ) THEN
        ALTER TYPE clienttype RENAME VALUE 'CONFIDENTIAL' TO 'confidential';
      END IF;
    END$$;
    """)

    # tokenauthmethod
    op.execute("""
    DO $$
    BEGIN
      IF EXISTS (
        SELECT 1 FROM pg_type t
        JOIN pg_enum e ON e.enumtypid = t.oid
        WHERE t.typname = 'tokenauthmethod' AND e.enumlabel = 'NONE'
      ) THEN
        ALTER TYPE tokenauthmethod RENAME VALUE 'NONE' TO 'none';
      END IF;

      IF EXISTS (
        SELECT 1 FROM pg_type t
        JOIN pg_enum e ON e.enumtypid = t.oid
        WHERE t.typname = 'tokenauthmethod' AND e.enumlabel = 'CLIENT_SECRET_POST'
      ) THEN
        ALTER TYPE tokenauthmethod RENAME VALUE 'CLIENT_SECRET_POST' TO 'client_secret_post';
      END IF;

      IF EXISTS (
        SELECT 1 FROM pg_type t
        JOIN pg_enum e ON e.enumtypid = t.oid
        WHERE t.typname = 'tokenauthmethod' AND e.enumlabel = 'CLIENT_SECRET_BASIC'
      ) THEN
        ALTER TYPE tokenauthmethod RENAME VALUE 'CLIENT_SECRET_BASIC' TO 'client_secret_basic';
      END IF;
    END$$;
    """)

    # РІРµСЂРЅСѓС‚СЊ РґРµС„РѕР»С‚С‹ РІ РЅРёР¶РЅРµРј СЂРµРіРёСЃС‚СЂРµ
    op.alter_column("clients", "type", server_default=sa.text("'public'::clienttype"))
    op.alter_column(
        "clients",
        "token_endpoint_auth_method",
        server_default=sa.text("'none'::tokenauthmethod"),
    )

def downgrade() -> None:
    op.alter_column("clients", "type", server_default=None)
    op.alter_column("clients", "token_endpoint_auth_method", server_default=None)

    op.execute("""
    DO $$
    BEGIN
      IF EXISTS (
        SELECT 1 FROM pg_type t
        JOIN pg_enum e ON e.enumtypid = t.oid
        WHERE t.typname = 'clienttype' AND e.enumlabel = 'public'
      ) THEN
        ALTER TYPE clienttype RENAME VALUE 'public' TO 'PUBLIC';
      END IF;

      IF EXISTS (
        SELECT 1 FROM pg_type t
        JOIN pg_enum e ON e.enumtypid = t.oid
        WHERE t.typname = 'clienttype' AND e.enumlabel = 'confidential'
      ) THEN
        ALTER TYPE clienttype RENAME VALUE 'confidential' TO 'CONFIDENTIAL';
      END IF;
    END$$;
    """)

    op.execute("""
    DO $$
    BEGIN
      IF EXISTS (
        SELECT 1 FROM pg_type t
        JOIN pg_enum e ON e.enumtypid = t.oid
        WHERE t.typname = 'tokenauthmethod' AND e.enumlabel = 'none'
      ) THEN
        ALTER TYPE tokenauthmethod RENAME VALUE 'none' TO 'NONE';
      END IF;

      IF EXISTS (
        SELECT 1 FROM pg_type t
        JOIN pg_enum e ON e.enumtypid = t.oid
        WHERE t.typname = 'tokenauthmethod' AND e.enumlabel = 'client_secret_post'
      ) THEN
        ALTER TYPE tokenauthmethod RENAME VALUE 'client_secret_post' TO 'CLIENT_SECRET_POST';
      END IF;

      IF EXISTS (
        SELECT 1 FROM pg_type t
        JOIN pg_enum e ON e.enumtypid = t.oid
        WHERE t.typname = 'tokenauthmethod' AND e.enumlabel = 'client_secret_basic'
      ) THEN
        ALTER TYPE tokenauthmethod RENAME VALUE 'client_secret_basic' TO 'CLIENT_SECRET_BASIC';
      END IF;
    END$$;
    """)

    op.alter_column("clients", "type", server_default=sa.text("'PUBLIC'::clienttype"))
    op.alter_column(
        "clients",
        "token_endpoint_auth_method",
        server_default=sa.text("'NONE'::tokenauthmethod"),
    )



/* ===== C:\Users\icipa\team-platform-public\id_service\alembic\versions\20250822_1914-4844acc09d05_fix_enum_case.py ===== */

"""fix enum case

Revision ID: 4844acc09d05
Revises: 0001_initial
Create Date: 2025-08-22 19:14:18.705987

"""

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '4844acc09d05'
down_revision = '0001_initial'
branch_labels = None
depends_on = None

def upgrade() -> None:
    # РџРµСЂРµРёРјРµРЅРѕРІР°С‚СЊ Р·РЅР°С‡РµРЅРёСЏ enum'РѕРІ, РµСЃР»Рё РѕРЅРё РµС‰С‘ РІ UPPERCASE
    op.execute("""
    DO $$
    BEGIN
        IF EXISTS (
            SELECT 1 FROM pg_type t
            JOIN pg_enum e ON t.oid = e.enumtypid
            WHERE t.typname = 'clienttype' AND e.enumlabel = 'PUBLIC'
        ) THEN
            ALTER TYPE clienttype RENAME VALUE 'PUBLIC' TO 'public';
        END IF;
    END$$;
    """)

    op.execute("""
    DO $$
    BEGIN
        IF EXISTS (
            SELECT 1 FROM pg_type t
            JOIN pg_enum e ON t.oid = e.enumtypid
            WHERE t.typname = 'tokenauthmethod' AND e.enumlabel = 'NONE'
        ) THEN
            ALTER TYPE tokenauthmethod RENAME VALUE 'NONE' TO 'none';
        END IF;
        IF EXISTS (
            SELECT 1 FROM pg_type t
            JOIN pg_enum e ON t.oid = e.enumtypid
            WHERE t.typname = 'tokenauthmethod' AND e.enumlabel = 'CLIENT_SECRET_POST'
        ) THEN
            ALTER TYPE tokenauthmethod RENAME VALUE 'CLIENT_SECRET_POST' TO 'client_secret_post';
        END IF;
        IF EXISTS (
            SELECT 1 FROM pg_type t
            JOIN pg_enum e ON t.oid = e.enumtypid
            WHERE t.typname = 'tokenauthmethod' AND e.enumlabel = 'CLIENT_SECRET_BASIC'
        ) THEN
            ALTER TYPE tokenauthmethod RENAME VALUE 'CLIENT_SECRET_BASIC' TO 'client_secret_basic';
        END IF;
    END$$;
    """)

    # РћР±РЅРѕРІРёС‚СЊ server_default'С‹
    op.alter_column(
        "clients", "type",
        server_default=sa.text("'public'::clienttype"),
        existing_type=sa.Enum(name="clienttype"),
    )
    op.alter_column(
        "clients", "token_endpoint_auth_method",
        server_default=sa.text("'none'::tokenauthmethod"),
        existing_type=sa.Enum(name="tokenauthmethod"),
    )


def downgrade() -> None:
    # РћС‚РєР°С‚РёС‚СЊ Р·РЅР°С‡РµРЅРёСЏ enum'РѕРІ РѕР±СЂР°С‚РЅРѕ РІ UPPERCASE (РЅР° СЃР»СѓС‡Р°Р№ РґР°СѓРЅРіСЂРµР№РґР°)
    op.execute("""
    DO $$
    BEGIN
        IF EXISTS (
            SELECT 1 FROM pg_type t
            JOIN pg_enum e ON t.oid = e.enumtypid
            WHERE t.typname = 'clienttype' AND e.enumlabel = 'public'
        ) THEN
            ALTER TYPE clienttype RENAME VALUE 'public' TO 'PUBLIC';
        END IF;
    END$$;
    """)

    op.execute("""
    DO $$
    BEGIN
        IF EXISTS (
            SELECT 1 FROM pg_type t
            JOIN pg_enum e ON t.oid = e.enumtypid
            WHERE t.typname = 'tokenauthmethod' AND e.enumlabel = 'client_secret_basic'
        ) THEN
            ALTER TYPE tokenauthmethod RENAME VALUE 'client_secret_basic' TO 'CLIENT_SECRET_BASIC';
        END IF;
        IF EXISTS (
            SELECT 1 FROM pg_type t
            JOIN pg_enum e ON t.oid = e.enumtypid
            WHERE t.typname = 'tokenauthmethod' AND e.enumlabel = 'client_secret_post'
        ) THEN
            ALTER TYPE tokenauthmethod RENAME VALUE 'client_secret_post' TO 'CLIENT_SECRET_POST';
        END IF;
        IF EXISTS (
            SELECT 1 FROM pg_type t
            JOIN pg_enum e ON t.oid = e.enumtypid
            WHERE t.typname = 'tokenauthmethod' AND e.enumlabel = 'none'
        ) THEN
            ALTER TYPE tokenauthmethod RENAME VALUE 'none' TO 'NONE';
        END IF;
    END$$;
    """)

    op.alter_column(
        "clients", "type",
        server_default=sa.text("'PUBLIC'::clienttype"),
        existing_type=sa.Enum(name="clienttype"),
    )
    op.alter_column(
        "clients", "token_endpoint_auth_method",
        server_default=sa.text("'NONE'::tokenauthmethod"),
        existing_type=sa.Enum(name="tokenauthmethod"),
    )



/* ===== C:\Users\icipa\team-platform-public\id_service\alembic\versions\20250822_1929-f94c88b39bdb_lowercase_enums_and_defaults.py ===== */

"""lowercase enums and defaults

Revision ID: f94c88b39bdb
Revises: 4844acc09d05
Create Date: 2025-08-22 19:29:09.507410

"""

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'f94c88b39bdb'
down_revision = '4844acc09d05'
branch_labels = None
depends_on = None

def upgrade() -> None:
    # РџРµСЂРµРёРјРµРЅРѕРІР°С‚СЊ Р·РЅР°С‡РµРЅРёСЏ ENUM, РµСЃР»Рё РѕРЅРё РµС‰С‘ РІ РІРµСЂС…РЅРµРј СЂРµРіРёСЃС‚СЂРµ
    op.execute("""
    DO $$
    BEGIN
      IF EXISTS (
        SELECT 1 FROM pg_enum e JOIN pg_type t ON t.oid=e.enumtypid
        WHERE t.typname='clienttype' AND e.enumlabel='PUBLIC'
      ) THEN
        ALTER TYPE clienttype RENAME VALUE 'PUBLIC' TO 'public';
      END IF;

      IF EXISTS (
        SELECT 1 FROM pg_enum e JOIN pg_type t ON t.oid=e.enumtypid
        WHERE t.typname='clienttype' AND e.enumlabel='CONFIDENTIAL'
      ) THEN
        ALTER TYPE clienttype RENAME VALUE 'CONFIDENTIAL' TO 'confidential';
      END IF;

      IF EXISTS (
        SELECT 1 FROM pg_enum e JOIN pg_type t ON t.oid=e.enumtypid
        WHERE t.typname='tokenauthmethod' AND e.enumlabel='NONE'
      ) THEN
        ALTER TYPE tokenauthmethod RENAME VALUE 'NONE' TO 'none';
      END IF;

      IF EXISTS (
        SELECT 1 FROM pg_enum e JOIN pg_type t ON t.oid=e.enumtypid
        WHERE t.typname='tokenauthmethod' AND e.enumlabel='CLIENT_SECRET_POST'
      ) THEN
        ALTER TYPE tokenauthmethod RENAME VALUE 'CLIENT_SECRET_POST' TO 'client_secret_post';
      END IF;

      IF EXISTS (
        SELECT 1 FROM pg_enum e JOIN pg_type t ON t.oid=e.enumtypid
        WHERE t.typname='tokenauthmethod' AND e.enumlabel='CLIENT_SECRET_BASIC'
      ) THEN
        ALTER TYPE tokenauthmethod RENAME VALUE 'CLIENT_SECRET_BASIC' TO 'client_secret_basic';
      END IF;
    END $$;
    """)

    # РћР±РЅРѕРІРёС‚СЊ РґРµС„РѕР»С‚С‹ РІ С‚Р°Р±Р»РёС†Рµ clients
    op.execute("ALTER TABLE clients ALTER COLUMN type SET DEFAULT 'public'::clienttype")
    op.execute("""
        ALTER TABLE clients ALTER COLUMN token_endpoint_auth_method
        SET DEFAULT 'none'::tokenauthmethod
    """)


def downgrade() -> None:
    # Р’РµСЂРЅСѓС‚СЊ РґРµС„РѕР»С‚С‹
    op.execute("""
        ALTER TABLE clients ALTER COLUMN token_endpoint_auth_method
        SET DEFAULT 'NONE'::tokenauthmethod
    """)
    op.execute("ALTER TABLE clients ALTER COLUMN type SET DEFAULT 'PUBLIC'::clienttype")

    # Р’РµСЂРЅСѓС‚СЊ Р·РЅР°С‡РµРЅРёСЏ ENUM РІ РІРµСЂС…РЅРёР№ СЂРµРіРёСЃС‚СЂ (РµСЃР»Рё РІРґСЂСѓРі Р±С‹Р»Рё РїРѕРЅРёР¶РµРЅС‹)
    op.execute("""
    DO $$
    BEGIN
      IF EXISTS (
        SELECT 1 FROM pg_enum e JOIN pg_type t ON t.oid=e.enumtypid
        WHERE t.typname='tokenauthmethod' AND e.enumlabel='client_secret_basic'
      ) THEN
        ALTER TYPE tokenauthmethod RENAME VALUE 'client_secret_basic' TO 'CLIENT_SECRET_BASIC';
      END IF;

      IF EXISTS (
        SELECT 1 FROM pg_enum e JOIN pg_type t ON t.oid=e.enumtypid
        WHERE t.typname='tokenauthmethod' AND e.enumlabel='client_secret_post'
      ) THEN
        ALTER TYPE tokenauthmethod RENAME VALUE 'client_secret_post' TO 'CLIENT_SECRET_POST';
      END IF;

      IF EXISTS (
        SELECT 1 FROM pg_enum e JOIN pg_type t ON t.oid=e.enumtypid
        WHERE t.typname='tokenauthmethod' AND e.enumlabel='none'
      ) THEN
        ALTER TYPE tokenauthmethod RENAME VALUE 'none' TO 'NONE';
      END IF;

      IF EXISTS (
        SELECT 1 FROM pg_enum e JOIN pg_type t ON t.oid=e.enumtypid
        WHERE t.typname='clienttype' AND e.enumlabel='confidential'
      ) THEN
        ALTER TYPE clienttype RENAME VALUE 'confidential' TO 'CONFIDENTIAL';
      END IF;

      IF EXISTS (
        SELECT 1 FROM pg_enum e JOIN pg_type t ON t.oid=e.enumtypid
        WHERE t.typname='clienttype' AND e.enumlabel='public'
      ) THEN
        ALTER TYPE clienttype RENAME VALUE 'public' TO 'PUBLIC';
      END IF;
    END $$;
    """)


/* ===== C:\Users\icipa\team-platform-public\id_service\api\account\__init__.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\api\account\delete_account.py ===== */

# id_service/api/account/delete_account.py


import logging
import asyncio
from fastapi import APIRouter, Request, Depends, HTTPException, status, Response
from sqlalchemy.ext.asyncio import AsyncSession

from db.session import get_async_session
from schemas.account import DeleteAccountRequest, DeleteAccountResponse
from api.account.profile import get_current_user
from services.session_service import session_service
from services.backchannel_logout import backchannel_logout_service
from crud import user_crud
from core.security import security

logger = logging.getLogger(__name__)
router = APIRouter()


@router.delete("/delete", response_model=DeleteAccountResponse)
async def delete_account(
    request: Request,
    delete_data: DeleteAccountRequest,
    session: AsyncSession = Depends(get_async_session),
    current_user = Depends(get_current_user),
    response: Response = None,
):
    """Delete user account (soft delete)"""
    
    # Verify password
    if not security.verify_password(delete_data.current_password, current_user.password_hash):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid password"
        )
    
    # Verify confirmation
    if delete_data.confirmation != "DELETE":
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Please type DELETE to confirm"
        )
    
    # Revoke all sessions
    _ = await session_service.revoke_all_user_sessions(session, str(current_user.id))

    # РћС‡РёСЃС‚РёС‚СЊ SSO cookie
    if response is not None:
        session_service.clear_session_cookie(response)

    # Revoke all refresh tokens and notify clients
    from services.token_service import token_service
    affected = await token_service.revoke_all_refresh_tokens_for_user(
        session, str(current_user.id), reason="account_deleted"
    )

    for cid in affected:
        asyncio.create_task(
            backchannel_logout_service.initiate_backchannel_logout(
                session=None,
                user=current_user,
                session_id=None,
                reason="account_deleted",
                only_client_id=cid
            )
        )

    
    # Soft delete user
    await user_crud.soft_delete(session, current_user)
    
    logger.info(f"Account deleted for user {current_user.id}")
    
    return DeleteAccountResponse(
        message="Account has been deleted"
    )


/* ===== C:\Users\icipa\team-platform-public\id_service\api\account\email_change.py ===== */

# id_service/api/account/email_change.py

import logging
import asyncio
from fastapi import APIRouter, Request, Depends, HTTPException, status, Response
from sqlalchemy.ext.asyncio import AsyncSession

from db.session import get_async_session
from schemas.account import (
    ChangeEmailRequest, ChangeEmailResponse,
    ConfirmEmailChangeRequest, ConfirmEmailChangeResponse
)
from api.account.profile import get_current_user
from services.email_service import email_service
from services.session_service import session_service
from services.backchannel_logout import backchannel_logout_service
from crud import user_crud
from utils.otp import otp_service
from utils.rate_limit import rate_limiter
from models import EmailCodePurpose
from core.security import security

logger = logging.getLogger(__name__)
router = APIRouter()


@router.post("/change-email/request", response_model=ChangeEmailResponse)
async def request_email_change(
    request: Request,
    change_data: ChangeEmailRequest,
    session: AsyncSession = Depends(get_async_session),
    current_user = Depends(get_current_user)
):
    """Request email change - sends verification code to new email"""
    
    # Rate limit
    await rate_limiter.check_rate_limit(request, "email_change", max_requests=3)
    
    # Verify current password
    if not security.verify_password(change_data.password, current_user.password_hash):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid password"
        )
    
    # Check if new email already exists
    if await user_crud.check_email_exists(
        session, 
        change_data.new_email,
        exclude_user_id=str(current_user.id)
    ):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already in use"
        )
    
    # Generate and send verification code to NEW email
    try:
        otp_code, email_code = await otp_service.create_otp(
            session=session,
            user=current_user,
            purpose=EmailCodePurpose.CHANGE_EMAIL,
            new_email=change_data.new_email,
            ip_address=request.client.host,
            user_agent=request.headers.get("User-Agent")
        )
        
        # Send verification email to NEW address
        await email_service.send_verification_code(
            to_email=change_data.new_email,
            username=current_user.username,
            code=otp_code,
            purpose="change_email"
        )
        
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_429_TOO_MANY_REQUESTS,
            detail=str(e)
        )
    
    logger.info(f"Email change requested for user {current_user.id}")
    
    return ChangeEmailResponse(
        message="Verification code sent to new email address"
    )


@router.post("/change-email/confirm", response_model=ConfirmEmailChangeResponse)
async def confirm_email_change(
    request: Request,
    confirm_data: ConfirmEmailChangeRequest,
    session: AsyncSession = Depends(get_async_session),
    current_user = Depends(get_current_user),
    response: Response = None,
):
    """Confirm email change with verification code"""
    
    # Rate limit
    await rate_limiter.check_rate_limit(request, "email_confirm", max_requests=10)
    
    # Verify OTP
    success, email_code, error = await otp_service.verify_otp(
        session=session,
        user_id=str(current_user.id),
        code=confirm_data.code,
        purpose=EmailCodePurpose.CHANGE_EMAIL
    )
    
    if not success:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=error or "Invalid verification code"
        )
    
    # Verify the new email matches
    if email_code.new_email != confirm_data.new_email.lower():
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email mismatch"
        )
    
    # Update email
    from schemas.user import UserUpdate
    user_update = UserUpdate(
        email=confirm_data.new_email,
        email_verified=True
    )
    await user_crud.update(session, current_user, user_update)
    
    # Revoke SSO sessions
    _ = await session_service.revoke_all_user_sessions(session, str(current_user.id))

    # РћС‡РёСЃС‚РёС‚СЊ SSO cookie
    if response is not None:
        session_service.clear_session_cookie(response)

    # Revoke refresh tokens and notify clients
    from services.token_service import token_service
    affected = await token_service.revoke_all_refresh_tokens_for_user(
        session, str(current_user.id), reason="email_changed"
    )

    
    for cid in affected:
        asyncio.create_task(
            backchannel_logout_service.initiate_backchannel_logout(
                session=None,
                user=current_user,
                session_id=None,
                reason="email_changed",
                only_client_id=cid
            )
        )

    
    logger.info(f"Email changed for user {current_user.id}")
    
    return ConfirmEmailChangeResponse(
        message="Email address updated successfully"
    )


/* ===== C:\Users\icipa\team-platform-public\id_service\api\account\password_change.py ===== */

# id_service/api/account/password_change.py


import logging
import asyncio
from fastapi import APIRouter, Request, Depends, HTTPException, status, Response
from sqlalchemy.ext.asyncio import AsyncSession

from db.session import get_async_session
from schemas.account import ChangePasswordRequest, ChangePasswordResponse
from api.account.profile import get_current_user
from services.email_service import email_service
from services.session_service import session_service
from services.backchannel_logout import backchannel_logout_service
from crud import user_crud
from core.security import security

logger = logging.getLogger(__name__)
router = APIRouter()


@router.post("/change-password", response_model=ChangePasswordResponse)
async def change_password(
    request: Request,
    change_data: ChangePasswordRequest,
    session: AsyncSession = Depends(get_async_session),
    current_user = Depends(get_current_user),
    response: Response = None
):
    """Change password for authenticated user"""
    
    # Verify old password
    if not security.verify_password(change_data.old_password, current_user.password_hash):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Current password is incorrect"
        )
    
    # Check new password is different
    if change_data.old_password == change_data.new_password:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="New password must be different from current password"
        )
    
    # Update password
    await user_crud.update_password(session, current_user, change_data.new_password)
    
    # Revoke all sessions
    _ = await session_service.revoke_all_user_sessions(session, str(current_user.id))

    # РћС‡РёСЃС‚РёС‚СЊ SSO cookie
    if response is not None:
        session_service.clear_session_cookie(response)

        
    
    # Revoke all refresh tokens and notify clients
    from services.token_service import token_service
    affected = await token_service.revoke_all_refresh_tokens_for_user(
        session, str(current_user.id), reason="password_changed"
    )
    for cid in affected:

        asyncio.create_task(
            backchannel_logout_service.initiate_backchannel_logout(
                session=None, user=current_user, session_id=None, reason="password_changed", only_client_id=cid
            )
        )
    

    
    logger.info(f"Password changed for user {current_user.id}")
    
    return ChangePasswordResponse(
        message="Password changed successfully"
    )


/* ===== C:\Users\icipa\team-platform-public\id_service\api\account\profile.py ===== */

# id_service/api/account/profile.py

import logging
from fastapi import APIRouter, Request, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession

from db.session import get_async_session
from schemas.account import ProfileResponse
from services.session_service import session_service
from crud import user_crud

logger = logging.getLogger(__name__)
router = APIRouter()


async def get_current_user(
    request: Request,
    session: AsyncSession = Depends(get_async_session)
):
    """Dependency to get current authenticated user"""
    
    # Get session from cookie
    idp_session = await session_service.get_session_from_cookie(session, request)
    if not idp_session:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated"
        )
    
    # Get user
    user = await user_crud.get_by_id(session, idp_session.user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    return user


@router.get("/profile", response_model=ProfileResponse)
async def get_profile(
    request: Request,
    session: AsyncSession = Depends(get_async_session),
    current_user = Depends(get_current_user)
):
    """Get current user profile"""
    
    return ProfileResponse(
        email=current_user.email,
        username=current_user.username,
        email_verified=current_user.email_verified,
        created_at=current_user.created_at,
        last_login_at=current_user.last_login_at
    )


/* ===== C:\Users\icipa\team-platform-public\id_service\api\auth\__init__.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\api\auth\csrf.py ===== */

# id_service/api/auth/csrf.py

from fastapi import APIRouter
from fastapi.responses import JSONResponse
from core.config import settings
from utils.csrf import csrf_protection

router = APIRouter()

@router.get("/csrf")
async def get_csrf():
    token = csrf_protection.generate_token()
    resp = JSONResponse({"csrf_token": token})
    resp.set_cookie(
        key=csrf_protection.cookie_name,
        value=token,
        path="/",
        httponly=False,  # double-submit
        secure=(settings.APP_ENV == "production"),
        samesite="lax",
    )
    return resp


/* ===== C:\Users\icipa\team-platform-public\id_service\api\auth\email_verification.py ===== */

# id_service/api/auth/email_verification.py
"""
РџРѕРґС‚РІРµСЂР¶РґРµРЅРёРµ e-mail вЂ” JSON-only.

РР·РјРµРЅРµРЅРёСЏ:
- РЈР±СЂР°РЅС‹ Р»СЋР±С‹Рµ RedirectResponse.
- РџСЂРё РЅР°Р»РёС‡РёРё РІР°Р»РёРґРЅРѕРіРѕ pending state РІ Redis С„РѕСЂРјРёСЂСѓРµРј redirect_to СЃС‚СЂРѕРєРѕР№ Р±РµР· 302.
- Р’СЃРµРіРґР° СЃС‚Р°РІРёРј SSO-cookie РЅР° JSON-РѕС‚РІРµС‚.
"""

import logging
import json
from urllib.parse import urlencode

from fastapi import APIRouter, Request, Response, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession

from db.session import get_async_session
from schemas.auth import VerifyEmailRequest, VerifyEmailResponse
from crud import user_crud, client_crud
from services.session_service import session_service
from services.token_service import token_service
from utils.otp import otp_service
from utils.rate_limit import rate_limiter
from utils.validators import validators
from models import EmailCodePurpose
from core.config import settings

logger = logging.getLogger(__name__)
router = APIRouter()


@router.post("/verify-email", response_model=VerifyEmailResponse)
async def verify_email(
    request: Request,
    response: Response,
    verify_data: VerifyEmailRequest,
    session: AsyncSession = Depends(get_async_session),
):
    """
    РџРѕРґС‚РІРµСЂР¶РґРµРЅРёРµ e-mail РїРѕ OTP РєРѕРґСѓ.
    РџРѕРІРµРґРµРЅРёРµ:
      - Р•СЃР»Рё РµСЃС‚СЊ pending /authorize РїРѕ state Рё redirect РІР°Р»РёРґРµРЅ вЂ” РІС‹РїСѓСЃРєР°РµРј code,
        РїСЂРёРІСЏР·С‹РІР°РµРј sid, СѓРґР°Р»СЏРµРј pending, РІРѕР·РІСЂР°С‰Р°РµРј JSON СЃ redirect_to.
      - РРЅР°С‡Рµ РѕР±С‹С‡РЅС‹Р№ JSON Р±РµР· redirect_to.
      - Р’Рћ Р’РЎР•РҐ СЃР»СѓС‡Р°СЏС… СЃС‚Р°РІРёРј SSO-cookie РЅР° СЌС‚РѕС‚ JSON-РѕС‚РІРµС‚.
    """
    # 1) Rate limit
    await rate_limiter.check_rate_limit(request, "verify_email", max_requests=10)

    # 2) РџРѕР»СЊР·РѕРІР°С‚РµР»СЊ
    user = await user_crud.get_by_id(session, verify_data.user_id)
    if not user:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User not found")

    # 3) РџСЂРѕРІРµСЂРєР° OTP
    success, email_code, error = await otp_service.verify_otp(
        session=session,
        user_id=verify_data.user_id,
        code=verify_data.code,
        purpose=EmailCodePurpose.REGISTER,
    )
    if not success:
        await rate_limiter.add_failed_attempt(verify_data.user_id, "otp_verify", max_attempts=5)
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=error or "Invalid verification code")

    # 4) РћС‚РјРµС‚РёС‚СЊ e-mail РєР°Рє РІРµСЂРёС„РёС†РёСЂРѕРІР°РЅРЅС‹Р№ Рё РѕС‡РёСЃС‚РёС‚СЊ СЃС‡С‘С‚С‡РёРє
    await user_crud.verify_email(session, user)
    await rate_limiter.clear_failed_attempts(verify_data.user_id, "otp_verify")

    # 5) РЎРѕР·РґР°С‚СЊ IdP-СЃРµСЃСЃРёСЋ
    idp_session = await session_service.create_session(session=session, user=user, request=request)

    # 6) OIDC-РїСЂРѕРґРѕР»Р¶РµРЅРёРµ: СЃРѕР±СЂР°С‚СЊ redirect_to, РµСЃР»Рё РµСЃС‚СЊ РІР°Р»РёРґРЅС‹Р№ pending РїРѕ state
    redirect_to: str | None = None
    if verify_data.state and rate_limiter.redis_client:
        raw = await rate_limiter.redis_client.get(f"authreq:{verify_data.state}")
        if raw:
            data = json.loads(raw)
            client = await client_crud.get_by_client_id(session, data.get("client_id"))
            redirect_uri = data.get("redirect_uri")
            if client and validators.validate_redirect_uri(redirect_uri, client.redirect_uris or []):
                # Р’С‹РїСѓСЃС‚РёС‚СЊ authorization code
                code = await token_service.create_auth_code(
                    session=session,
                    user=user,
                    client=client,
                    redirect_uri=redirect_uri,
                    scope=data.get("scope", ""),
                    state=verify_data.state,
                    nonce=data.get("nonce"),
                    code_challenge=data.get("code_challenge"),
                    ip_address=request.client.host,
                    user_agent=request.headers.get("User-Agent"),
                )
                # РџСЂРёРІСЏР·Р°С‚СЊ sid Рє РєРѕРґСѓ Рё СѓРґР°Р»РёС‚СЊ pending
                await rate_limiter.redis_client.setex(
                    f"authcode_sid:{code}", settings.AUTH_CODE_TTL, idp_session.session_id
                )
                await rate_limiter.redis_client.delete(f"authreq:{verify_data.state}")

                params = {"code": code, "state": verify_data.state}
                redirect_to = f"{redirect_uri}?{urlencode(params)}"

    # 7) РљСѓРєР° SSO вЂ” РЅР° С‚РµРєСѓС‰РёР№ JSON-РѕС‚РІРµС‚
    session_service.set_session_cookie(response, idp_session.session_id)

    logger.info(f"Email verified for user {user.id}")
    return VerifyEmailResponse(ok=True, message="Email verified successfully", redirect_to=redirect_to)



/* ===== C:\Users\icipa\team-platform-public\id_service\api\auth\login.py ===== */

# id_service/api/auth/login.py
"""
Р›РѕРіРёРЅ РїРѕ РїР°СЂРѕР»СЋ вЂ” JSON-only.
Р¦РµР»Рё:
- РџСЂРёРЅРёРјР°РµРј JSON (РЅРёРєР°РєРёС… Form(...)).
- РџСЂРѕРІРµСЂРєР° CSRF СѓР¶Рµ РІ CSRFMiddleware РїРѕ Р·Р°РіРѕР»РѕРІРєСѓ X-CSRF-Token.
- РќР° СѓСЃРїРµС…Рµ РІСЃРµРіРґР° СЃС‚Р°РІРёРј SSO-cookie РЅР° JSON-РѕС‚РІРµС‚.
- Р•СЃР»Рё РµСЃС‚СЊ РІР°Р»РёРґРЅС‹Рµ state+client_id РІ Redis (pending /authorize) вЂ” СЃРѕР·РґР°С‘Рј code Рё
  РІРѕР·РІСЂР°С‰Р°РµРј redirect_to СЃС‚СЂРѕРєРѕР№ Р±РµР· 302. РРЅР°С‡Рµ redirect_to = null.
"""

import logging
import json
from datetime import datetime, timezone
from typing import Optional
from urllib.parse import urlencode

from fastapi import APIRouter, Request, Response, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession

from db.session import get_async_session
from schemas.auth import LoginPasswordRequest, LoginPasswordResponse
from crud import user_crud, client_crud
from services.session_service import session_service
from services.token_service import token_service
from utils.rate_limit import rate_limiter
from utils.validators import validators
from core.security import security
from core.config import settings

logger = logging.getLogger(__name__)
router = APIRouter()


@router.post("/login-password", response_model=LoginPasswordResponse)
async def login_password(
    request: Request,
    response: Response,
    login_data: LoginPasswordRequest,
    session: AsyncSession = Depends(get_async_session),
):
    """
    Р›РѕРіРёРЅ РїРѕ РїР°СЂРѕР»СЋ СЃ JSON-С‚РµР»РѕРј.
    РџРѕРІРµРґРµРЅРёРµ:
      - РЈСЃРїРµС… Р±РµР· state: { ok:true, redirect_to:null } + СѓСЃС‚Р°РЅРѕРІРєР° SSO-cookie.
      - РЈСЃРїРµС… СЃ РІР°Р»РёРґРЅС‹РјРё state+client_id (pending РІ Redis): РІС‹РґР°С‘Рј code, СѓРґР°Р»СЏРµРј pending,
        РІРѕР·РІСЂР°С‰Р°РµРј { ok:true, redirect_to:"<redirect_uri>?code=...&state=..." } + cookie.
    РћС€РёР±РєРё: С‡РµСЂРµР· HTTPException, РёС… РїРµСЂРµС…РІР°С‚РёС‚ РіР»РѕР±Р°Р»СЊРЅС‹Р№ С…РµРЅРґР»РµСЂ.
    """

    # 1) Rate limit
    await rate_limiter.check_rate_limit(request, "login", max_requests=10)

    # 2) РџРѕРёСЃРє РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ Рё Р±Р°Р·РѕРІС‹Рµ РїСЂРѕРІРµСЂРєРё
    user = await user_crud.get_by_email(session, login_data.email)
    if not user:
        await rate_limiter.add_failed_attempt(login_data.email, "login")
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid email or password")

    if not security.verify_password(login_data.password, user.password_hash):
        await user_crud.update_login_info(session, user, success=False)
        await rate_limiter.add_failed_attempt(login_data.email, "login")
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid email or password")

    # РћРїС†РёРѕРЅР°Р»СЊРЅР°СЏ С‚РёС…Р°СЏ РїРµСЂРµ-РІС‹С‡РёСЃР»СЏРµРјРѕСЃС‚СЊ С…СЌС€Р°
    if security.needs_rehash(user.password_hash):
        await user_crud.rehash_password(session, user, login_data.password)

    if not user.email_verified:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Please verify your email first")

    # 3) РЈСЃРїРµС€РЅС‹Р№ РІС…РѕРґ: Р°СѓРґРёС‚ Рё РѕС‡РёСЃС‚РєР° СЃС‡С‘С‚С‡РёРєРѕРІ
    await rate_limiter.clear_failed_attempts(login_data.email, "login")
    await user_crud.update_login_info(session, user, success=True)

    # 4) РЎРѕР·РґР°С‚СЊ IdP-СЃРµСЃСЃРёСЋ
    idp_session = await session_service.create_session(
        session=session,
        user=user,
        request=request,
        remember_me=login_data.remember_me,
    )
    # Р’С‹С‡РёСЃР»РёС‚СЊ max_age РґР»СЏ РєСѓРєРё РёР· hard-max TTL СЃРµСЃСЃРёРё
    max_age = int((idp_session.max_expires_at - datetime.now(timezone.utc)).total_seconds())

    # 5) OIDC-РїСЂРѕРґРѕР»Р¶РµРЅРёРµ, РµСЃР»Рё РїСЂРёС€Р»Рё client_id+state Рё РІ Redis РµСЃС‚СЊ pending authreq
    redirect_to: Optional[str] = None
    if login_data.client_id and login_data.state and rate_limiter.redis_client:
        raw = await rate_limiter.redis_client.get(f"authreq:{login_data.state}")
        if raw:
            data = json.loads(raw)

            # Р’Р°Р»РёРґР°С†РёСЏ РєР»РёРµРЅС‚Р° Рё redirect_uri
            client = await client_crud.get_by_client_id(session, login_data.client_id)
            if client and data.get("client_id") == login_data.client_id and validators.validate_redirect_uri(
                data.get("redirect_uri"), client.redirect_uris or []
            ):
                # Р’С‹РїСѓСЃРєР°РµРј РѕРґРЅРѕСЂР°Р·РѕРІС‹Р№ authorization code
                code = await token_service.create_auth_code(
                    session=session,
                    user=user,
                    client=client,
                    redirect_uri=data["redirect_uri"],
                    scope=data["scope"],
                    state=login_data.state,
                    nonce=data.get("nonce"),
                    code_challenge=data.get("code_challenge"),
                    ip_address=request.client.host,
                    user_agent=request.headers.get("User-Agent"),
                )

                # РџСЂРёРІСЏР¶РµРј sid Рє РєРѕРґСѓ РЅР° TTL РєРѕРґР° Рё СѓРґР°Р»РёРј pending
                await rate_limiter.redis_client.setex(f"authcode_sid:{code}", settings.AUTH_CODE_TTL, idp_session.session_id)
                await rate_limiter.redis_client.delete(f"authreq:{login_data.state}")

                # РЎС„РѕСЂРјРёСЂРѕРІР°С‚СЊ redirect_to СЃС‚СЂРѕРєСѓ РґР»СЏ С„СЂРѕРЅС‚Р°
                params = {"code": code, "state": login_data.state}
                redirect_to = f'{data["redirect_uri"]}?{urlencode(params)}'

    # 6) РЈСЃС‚Р°РЅРѕРІРёС‚СЊ SSO-cookie РЅР° СЃР°Рј JSON-РѕС‚РІРµС‚
    session_service.set_session_cookie(response, idp_session.session_id, max_age=max_age)

    # 7) Р’РµСЂРЅСѓС‚СЊ СѓРЅРёС„РёС†РёСЂРѕРІР°РЅРЅС‹Р№ JSON-РѕС‚РІРµС‚ Р±РµР· 302
    return LoginPasswordResponse(ok=True, message="Login successful", redirect_to=redirect_to)



/* ===== C:\Users\icipa\team-platform-public\id_service\api\auth\password_reset.py ===== */

# id_service/api/auth/password_reset.py


import logging
import asyncio
import secrets
from fastapi import APIRouter, Request, Depends, HTTPException, status, Response
from sqlalchemy.ext.asyncio import AsyncSession

from db.session import get_async_session
from schemas.auth import (
    ForgotPasswordRequest, ForgotPasswordResponse,
    VerifyResetRequest, VerifyResetResponse,
    SetNewPasswordRequest, SetNewPasswordResponse
)
from utils.rate_limit import rate_limiter
from crud import user_crud
from services.email_service import email_service
from services.session_service import session_service
from services.backchannel_logout import backchannel_logout_service
from services.token_service import token_service
from utils.otp import otp_service
from models import EmailCodePurpose

logger = logging.getLogger(__name__)
router = APIRouter()


@router.post("/forgot-password", response_model=ForgotPasswordResponse)
async def forgot_password(
    request: Request,
    forgot_data: ForgotPasswordRequest,
    session: AsyncSession = Depends(get_async_session)
):
    """Request password reset"""
    
    # Rate limit
    await rate_limiter.check_rate_limit(request, "forgot_password", max_requests=3)
    
    # Always return same response for security
    response_message = "If an account exists with this email, a reset code has been sent"
    
    # Find user
    user = await user_crud.get_by_email(session, forgot_data.email)
    if user:
        try:
            # Generate and send reset code
            otp_code, email_code = await otp_service.create_otp(
                session=session,
                user=user,
                purpose=EmailCodePurpose.RESET_PASSWORD,
                ip_address=request.client.host,
                user_agent=request.headers.get("User-Agent")
            )
            
            # Send reset email
            await email_service.send_verification_code(
                to_email=user.email,
                username=user.username,
                code=otp_code,
                purpose="reset"
            )
            
            logger.info(f"Password reset requested for user {user.id}")
            
        except Exception as e:
            logger.error(f"Failed to process password reset: {e}")
    
    return ForgotPasswordResponse(message=response_message)


@router.post("/verify-reset", response_model=VerifyResetResponse)
async def verify_reset(
    request: Request,
    verify_data: VerifyResetRequest,
    session: AsyncSession = Depends(get_async_session)
):
    """Verify password reset code"""
    
    # Rate limit
    await rate_limiter.check_rate_limit(request, "verify_reset", max_requests=10)
    
    # Find user
    user = await user_crud.get_by_email(session, verify_data.email)
    if not user:
        # РѕРґРёРЅР°РєРѕРІС‹Р№ РѕС‚РІРµС‚, Р±РµР· СѓС‚РµС‡РєРё РЅР°Р»РёС‡РёСЏ e-mail
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid email or code"
        )

    
    # Verify OTP
    success, email_code, error = await otp_service.verify_otp(
        session=session,
        user_id=str(user.id),
        code=verify_data.code,
        purpose=EmailCodePurpose.RESET_PASSWORD
    )
    
    if not success:
        await rate_limiter.add_failed_attempt(
            verify_data.email,
            "reset_verify",
            max_attempts=5
        )
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=error or "Invalid reset code"
        )
    
    # Generate temporary reset token
    reset_token = secrets.token_urlsafe(32)
    # Store reset token in Redis (15 РјРёРЅСѓС‚)
    if rate_limiter.redis_client:
        await rate_limiter.redis_client.setex(
            f"pwdreset:{user.id}", 900, reset_token
        )  
    
    return VerifyResetResponse(
        user_id=str(user.id),
        reset_token=reset_token
    )


@router.post("/set-new-password", response_model=SetNewPasswordResponse)
async def set_new_password(
    request: Request,
    reset_data: SetNewPasswordRequest,
    session: AsyncSession = Depends(get_async_session),
    response: Response = None,
):
    """Set new password after reset"""
    
    # Rate limit
    await rate_limiter.check_rate_limit(request, "set_password", max_requests=5)
    
    # Verify reset token (one-time)
    if not rate_limiter.redis_client:
        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail="Reset not available")
    stored = await rate_limiter.redis_client.get(f"pwdreset:{reset_data.user_id}")
    if not stored or stored != reset_data.reset_token:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Invalid reset token")
    await rate_limiter.redis_client.delete(f"pwdreset:{reset_data.user_id}")

    
    # Get user
    user = await user_crud.get_by_id(session, reset_data.user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Invalid reset token"
        )
    
    # Update password
    await user_crud.update_password(session, user, reset_data.new_password)

    # Revoke all sessions
    _ = await session_service.revoke_all_user_sessions(session, str(user.id))

    # РћС‡РёСЃС‚РёС‚СЊ SSO cookie
    if response is not None:
        session_service.clear_session_cookie(response)

    # Revoke all refresh tokens and notify clients
    
    affected = await token_service.revoke_all_refresh_tokens_for_user(
        session, str(user.id), reason="password_reset"
    )
    
    for cid in affected:
        asyncio.create_task(
            backchannel_logout_service.initiate_backchannel_logout(
                session=None, user=user, session_id=None, reason="password_reset", only_client_id=cid
            )
        )


    
    logger.info(f"Password reset completed for user {user.id}")
    
    return SetNewPasswordResponse(
        message="Password has been reset successfully"
    )


/* ===== C:\Users\icipa\team-platform-public\id_service\api\auth\register.py ===== */

# id_service/api/auth/register.py

import logging
from fastapi import APIRouter, Request, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession

from db.session import get_async_session
from schemas.auth import RegisterRequest, RegisterResponse
from schemas.user import UserCreate
from crud import user_crud
from services.email_service import email_service
from utils.otp import otp_service
from utils.rate_limit import rate_limiter
from models import EmailCodePurpose

logger = logging.getLogger(__name__)
router = APIRouter()


@router.post("/register", response_model=RegisterResponse)
async def register(
    request: Request,
    register_data: RegisterRequest,
    session: AsyncSession = Depends(get_async_session)
):
    """Register new user"""
    
    # Rate limit
    await rate_limiter.check_rate_limit(request, "register", max_requests=5)
    
    # Check if email already exists
    if await user_crud.check_email_exists(session, register_data.email):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered"
        )
    
    # Check if username already exists
    if await user_crud.check_username_exists(session, register_data.username):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Username already taken"
        )
    
    # Create user
    user_create = UserCreate(
        email=register_data.email,
        username=register_data.username,
        password=register_data.password,
        email_verified=False
    )
    
    user = await user_crud.create(session, user_create)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create user"
        )
    
    # Generate and send verification code
    try:
        otp_code, email_code = await otp_service.create_otp(
            session=session,
            user=user,
            purpose=EmailCodePurpose.REGISTER,
            ip_address=request.client.host,
            user_agent=request.headers.get("User-Agent")
        )
        
        # Send verification email
        await email_service.send_verification_code(
            to_email=user.email,
            username=user.username,
            code=otp_code,
            purpose="registration"
        )
        
    except ValueError as e:
        # OTP creation failed (cooldown)
        raise HTTPException(
            status_code=status.HTTP_429_TOO_MANY_REQUESTS,
            detail=str(e)
        )
    except Exception as e:
        logger.error(f"Failed to send verification email: {e}")
        # Don't reveal email sending issues
    
    return RegisterResponse(
        user_id=str(user.id),
        message="Registration successful. Please check your email for verification code."
    )


/* ===== C:\Users\icipa\team-platform-public\id_service\api\health.py ===== */

# id_service/api/health.py

from fastapi import APIRouter, Depends
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text

from db.session import get_async_session
from utils.rate_limit import rate_limiter

from fastapi.responses import JSONResponse


router = APIRouter()


@router.get("/health")
async def health():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "service": "id-service"
    }


@router.get("/health/ready")
async def readiness(session: AsyncSession = Depends(get_async_session)):
    """Readiness check with database connection"""
    try:
        # Check database
        await session.execute(text("SELECT 1"))
        
        # Check Redis
        redis_healthy = False
        if rate_limiter.redis_client:
            try:
                await rate_limiter.redis_client.ping()
                redis_healthy = True
            except:
                pass
        
        return {
            "status": "ready",
            "database": "connected",
            "redis": "connected" if redis_healthy else "disconnected"
        }
    except Exception as e:
        return JSONResponse(
            {"status": "not_ready", "error": str(e)},
            status_code=503
        )


/* ===== C:\Users\icipa\team-platform-public\id_service\api\oidc\__init__.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\api\oidc\authorize.py ===== */

# id_service/api/oidc/authorize.py

import json
import logging
from typing import Optional
from urllib.parse import urlencode

from fastapi import APIRouter, Request, Depends, HTTPException, Query
from fastapi.responses import RedirectResponse, JSONResponse
from sqlalchemy.ext.asyncio import AsyncSession

from db.session import get_async_session
from core.config import settings
from crud import client_crud, user_crud
from services.session_service import session_service
from services.token_service import token_service
from utils.validators import validators
from utils.rate_limit import rate_limiter
from models import ClientType

logger = logging.getLogger(__name__)
router = APIRouter()


def _oauth_error_redirect(redirect_uri: Optional[str], state: Optional[str], error: str, desc: str):
    if redirect_uri:
        params = {"error": error, "error_description": desc}
        if state is not None:
            params["state"] = state
        return RedirectResponse(
            url=f"{redirect_uri}?{urlencode(params)}",
            status_code=302,
            headers={"Cache-Control": "no-store", "Pragma": "no-cache"},
        )
    # Fallback: JSON РІРјРµСЃС‚Рѕ HTML
    body = {"error": error, "error_description": desc}
    if state is not None:
        body["state"] = state
    return JSONResponse(body, status_code=400, headers={"Cache-Control": "no-store", "Pragma": "no-cache"})


@router.get("/authorize")
async def authorize(
    request: Request,
    session: AsyncSession = Depends(get_async_session),
    client_id: str = Query(...),
    response_type: str = Query(...),
    redirect_uri: str = Query(...),
    scope: str = Query(...),
    state: str = Query(..., min_length=1),
    nonce: Optional[str] = Query(None),
    code_challenge: Optional[str] = Query(None),
    code_challenge_method: Optional[str] = Query(None),
):
    # Р‘Р°Р·РѕРІР°СЏ РІР°Р»РёРґР°С†РёСЏ Р·Р°РїСЂРѕСЃР°
    if response_type != "code":
        return _oauth_error_redirect(redirect_uri, state, "unsupported_response_type", "Only response_type=code is supported")

    client = await client_crud.get_by_client_id(session, client_id)
    if not client:
        return _oauth_error_redirect(redirect_uri, state, "unauthorized_client", "Unknown client_id")

    if not validators.validate_redirect_uri(redirect_uri, client.redirect_uris or []):
        return _oauth_error_redirect(redirect_uri, state, "invalid_request", "redirect_uri is not registered for client")

    ok, err = validators.validate_scope(scope)
    if not ok:
        return _oauth_error_redirect(redirect_uri, state, "invalid_scope", err)

    ok, err = validators.validate_state(state)
    if not ok:
        return _oauth_error_redirect(redirect_uri, state, "invalid_request", err)

    ok, err = validators.validate_nonce(nonce or "")
    if not ok:
        return _oauth_error_redirect(redirect_uri, state, "invalid_request", err)

    # PKCE С‚СЂРµР±РѕРІР°РЅРёСЏ
    require_pkce = client.type == ClientType.PUBLIC or (getattr(client, "pkce_required", True) is True)
    if require_pkce:
        if code_challenge is None or (code_challenge_method or "S256") != "S256":
            return _oauth_error_redirect(redirect_uri, state, "invalid_request", "PKCE S256 is required")

    # Р•СЃР»Рё РµСЃС‚СЊ SSO вЂ” РІС‹РґР°РµРј code Рё СЂРµРґРёСЂРµРєС‚РёРј СЃСЂР°Р·Сѓ
    idp_session = await session_service.get_session_from_cookie(session, request)
    if idp_session:
        user = await user_crud.get_by_id(session, idp_session.user_id)
        if not user:
            return _oauth_error_redirect(redirect_uri, state, "access_denied", "User not found")

        code = await token_service.create_auth_code(
            session=session,
            user=user,
            client=client,
            redirect_uri=redirect_uri,
            scope=scope,
            state=state,
            nonce=nonce,
            code_challenge=code_challenge,  # СЃРѕС…СЂР°РЅСЏРµРј РєР°Рє РµСЃС‚СЊ, РІРµСЂРёС„РёС†РёСЂСѓРµРј РЅР° /token
            ip_address=request.client.host,
            user_agent=request.headers.get("User-Agent"),
        )

        # РџСЂРёРІСЏР¶РµРј sid Рє РєРѕРґСѓ С‡РµСЂРµР· Redis, С‡С‚РѕР±С‹ РїРѕС‚РѕРј РґРѕР±Р°РІРёС‚СЊ РІ id_token
        if rate_limiter.redis_client:
            await rate_limiter.redis_client.setex(
                f"authcode_sid:{code}", settings.AUTH_CODE_TTL, idp_session.session_id
            )

        params = {"code": code, "state": state}
        return RedirectResponse(url=f"{redirect_uri}?{urlencode(params)}", status_code=302)

    # РќРµС‚ SSO вЂ” СЃРѕС…СЂР°РЅРёРј pending Рё СЂРµРґРёСЂРµРєС‚РёРј РЅР° SPA /login
    if not rate_limiter.redis_client:
        return _oauth_error_redirect(redirect_uri, state, "server_error", "Redis unavailable")

    payload = {
        "client_id": client_id,
        "redirect_uri": redirect_uri,
        "scope": scope,
        "state": state,
        "nonce": nonce,
        "code_challenge": code_challenge,
        "created_at": "now",
        "ip": request.client.host,
        "ua": validators.sanitize_user_agent(request.headers.get("User-Agent")),
    }
    await rate_limiter.redis_client.setex(f"authreq:{state}", settings.AUTH_CODE_TTL, json.dumps(payload))

    # Р±Р°Р·РѕРІС‹Р№ origin С‚РµРєСѓС‰РµРіРѕ С…РѕСЃС‚Р° (id.localhost РёР»Рё id.asynq.ru)
    host = request.headers.get("host") or request.url.netloc
    origin = f"{request.url.scheme}://{host.split(',')[0].strip()}"
    login_qs = urlencode({
        "client_id": client_id,
        "redirect_uri": redirect_uri,
        "scope": scope,
        "state": state,
        **({"nonce": nonce} if nonce else {}),
        **({"code_challenge": code_challenge} if code_challenge else {}),
    })
    return RedirectResponse(url=f"{origin}/login?{login_qs}", status_code=302)


/* ===== C:\Users\icipa\team-platform-public\id_service\api\oidc\discovery.py ===== */

# id_service/api/oidc/discovery.py
"""
OIDC Discovery (.well-known/openid-configuration)

РћР±РЅРѕРІР»РµРЅРѕ:
- frontchannel_logout_supported = False, С‚.Рє. С„СЂРѕРЅС‚-РєР°РЅР°Р» СѓР±СЂР°РЅ.
- backchannel_logout_supported = True (РєР°Рє Рё Р±С‹Р»Рѕ).
"""

from fastapi import APIRouter, Request
from fastapi.responses import JSONResponse

from core.config import settings
from schemas.oidc import DiscoveryResponse

router = APIRouter()


@router.get("/.well-known/openid-configuration", response_model=DiscoveryResponse)
async def openid_configuration(request: Request):
    """OpenID Connect Discovery endpoint"""
    base_url = settings.ISSUER

    return DiscoveryResponse(
        issuer=base_url,
        authorization_endpoint=f"{base_url}/authorize",
        token_endpoint=f"{base_url}/token",
        userinfo_endpoint=f"{base_url}/userinfo",
        jwks_uri=f"{base_url}/.well-known/jwks.json",
        end_session_endpoint=f"{base_url}/logout",
        response_types_supported=["code"],
        grant_types_supported=["authorization_code", "refresh_token"],
        scopes_supported=["openid", "email", "profile", "offline_access"],
        id_token_signing_alg_values_supported=["RS256"],
        subject_types_supported=["public"],
        token_endpoint_auth_methods_supported=["none", "client_secret_post", "client_secret_basic"],
        code_challenge_methods_supported=["S256"],
        claims_supported=[
            "sub", "email", "email_verified", "preferred_username",
            "auth_time", "iss", "aud", "exp", "iat", "nonce", "at_hash", "sid"
        ],
        frontchannel_logout_supported=False,   # С„СЂРѕРЅС‚-РєР°РЅР°Р» РѕС‚РєР»СЋС‡С‘РЅ
        backchannel_logout_supported=True,
        backchannel_logout_session_supported=True,
    )



/* ===== C:\Users\icipa\team-platform-public\id_service\api\oidc\jwks.py ===== */

# id_service/api/oidc/jwks.py

import logging
from fastapi import APIRouter
from fastapi.responses import JSONResponse
from services.jwk_service import jwk_service

logger = logging.getLogger(__name__)
router = APIRouter()

@router.get("/.well-known/jwks.json")
async def jwks():
    jwks_dict = await jwk_service.get_jwks()
    return JSONResponse(
        jwks_dict,
        headers={
            "Cache-Control": "public, max-age=300, must-revalidate",
            "Content-Type": "application/json",
        },
    )



/* ===== C:\Users\icipa\team-platform-public\id_service\api\oidc\logout.py ===== */

# id_service/api/oidc/logout.py
"""
OIDC RP-Initiated Logout.

РР·РјРµРЅРµРЅРёСЏ:
- Р”РѕР±Р°РІР»РµРЅ JSON-Р»РѕРіР°СѓС‚: POST /logout СЃ С‚РµР»РѕРј LogoutRequest Рё РѕС‚РІРµС‚РѕРј LogoutResponse.
- GET /logout СѓРїСЂРѕС‰С‘РЅ: Р±РѕР»СЊС€Рµ РќР•Рў HTML/iframes. РўРѕР»СЊРєРѕ:
    - 302 РЅР° РІР°Р»РёРґРЅС‹Р№ post_logout_redirect_uri (РµСЃР»Рё РѕРЅ РІР°Р»РёРґРµРЅ РґР»СЏ РєР»РёРµРЅС‚Р° РёР· id_token_hint)
    - РёРЅР°С‡Рµ 204 No Content.
- Back-channel РѕСЃС‚Р°С‘С‚СЃСЏ. Р¤СЂРѕРЅС‚-РєР°РЅР°Р» СѓРґР°Р»С‘РЅ.
- РћС‡РёСЃС‚РєР° cookie Рё РѕС‚Р·С‹РІ IdP-СЃРµСЃСЃРёРё вЂ” С‚РѕР»СЊРєРѕ РІ POST-РІР°СЂРёР°РЅС‚Рµ (РїРѕ РўР—).
"""

import logging
import asyncio
from typing import Optional
from urllib.parse import urlencode

from fastapi import APIRouter, Request, Response, Depends, Query
from fastapi.responses import RedirectResponse
from sqlalchemy.ext.asyncio import AsyncSession
from jose import jwt, JWTError

from db.session import get_async_session
from services.session_service import session_service
from services.backchannel_logout import backchannel_logout_service
from services.jwk_service import jwk_service
from crud import client_crud, user_crud
from utils.validators import validators
from core.config import settings
from schemas.oidc import LogoutRequest, LogoutResponse

logger = logging.getLogger(__name__)
router = APIRouter()


async def _parse_id_token_hint(
    id_token_hint: Optional[str],
    session: AsyncSession,
) -> tuple[Optional[str], Optional[str]]:
    """
    Р Р°Р·Р±РѕСЂ id_token_hint.
    Р’РѕР·РІСЂР°С‰Р°РµС‚ (client_id, user_id) РµСЃР»Рё С‚РѕРєРµРЅ РєРѕСЂСЂРµРєС‚РµРЅ. РРЅР°С‡Рµ (None, None).
    РђСѓРґРёС‚РѕСЂРёСЋ (aud) РІР°Р»РёРґРёСЂСѓРµРј РєР°Рє СЃС‚СЂРѕРєСѓ РѕРґРЅРѕРіРѕ РєР»РёРµРЅС‚Р°.
    """
    if not id_token_hint:
        return None, None
    try:
        hdr = jwt.get_unverified_header(id_token_hint)
        kid = hdr.get("kid")
        jwk = await jwk_service.get_key_by_kid(kid) if kid else None
        if not jwk:
            raise JWTError("unknown kid")
        public_key = jwk_service.load_public_key(jwk.public_pem)

        # aud РїСЂРѕРІРµСЂСЏС‚СЊ РєР°Рє hint: verify_aud=False, РЅРѕ issuer РїСЂРѕРІРµСЂСЏРµРј
        claims = jwt.decode(
            id_token_hint,
            public_key,
            algorithms=["RS256"],
            issuer=settings.ISSUER,
            options={"verify_aud": False},
        )
        aud = claims.get("aud")
        client_id = aud if isinstance(aud, str) else None
        user_id = claims.get("sub")
        return client_id, user_id
    except JWTError:
        logger.warning("Invalid id_token_hint provided")
        return None, None


def _build_redirect(redirect_uri: Optional[str], state: Optional[str]) -> Optional[str]:
    """РЎРѕР±РёСЂР°РµС‚ redirect_to СЃС‚СЂРѕРєСѓ СЃ ?state=... РµСЃР»Рё Р·Р°РґР°РЅРѕ."""
    if not redirect_uri:
        return None
    if state:
        return f"{redirect_uri}?{urlencode({'state': state})}"
    return redirect_uri


@router.post("/logout", response_model=LogoutResponse)
async def logout_post(
    request: Request,
    response: Response,
    body: LogoutRequest,
    session: AsyncSession = Depends(get_async_session),
):
    """
    JSON-Р»РѕРіР°СѓС‚.
    Р”РµР№СЃС‚РІРёСЏ:
      - Р•СЃР»Рё РµСЃС‚СЊ IdP-СЃРµСЃСЃРёСЏ: РѕС‚РѕР·РІР°С‚СЊ, РѕС‡РёСЃС‚РёС‚СЊ cookie, РґРµСЂРЅСѓС‚СЊ back-channel.
      - Р’Р°Р»РёРґР°С†РёСЏ post_logout_redirect_uri РёРґС‘С‚ РїРѕ РєР»РёРµРЅС‚Сѓ РёР· id_token_hint.
      - Р’РѕР·РІСЂР°С‰Р°РµРј { ok: true, redirect_to: <uri>|null }. 302 РЅРµС‚.
    """
    # 1) Р Р°Р·РѕР±СЂР°С‚СЊ id_token_hint, С‡С‚РѕР±С‹ РїРѕРЅСЏС‚СЊ РєР»РёРµРЅС‚Р° Рё РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ (РґР»СЏ back-channel)
    client_id_from_hint, user_id_from_hint = await _parse_id_token_hint(body.id_token_hint, session)

    # 2) РЎС‡РёС‚Р°С‚СЊ С‚РµРєСѓС‰СѓСЋ IdP-СЃРµСЃСЃРёСЋ РёР· cookie
    idp_session = await session_service.get_session_from_cookie(session, request)
    current_user = None

    # 3) Р•СЃР»Рё СЃРµСЃСЃРёСЏ РµСЃС‚СЊ вЂ” РѕС‚Р·С‹РІР°РµРј Рё РѕС‡РёС‰Р°РµРј cookie
    if idp_session:
        # Р•СЃР»Рё РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ РµС‰С‘ РЅРµ Р·РЅР°РµРј вЂ” Р·Р°РіСЂСѓР·РёРј
        if not user_id_from_hint:
            user_id_from_hint = str(idp_session.user_id)
        current_user = await user_crud.get_by_id(session, user_id_from_hint) if user_id_from_hint else None

        await session_service.revoke_session(session, idp_session)
        session_service.clear_session_cookie(response)

        # 4) Back-channel РґР»СЏ Р°РєС‚РёРІРЅС‹С… RP (РєР°Рє СЂР°РЅСЊС€Рµ)
        if current_user:
            asyncio.create_task(
                backchannel_logout_service.initiate_backchannel_logout(
                    session=None,  # СЃРµСЂРІРёСЃ СЃР°Рј РѕС‚РєСЂРѕРµС‚ СЃРµСЃСЃРёСЋ
                    user=current_user,
                    session_id=idp_session.session_id,
                    reason="rp_logout",
                )
            )

    # 5) Р’Р°Р»РёРґР°С†РёСЏ post_logout_redirect_uri РїРѕ РєР»РёРµРЅС‚Сѓ РёР· id_token_hint
    redirect_to: Optional[str] = None
    if body.post_logout_redirect_uri and client_id_from_hint:
        client = await client_crud.get_by_client_id(session, client_id_from_hint)
        if client and validators.validate_redirect_uri(body.post_logout_redirect_uri, client.post_logout_redirect_uris):
            redirect_to = _build_redirect(body.post_logout_redirect_uri, body.state)

    # 6) JSON-РѕС‚РІРµС‚
    return LogoutResponse(ok=True, redirect_to=redirect_to)


@router.get("/logout")
async def logout_get(
    request: Request,
    session: AsyncSession = Depends(get_async_session),
    id_token_hint: Optional[str] = Query(None),
    post_logout_redirect_uri: Optional[str] = Query(None),
    state: Optional[str] = Query(None),
):
    """
    РЈРїСЂРѕС‰С‘РЅРЅС‹Р№ GET-РІР°СЂРёР°РЅС‚.
    РќРёРєР°РєРёС… HTML/iframes. Р‘РµР· РѕС‡РёСЃС‚РєРё cookie Рё Р±РµР· СЂРµРІРѕРєР°С†РёРё.
    Р•СЃР»Рё redirect РІР°Р»РёРґРµРЅ РїРѕ РєР»РёРµРЅС‚Сѓ РёР· id_token_hint вЂ” 302 С‚СѓРґР° (РґРѕР±Р°РІРёРј state).
    РРЅР°С‡Рµ вЂ” 204 No Content.
    """
    client_id_from_hint, _ = await _parse_id_token_hint(id_token_hint, session)

    if post_logout_redirect_uri and client_id_from_hint:
        client = await client_crud.get_by_client_id(session, client_id_from_hint)
        if client and validators.validate_redirect_uri(post_logout_redirect_uri, client.post_logout_redirect_uris):
            url = _build_redirect(post_logout_redirect_uri, state)
            return RedirectResponse(url=url, status_code=302)

    # РќРёС‡РµРіРѕ РЅРµ РґРµР»Р°РµРј, РґР°С‘Рј 204
    return Response(status_code=204)



/* ===== C:\Users\icipa\team-platform-public\id_service\api\oidc\revoke.py ===== */

# id_service/api/oidc/revoke.py

import logging
from typing import Optional

from fastapi import APIRouter, Request, Depends, Form
from fastapi.responses import JSONResponse
from sqlalchemy.ext.asyncio import AsyncSession

from db.session import get_async_session
from .token import _get_client_and_auth  # РёСЃРїРѕР»СЊР·СѓРµРј С‚РѕС‚ Р¶Рµ helper
from services.token_service import token_service

logger = logging.getLogger(__name__)
router = APIRouter()

@router.post("/revoke")
async def revoke(
    request: Request,
    session: AsyncSession = Depends(get_async_session),
    token: str = Form(...),
    token_type_hint: Optional[str] = Form(None),
    client_id: Optional[str] = Form(None),
    client_secret: Optional[str] = Form(None),
):
    # РђСѓС‚РµРЅС‚РёС„РёС†РёСЂСѓРµРј РєР»РёРµРЅС‚Р° С‚Р°Рє Р¶Рµ, РєР°Рє РЅР° /token
    client, err = await _get_client_and_auth(request, session, client_id, client_secret)
    if err:
        return err  # 401 invalid_client РїСЂРё РѕС€РёР±РєРµ

    # РџРѕРґРґРµСЂР¶РёРІР°РµРј С‚РѕР»СЊРєРѕ refresh_token (access вЂ” СЃР°РјРѕРґРѕСЃС‚Р°С‚РѕС‡РЅС‹Р№ JWT)
    if token_type_hint and token_type_hint not in ("refresh_token", "access_token"):
        # РїРѕ RFC РїСЂРѕСЃС‚Рѕ РёРіРЅРѕСЂРёСЂСѓРµРј hint Рё РїСЂРѕРґРѕР»Р¶Р°РµРј
        pass

    # РџРѕ RFC: РІСЃРµРіРґР° 200 OK РґР°Р¶Рµ РµСЃР»Рё С‚РѕРєРµРЅ РЅРµРІР°Р»РёРґРµРЅ/РЅРµ РЅР°Р№РґРµРЅ
    try:
        await token_service.revoke_refresh_token(
            session=session,
            refresh_token=token,
            client_id=client.client_id,
            reason="revoked_by_client",
        )
    except Exception:
        # РЅРµ РїР°Р»РёРј РґРµС‚Р°Р»Рё РЅР°СЂСѓР¶Сѓ
        pass

    return JSONResponse({}, status_code=200)



/* ===== C:\Users\icipa\team-platform-public\id_service\api\oidc\token.py ===== */

# id_service/api/oidc/token.py

import base64
import json
import logging
from typing import Optional, Tuple

from fastapi import APIRouter, Request, Depends, Form
from fastapi.responses import JSONResponse
from sqlalchemy.ext.asyncio import AsyncSession

from db.session import get_async_session
from utils.rate_limit import rate_limiter
from crud import client_crud
from models import TokenAuthMethod, ClientType
from services.token_service import token_service
from utils.validators import validators
from core.config import settings

logger = logging.getLogger(__name__)
router = APIRouter()


def _oauth_error(error: str, desc: str, status_code: int = 400):
    return JSONResponse(
        {"error": error, "error_description": desc},
        status_code=status_code,
        headers={"Cache-Control": "no-store", "Pragma": "no-cache"},
    )

def _basic_auth(header: Optional[str]) -> Tuple[Optional[str], Optional[str]]:
    if not header or not header.lower().startswith("basic "):
        return None, None
    try:
        raw = base64.b64decode(header.split(" ", 1)[1]).decode()
        client_id, client_secret = raw.split(":", 1)
        return client_id, client_secret
    except Exception:
        return None, None


async def _get_client_and_auth(request: Request, session: AsyncSession, form_client_id: Optional[str], form_client_secret: Optional[str]):
    auth_header = request.headers.get("Authorization")
    basic_id, basic_secret = _basic_auth(auth_header)
    client_id = basic_id or form_client_id
    client = await client_crud.get_by_client_id(session, client_id) if client_id else None
    if not client:
        return None, _oauth_error("invalid_client", "Unknown client_id", 401)

    # Determine how client authenticates
    method = client.token_endpoint_auth_method
    if method == TokenAuthMethod.NONE:
        # public client, no secret expected
        return client, None
    elif method == TokenAuthMethod.CLIENT_SECRET_BASIC:
        if basic_id is None:
            return None, _oauth_error("invalid_client", "client_secret_basic required", 401)
        if not await client_crud.verify_secret(client, basic_secret or ""):
            return None, _oauth_error("invalid_client", "Invalid client secret", 401)
        return client, None
    elif method == TokenAuthMethod.CLIENT_SECRET_POST:
        secret = form_client_secret or ""
        if not await client_crud.verify_secret(client, secret):
            return None, _oauth_error("invalid_client", "Invalid client secret", 401)
        return client, None
    else:
        return None, _oauth_error("invalid_client", "Unsupported auth method", 401)


@router.post("/token")
async def token(
    request: Request,
    session: AsyncSession = Depends(get_async_session),
    grant_type: str = Form(...),
    code: Optional[str] = Form(None),
    redirect_uri: Optional[str] = Form(None),
    code_verifier: Optional[str] = Form(None),
    refresh_token: Optional[str] = Form(None),
    client_id: Optional[str] = Form(None),
    client_secret: Optional[str] = Form(None),
):
    client, err = await _get_client_and_auth(request, session, client_id, client_secret)
    if err:
        return err

    if grant_type == "authorization_code":
        if not code or not redirect_uri:
            return _oauth_error("invalid_request", "code and redirect_uri are required")

        # PKCE: РґР»СЏ public/required вЂ” РѕР±СЏР·Р°С‚РµР»РµРЅ РєРѕСЂСЂРµРєС‚РЅС‹Р№ verifier
        require_pkce = client.type == ClientType.PUBLIC or (getattr(client, "pkce_required", True) is True)
        if require_pkce:
            ok, errtxt = validators.validate_pkce_verifier(code_verifier or "")
            if not ok:
                return _oauth_error("invalid_request", errtxt)

        auth_code, oauth_err = await token_service.exchange_auth_code(
            session=session,
            code=code,
            client_id=client.client_id,
            redirect_uri=redirect_uri,
            code_verifier=code_verifier,
        )
        if oauth_err:
            return _oauth_error(oauth_err, "invalid authorization code")

        # РџРѕР»СѓС‡Р°РµРј sid РёР· Redis (РїСЂРёРІСЏР·Р°Р»Рё РЅР° /authorize)
        sid = None
        if rate_limiter.redis_client:
            sid = await rate_limiter.redis_client.get(f"authcode_sid:{code}")

        tokens = await token_service.create_tokens(
            session=session,
            user=auth_code.user,
            client=client,
            scope=auth_code.scope,
            nonce=auth_code.nonce,
            auth_time=auth_code.auth_time,
            session_id=sid,
            ip_address=request.client.host,
            user_agent=request.headers.get("User-Agent"),
        )

        return JSONResponse(tokens, headers={"Cache-Control": "no-store", "Pragma": "no-cache"})


    elif grant_type == "refresh_token":
        if not refresh_token:
            return _oauth_error("invalid_request", "refresh_token is required")

        new_tokens, oauth_err = await token_service.rotate_refresh_token(
            session=session,
            refresh_token=refresh_token,
            client_id=client.client_id,
            ip_address=request.client.host,
            user_agent=request.headers.get("User-Agent"),
        )
        if oauth_err:
            return _oauth_error(oauth_err, "cannot rotate refresh token")
        return JSONResponse(new_tokens, headers={"Cache-Control": "no-store", "Pragma": "no-cache"})


    else:
        return _oauth_error("unsupported_grant_type", "Only authorization_code and refresh_token are supported")



/* ===== C:\Users\icipa\team-platform-public\id_service\api\oidc\userinfo.py ===== */

# id_service/api/oidc/userinfo.py

import logging
from fastapi import APIRouter, Request, Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.ext.asyncio import AsyncSession

from db.session import get_async_session
from schemas.oidc import UserInfoResponse
from services.token_service import token_service
from crud import user_crud

logger = logging.getLogger(__name__)
router = APIRouter()

security = HTTPBearer()


@router.get("/userinfo", response_model=UserInfoResponse)
@router.post("/userinfo", response_model=UserInfoResponse)
async def userinfo(
    request: Request,
    session: AsyncSession = Depends(get_async_session),
    credentials: HTTPAuthorizationCredentials = Depends(security)
):
    """OpenID Connect UserInfo endpoint"""
    
    # Verify access token
    token_claims = await token_service.verify_access_token(credentials.credentials)
    
    if not token_claims:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid access token",
            headers={"WWW-Authenticate": "Bearer"}
        )
    
    # Check scope
    scopes = token_claims.get("scope", "").split()
    
    # Get user
    user = await user_crud.get_by_id(session, token_claims["sub"])
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    # Build response based on scopes
    response_data = {
        "sub": str(user.id)
    }
    
    if "email" in scopes:
        response_data["email"] = user.email
        response_data["email_verified"] = user.email_verified
    
    if "profile" in scopes:
        response_data["preferred_username"] = user.username
        if user.updated_at:
            response_data["updated_at"] = int(user.updated_at.timestamp())
    
    return UserInfoResponse(**response_data)


/* ===== C:\Users\icipa\team-platform-public\id_service\core\__init__.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\core\config.py ===== */

# id_service/core/config.py
from typing import List
from pydantic_settings import BaseSettings, SettingsConfigDict
from pydantic import Field


class Settings(BaseSettings):
    # App
    APP_NAME: str = "ID Service"
    APP_ENV: str = "development"  # development|production
    ISSUER: str = "http://localhost:8000"
    CORS_ORIGINS: List[str] = []

    # DB / Redis
    DATABASE_URL: str = "postgresql+asyncpg://postgres:password@localhost:5432/id_service"
    DB_ECHO: bool = False
    REDIS_URL: str = "redis://localhost:6379/1"

    # Security / Secrets
    SECRET_KEY: str = "dev-secret"
    PEPPER_SECRET: str = "dev-pepper"
    COOKIE_SECRET: str = "dev-cookie-secret"
    JWT_PRIVATE_KEY_PASSWORD: str = "dev-jwt-password"

    # Token TTLs (seconds)
    ACCESS_TOKEN_TTL: int = 600
    REFRESH_TOKEN_TTL: int = 2592000
    AUTH_CODE_TTL: int = 600
    SSO_IDLE_TTL: int = 1800
    SSO_MAX_TTL: int = 86400

    # OTP
    OTP_TTL: int = 300
    OTP_RESEND_SECONDS: int = 60
    OTP_MAX_ATTEMPTS: int = 5

    # SMTP
    SMTP_HOST: str = "smtp.gmail.com"
    SMTP_PORT: int = 587
    SMTP_USER: str = ""
    SMTP_PASSWORD: str = ""
    SMTP_TLS: bool = True
    EMAIL_FROM: str = "Asynq ID <noreply@example.com>"

    # Rate limit
    RATE_LIMIT_ENABLED: bool = True
    RATE_LIMIT_REQUESTS_PER_MINUTE: int = 60

    # Password policy
    PASSWORD_MIN_LENGTH: int = 8
    PASSWORD_REQUIRE_UPPERCASE: bool = True
    PASSWORD_REQUIRE_LOWERCASE: bool = True
    PASSWORD_REQUIRE_DIGIT: bool = True
    PASSWORD_REQUIRE_SPECIAL: bool = False

    # Dev client IDs
    TEACH_CLIENT_ID: str = "teach-service"
    RUN_CLIENT_ID: str = "run-service"
    LEARN_CLIENT_ID: str = "learn-service"
    CATALOG_CLIENT_ID: str = "catalog-service"
    ADMIN_CLIENT_ID: str = "admin-service"

    # Argon2id tuning (can be overridden via .env)
    ARGON2_TIME_COST: int = 3
    ARGON2_MEMORY_COST: int = 65536  # KiB (64 MiB)
    ARGON2_PARALLELISM: int = 2
    ARGON2_HASH_LEN: int = 32
    ARGON2_SALT_LEN: int = 16

    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        case_sensitive=False,
    )


settings = Settings()



/* ===== C:\Users\icipa\team-platform-public\id_service\core\constants.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\core\security.py ===== */

# id_service/core/security.py

import base64
import hashlib
import hmac
import secrets
import string
from typing import Tuple

from argon2 import PasswordHasher, Type
from argon2.exceptions import VerifyMismatchError
from core.config import settings


class SecurityService:

    def __init__(self) -> None:
        self.pepper = settings.PEPPER_SECRET
        self.ph = PasswordHasher(
            time_cost=settings.ARGON2_TIME_COST,
            memory_cost=settings.ARGON2_MEMORY_COST,
            parallelism=settings.ARGON2_PARALLELISM,
            hash_len=settings.ARGON2_HASH_LEN,
            salt_len=settings.ARGON2_SALT_LEN,
            type=Type.ID,
        )
    # -------- Password hashing (Argon2id + pepper) --------
    def hash_password(self, password: str) -> str:
        return self.ph.hash(f"{password}{self.pepper}")

    def is_argon2id_hash(self, stored: str) -> bool:
        return stored.startswith("$argon2id$")


    def verify_password(self, password: str, stored: str) -> bool:
        if not self.is_argon2id_hash(stored):
            return False
        try:
            self.ph.verify(stored, f"{password}{self.pepper}")
            return True
        except VerifyMismatchError:
            return False
        except Exception:
            return False

    def needs_rehash(self, stored: str) -> bool:
        if not self.is_argon2id_hash(stored):
            return False
        try:
            return self.ph.check_needs_rehash(stored)
        except Exception:
            return True

    # -------- OTP (email codes) --------
    def generate_otp(self, length: int = 4) -> str:
        digits = string.digits
        return "".join(secrets.choice(digits) for _ in range(length))

    def hash_otp(self, code: str) -> str:
        digest = hmac.new(self.pepper.encode("utf-8"), code.encode("utf-8"), hashlib.sha256).digest()
        return base64.urlsafe_b64encode(digest).decode().rstrip("=")

    def constant_time_compare(self, a: str, b: str) -> bool:
        return hmac.compare_digest(a, b)

    # -------- Password policy --------
    def validate_password_strength(self, password: str) -> Tuple[bool, str]:
        if len(password) < int(getattr(settings, "PASSWORD_MIN_LENGTH", 8)):
            return False, f"Password must be at least {settings.PASSWORD_MIN_LENGTH} characters"
        if getattr(settings, "PASSWORD_REQUIRE_UPPERCASE", True) and not any(c.isupper() for c in password):
            return False, "Password must contain an uppercase letter"
        if getattr(settings, "PASSWORD_REQUIRE_LOWERCASE", True) and not any(c.islower() for c in password):
            return False, "Password must contain a lowercase letter"
        if getattr(settings, "PASSWORD_REQUIRE_DIGIT", True) and not any(c.isdigit() for c in password):
            return False, "Password must contain a digit"
        if getattr(settings, "PASSWORD_REQUIRE_SPECIAL", False) and not any(c in "!@#$%^&*()-_=+[]{};:,.?/\\|" for c in password):
            return False, "Password must contain a special character"
        return True, ""

    # -------- PKCE S256 --------
    def verify_code_challenge(self, code_verifier: str, stored_challenge: str) -> bool:
        if not code_verifier or not stored_challenge:
            return False
        if len(code_verifier) < 43 or len(code_verifier) > 128:
            return False
        allowed = set(string.ascii_letters + string.digits + "-._~")
        if any(c not in allowed for c in code_verifier):
            return False
        digest = hashlib.sha256(code_verifier.encode()).digest()
        computed = base64.urlsafe_b64encode(digest).decode().rstrip("=")
        return hmac.compare_digest(computed, stored_challenge)


security = SecurityService()



/* ===== C:\Users\icipa\team-platform-public\id_service\crud\__init__.py ===== */

# id_service/crud/__init__.py

from .user import user_crud
from .client import client_crud
from .idp_session import idp_session_crud

__all__ = [
    "user_crud",
    "client_crud",
    "idp_session_crud"
]


/* ===== C:\Users\icipa\team-platform-public\id_service\crud\auth_code.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\crud\client.py ===== */

# id_service/crud/client.py

from typing import Optional, List
from datetime import datetime, timezone
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_

from models import Client, ClientType, TokenAuthMethod
from core.security import security

import logging
logger = logging.getLogger(__name__)


class ClientCRUD:
    """CRUD operations for Client model"""
    
    async def get_by_client_id(
        self,
        session: AsyncSession,
        client_id: str
    ) -> Optional[Client]:
        """Get client by client_id"""
        result = await session.execute(
            select(Client).where(Client.client_id == client_id)
        )
        return result.scalar_one_or_none()
    
    async def create(
        self,
        session: AsyncSession,
        client_id: str,
        name: str,
        client_type: ClientType = ClientType.PUBLIC,
        redirect_uris: List[str] = None,
        post_logout_redirect_uris: List[str] = None,
        backchannel_logout_uri: Optional[str] = None,
        frontchannel_logout_uri: Optional[str] = None,
        scopes: List[str] = None,
        client_secret: Optional[str] = None,
        pkce_required: bool = True
    ) -> Client:
        """Create new client"""
        
        # Hash client secret if provided
        client_secret_hash = None
        if client_secret:
            client_secret_hash = security.hash_password(client_secret)
        
        client = Client(
            client_id=client_id,
            name=name,
            type=client_type,
            token_endpoint_auth_method=(
                TokenAuthMethod.CLIENT_SECRET_POST 
                if client_type == ClientType.CONFIDENTIAL 
                else TokenAuthMethod.NONE
            ),
            pkce_required=pkce_required,
            redirect_uris=redirect_uris or [],
            post_logout_redirect_uris=post_logout_redirect_uris or [],
            backchannel_logout_uri=backchannel_logout_uri,
            frontchannel_logout_uri=frontchannel_logout_uri,
            scopes=scopes or ["openid", "email", "profile"],
            client_secret_hash=client_secret_hash,
            created_at=datetime.now(timezone.utc)
        )
        
        session.add(client)
        await session.flush()
        
        logger.info(f"Created client {client_id}")
        return client
    
    async def update(
        self,
        session: AsyncSession,
        client: Client,
        **kwargs
    ) -> Client:
        """Update client"""
        for key, value in kwargs.items():
            if hasattr(client, key):
                setattr(client, key, value)
        
        client.updated_at = datetime.now(timezone.utc)
        await session.flush()
        
        logger.info(f"Updated client {client.client_id}")
        return client
    
    async def rotate_secret(
        self,
        session: AsyncSession,
        client: Client,
        new_secret: str
    ) -> Client:
        """Rotate client secret"""
        client.client_secret_hash = security.hash_password(new_secret)
        client.secret_rotated_at = datetime.now(timezone.utc)
        client.updated_at = datetime.now(timezone.utc)
        
        await session.flush()
        
        logger.info(f"Rotated secret for client {client.client_id}")
        return client
    
    async def verify_secret(
        self,
        client: Client,
        secret: str
    ) -> bool:
        """Verify client secret"""
        if not client.client_secret_hash:
            return False
        
        return security.verify_password(secret, client.client_secret_hash)
    
    async def list_all(
        self,
        session: AsyncSession,
        limit: int = 100,
        offset: int = 0
    ) -> List[Client]:
        """List all clients"""
        result = await session.execute(
            select(Client)
            .order_by(Client.created_at.desc())
            .limit(limit)
            .offset(offset)
        )
        return result.scalars().all()


client_crud = ClientCRUD()


/* ===== C:\Users\icipa\team-platform-public\id_service\crud\email_code.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\crud\idp_session.py ===== */

# id_service/crud/idp_session.py

from typing import Optional, List
from datetime import datetime, timezone, timedelta
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_

from models import IDPSession

import logging
logger = logging.getLogger(__name__)


class IDPSessionCRUD:
    """CRUD operations for IDP Session model"""
    
    async def get_active_session(
        self,
        session: AsyncSession,
        session_id: str
    ) -> Optional[IDPSession]:
        """Get active session by ID"""
        now = datetime.now(timezone.utc)
        
        result = await session.execute(
            select(IDPSession).where(
                and_(
                    IDPSession.session_id == session_id,
                    IDPSession.revoked_at.is_(None),
                    IDPSession.idle_expires_at > now,
                    IDPSession.max_expires_at > now
                )
            )
        )
        return result.scalar_one_or_none()
    
    async def get_user_sessions(
        self,
        session: AsyncSession,
        user_id: str,
        only_active: bool = True
    ) -> List[IDPSession]:
        """Get all sessions for a user"""
        query = select(IDPSession).where(IDPSession.user_id == user_id)
        
        if only_active:
            now = datetime.now(timezone.utc)
            query = query.where(
                and_(
                    IDPSession.revoked_at.is_(None),
                    IDPSession.max_expires_at > now
                )
            )
        
        query = query.order_by(IDPSession.created_at.desc())
        
        result = await session.execute(query)
        return result.scalars().all()
    
    async def cleanup_expired(
        self,
        session: AsyncSession
    ) -> int:
        """Clean up expired sessions"""
        now = datetime.now(timezone.utc)
        cutoff = now - timedelta(days=7)  # Keep for 7 days after expiry
        
        result = await session.execute(
            select(IDPSession).where(
                or_(
                    IDPSession.max_expires_at < cutoff,
                    and_(
                        IDPSession.revoked_at.is_not(None),
                        IDPSession.revoked_at < cutoff
                    )
                )
            )
        )
        
        expired_sessions = result.scalars().all()
        
        for idp_session in expired_sessions:
            session.delete(idp_session)
        
        await session.flush()
        
        count = len(expired_sessions)
        if count > 0:
            logger.info(f"Cleaned up {count} expired sessions")
        
        return count


idp_session_crud = IDPSessionCRUD()


/* ===== C:\Users\icipa\team-platform-public\id_service\crud\jwk_key.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\crud\refresh_token.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\crud\user.py ===== */

# id_service/crud/user.py

from typing import Optional, List
from datetime import datetime, timezone
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, func, or_
from sqlalchemy.exc import IntegrityError

from models import User
from schemas.user import UserCreate, UserUpdate
from core.security import security

from datetime import datetime, timezone
from sqlalchemy.ext.asyncio import AsyncSession
from models import User
from core.security import security

import logging
logger = logging.getLogger(__name__)


class UserCRUD:
    """CRUD operations for User model"""
    
    async def create(
        self,
        session: AsyncSession,
        user_create: UserCreate
    ) -> Optional[User]:
        """Create new user"""
        try:
            # Hash password
            password_hash = security.hash_password(user_create.password)
            
            # Create user
            user = User(
                email=user_create.email.lower(),
                username=user_create.username,
                password_hash=password_hash,
                email_verified=user_create.email_verified,
                created_at=datetime.now(timezone.utc)
            )
            
            session.add(user)
            await session.flush()
            
            logger.info(f"Created user with ID {user.id}")
            return user
            
        except IntegrityError as e:
            logger.warning(f"Failed to create user: {e}")
            await session.rollback()
            return None
    
    async def get_by_id(
        self,
        session: AsyncSession,
        user_id: str
    ) -> Optional[User]:
        """Get user by ID"""
        result = await session.execute(
            select(User).where(
                and_(
                    User.id == user_id,
                    User.deleted_at.is_(None)
                )
            )
        )
        return result.scalar_one_or_none()
    
    async def get_by_email(
        self,
        session: AsyncSession,
        email: str
    ) -> Optional[User]:
        """Get user by email (case-insensitive)"""
        result = await session.execute(
            select(User).where(
                and_(
                    func.lower(User.email) == email.lower(),
                    User.deleted_at.is_(None)
                )
            )
        )
        return result.scalar_one_or_none()
    
    async def get_by_username(
        self,
        session: AsyncSession,
        username: str
    ) -> Optional[User]:
        """Get user by username"""
        result = await session.execute(
            select(User).where(
                and_(
                    User.username == username,
                    User.deleted_at.is_(None)
                )
            )
        )
        return result.scalar_one_or_none()
    
    async def get_by_email_or_username(
        self,
        session: AsyncSession,
        identifier: str
    ) -> Optional[User]:
        """Get user by email or username"""
        result = await session.execute(
            select(User).where(
                and_(
                    or_(
                        func.lower(User.email) == identifier.lower(),
                        User.username == identifier
                    ),
                    User.deleted_at.is_(None)
                )
            )
        )
        return result.scalar_one_or_none()
    
    async def update(
        self,
        session: AsyncSession,
        user: User,
        user_update: UserUpdate
    ) -> User:
        """Update user"""
        update_data = user_update.model_dump(exclude_unset=True)
        
        for field, value in update_data.items():
            if field == "email" and value:
                value = value.lower()
            setattr(user, field, value)
        
        user.updated_at = datetime.now(timezone.utc)
        await session.flush()
        
        logger.info(f"Updated user {user.id}")
        return user
    
    async def update_password(
        self,
        session: AsyncSession,
        user: User,
        new_password: str
    ) -> User:
        """Update user password"""
        user.password_hash = security.hash_password(new_password)
        user.last_password_change_at = datetime.now(timezone.utc)
        user.updated_at = datetime.now(timezone.utc)
        user.failed_login_attempts = 0  # Reset failed attempts
        
        await session.flush()
        
        logger.info(f"Updated password for user {user.id}")
        return user
    
    async def verify_email(
        self,
        session: AsyncSession,
        user: User
    ) -> User:
        """Mark user email as verified"""
        user.email_verified = True
        user.updated_at = datetime.now(timezone.utc)
        
        await session.flush()
        
        logger.info(f"Verified email for user {user.id}")
        return user
    
    async def update_login_info(
        self,
        session: AsyncSession,
        user: User,
        success: bool = True
    ) -> User:
        """Update login information"""
        now = datetime.now(timezone.utc)
        
        if success:
            user.last_login_at = now
            user.failed_login_attempts = 0
        else:
            user.failed_login_attempts += 1
        
        user.updated_at = now
        await session.flush()
        
        return user
    
    async def soft_delete(
        self,
        session: AsyncSession,
        user: User
    ) -> User:
        """Soft delete user"""
        now = datetime.now(timezone.utc)
        user.deleted_at = now
        user.updated_at = now
        
        # Anonymize personal data
        user.email = f"deleted_{user.id}@deleted.local"
        user.username = f"deleted_{user.id}"
        
        await session.flush()
        
        logger.info(f"Soft deleted user {user.id}")
        return user
    
    async def check_email_exists(
        self,
        session: AsyncSession,
        email: str,
        exclude_user_id: Optional[str] = None
    ) -> bool:
        """Check if email already exists"""
        query = select(User).where(
            and_(
                func.lower(User.email) == email.lower(),
                User.deleted_at.is_(None)
            )
        )
        
        if exclude_user_id:
            query = query.where(User.id != exclude_user_id)
        
        result = await session.execute(query.exists().select())
        return result.scalar()
    
    async def check_username_exists(
        self,
        session: AsyncSession,
        username: str,
        exclude_user_id: Optional[str] = None
    ) -> bool:
        """Check if username already exists"""
        query = select(User).where(
            and_(
                User.username == username,
                User.deleted_at.is_(None)
            )
        )
        
        if exclude_user_id:
            query = query.where(User.id != exclude_user_id)
        
        result = await session.execute(query.exists().select())
        return result.scalar()
    
    async def rehash_password(
        self,
        session: AsyncSession,
        user: User,
        raw_password: str
    ) -> User:
        """
        РўРёС…РёР№ СЂРµ-С…СЌС€ РїР°СЂРѕР»СЏ (Р±РµР· РїРѕРјРµС‚РєРё last_password_change_at).
        РњРµРЅСЏРµС‚ С‚РѕР»СЊРєРѕ password_hash/updated_at/failed_login_attempts.
        """
        user.password_hash = security.hash_password(raw_password)
        user.updated_at = datetime.now(timezone.utc)
        user.failed_login_attempts = 0
        await session.flush()
        return user


user_crud = UserCRUD()


/* ===== C:\Users\icipa\team-platform-public\id_service\db\__init__.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\db\base.py ===== */

# id_service/db/base.py
from __future__ import annotations

from sqlalchemy import MetaData
from sqlalchemy.orm import DeclarativeBase

# РЎС‚СЂРѕРіР°СЏ СЃС…РµРјР° РёРјРµРЅ вЂ” РІР°Р¶РЅРѕ РґР»СЏ Alembic Рё РІРѕСЃРїСЂРѕРёР·РІРѕРґРёРјРѕСЃС‚Рё РјРёРіСЂР°С†РёР№
naming_convention = {
    "ix": "ix_%(table_name)s_%(column_0_N_name)s",
    "uq": "uq_%(table_name)s_%(column_0_N_name)s",
    "ck": "ck_%(table_name)s_%(constraint_name)s",
    "fk": "fk_%(table_name)s_%(column_0_N_name)s_%(referred_table_name)s",
    "pk": "pk_%(table_name)s",
}


class Base(DeclarativeBase):
    """Р‘Р°Р·РѕРІС‹Р№ РєР»Р°СЃСЃ РјРѕРґРµР»РµР№ SQLAlchemy СЃ РµРґРёРЅС‹Рј MetaData Рё РєРѕРЅРІРµРЅС†РёРµР№ РёРјРµРЅ."""
    metadata = MetaData(naming_convention=naming_convention)

    def __repr__(self) -> str:
        mapper = self.__class__.__mapper__
        pk_cols = [c.key for c in mapper.primary_key]
        pk_vals = ", ".join(f"{k}={getattr(self, k)!r}" for k in pk_cols)
        return f"<{self.__class__.__name__} {pk_vals}>"



/* ===== C:\Users\icipa\team-platform-public\id_service\db\init_db.py ===== */

# id_service/db/init_db.py

import logging
from datetime import datetime, timezone
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from core.config import settings
from core.security import security
from models import Client, ClientType, User


logger = logging.getLogger(__name__)


async def init_db(session: AsyncSession) -> None:
    """Seed С‚РѕР»СЊРєРѕ РґР»СЏ dev. Р’ РїСЂРѕРґРµ вЂ” РјРёРіСЂР°С†РёРё Alembic Рё РЅРёРєР°РєРѕРіРѕ create_all."""
    if settings.APP_ENV != "development":
        return

    result = await session.execute(select(Client).limit(1))
    if result.scalar_one_or_none():
        logger.info("Database already initialized")
        return

    logger.info("Creating initial data for development...")
    
    # Create local development clients
    clients_data = [
        {
            "client_id": settings.TEACH_CLIENT_ID,
            "name": "Teach Service (Local)",
            "type": ClientType.PUBLIC,
            "redirect_uris": [
                "http://localhost:3001/callback",
                "http://teach.localhost:3001/callback"
            ],
            "post_logout_redirect_uris": [
                "http://localhost:3001",
                "http://teach.localhost:3001"
            ],
            "backchannel_logout_uri": "http://localhost:3001/backchannel-logout",
            "frontchannel_logout_uri": "http://localhost:3001/frontchannel-logout",
            "scopes": ["openid", "email", "profile", "offline_access"]
        },
        {
            "client_id": settings.RUN_CLIENT_ID,
            "name": "Run Service (Local)",
            "type": ClientType.PUBLIC,
            "redirect_uris": [
                "http://localhost:3002/callback",
                "http://run.localhost:3002/callback"
            ],
            "post_logout_redirect_uris": [
                "http://localhost:3002",
                "http://run.localhost:3002"
            ],
            "backchannel_logout_uri": "http://localhost:3002/backchannel-logout",
            "frontchannel_logout_uri": "http://localhost:3002/frontchannel-logout",
            "scopes": ["openid", "email", "profile", "offline_access"]
        },
        {
            "client_id": settings.LEARN_CLIENT_ID,
            "name": "Learn Service (Local)",
            "type": ClientType.PUBLIC,
            "redirect_uris": [
                "http://localhost:3003/callback",
                "http://learn.localhost:3003/callback"
            ],
            "post_logout_redirect_uris": [
                "http://localhost:3003",
                "http://learn.localhost:3003"
            ],
            "backchannel_logout_uri": "http://localhost:3003/backchannel-logout",
            "frontchannel_logout_uri": "http://localhost:3003/frontchannel-logout",
            "scopes": ["openid", "email", "profile", "offline_access"]
        }
    ]
    
    for client_data in clients_data:
        session.add(Client(**client_data))
    
    test_user = User(
        email="test@asynq.ru",
        username="testuser",
        password_hash=security.hash_password("Test123!"),
        email_verified=True,
        created_at=datetime.now(timezone.utc)
    )
    session.add(test_user)

    await session.commit()
    logger.info("Dev data created")


/* ===== C:\Users\icipa\team-platform-public\id_service\db\session.py ===== */

# id_service/db/session.py
from __future__ import annotations

from typing import AsyncGenerator

from sqlalchemy.ext.asyncio import (
    AsyncEngine,
    AsyncSession,
    async_sessionmaker,
    create_async_engine,
)

from core.config import settings

# Async SQLAlchemy engine
engine: AsyncEngine = create_async_engine(
    settings.DATABASE_URL,
    echo=settings.DB_ECHO,
    pool_pre_ping=True,
    pool_size=10,
    max_overflow=20,
    future=True,
)

# Session factory
async_session_maker = async_sessionmaker(
    bind=engine,
    class_=AsyncSession,
    expire_on_commit=False,
    autoflush=False,
)

# FastAPI dependency
async def get_async_session() -> AsyncGenerator[AsyncSession, None]:
    async with async_session_maker() as session:
        try:
            yield session
            await session.commit()
        except Exception:
            await session.rollback()
            raise



/* ===== C:\Users\icipa\team-platform-public\id_service\Dockerfile ===== */

# id_service/Dockerfile

FROM python:3.11-slim

ENV PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    PYTHONPATH=/id_service \
    DEBIAN_FRONTEND=noninteractive

WORKDIR /id_service

# Install system dependencies
RUN set -eux; \
    if [ -f /etc/apt/sources.list ]; then \
      sed -i -E 's|http://deb.debian.org|https://deb.debian.org|g' /etc/apt/sources.list; \
    fi; \
    if [ -f /etc/apt/sources.list.d/debian.sources ]; then \
      sed -i -E 's|http://deb.debian.org|https://deb.debian.org|g' /etc/apt/sources.list.d/debian.sources; \
    fi; \
    printf 'Acquire::Retries "5";\n' > /etc/apt/apt.conf.d/80-retries; \
    apt-get update; \
    apt-get install -y --no-install-recommends ca-certificates curl postgresql-client \
    || (sleep 2; apt-get update && apt-get install -y --no-install-recommends --fix-missing ca-certificates curl postgresql-client); \
    rm -rf /var/lib/apt/lists/*

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

# Make init script executable
RUN [ -f ./init_db.sh ] && sed -i 's/\r$//' ./init_db.sh && chmod +x ./init_db.sh || true

# Install package if setup.py exists
RUN if [ -f pyproject.toml ] || [ -f setup.py ]; then pip install -e .; fi

CMD ["sh","-lc","alembic upgrade head && uvicorn main:app --host 0.0.0.0 --port 8000 --workers 4 --proxy-headers --forwarded-allow-ips='*'"]



/* ===== C:\Users\icipa\team-platform-public\id_service\main.py ===== */

# id_service/main.py
"""
Р“Р»Р°РІРЅС‹Р№ РјРѕРґСѓР»СЊ FastAPI.

Р”РѕР±Р°РІР»РµРЅРѕ:
- Р“Р»РѕР±Р°Р»СЊРЅС‹Рµ JSON-С…РµРЅРґР»РµСЂС‹ РѕС€РёР±РѕРє:
  * HTTPException в†’ {"error":{"code", "message", "details?"}}
  * RequestValidationError в†’ {"error":{"code":422, "message":"Validation error", "details":[...]}}
- JSONContentTypeMiddleware: РґР»СЏ РЅРµР±РµР·РѕРїР°СЃРЅС‹С… РјРµС‚РѕРґРѕРІ РїРѕРґ /auth/** Рё /account/** С‚СЂРµР±СѓРµРј Content-Type: application/json
  (РёСЃРєР»СЋС‡РµРЅРёРµ: /auth/csrf).
- AuthCacheHeadersMiddleware: РЅР° /auth/** Рё /oidc/** РІС‹СЃС‚Р°РІР»СЏРµРј Cache-Control: no-store Рё Pragma: no-cache
  (РёСЃРєР»СЋС‡РµРЅРёСЏ: discovery Рё jwks).
РџРѕСЂСЏРґРѕРє middleware: SecurityHeaders в†’ JSONContentType в†’ CSRF в†’ AuthCacheHeaders в†’ CORS в†’ TrustedHost(prod).
"""

import logging
from contextlib import asynccontextmanager

from fastapi import FastAPI, Request, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from starlette.middleware.base import BaseHTTPMiddleware

from utils.csrf import csrf_protection
from core.config import settings
from db.init_db import init_db
from db.session import async_session_maker, engine
from db.base import Base
from services.jwk_service import jwk_service
from services.backchannel_logout import backchannel_logout_service
from utils import rate_limiter, setup_logging

# Routers
from api.oidc import discovery, authorize, token, userinfo, logout, jwks, revoke
from api.auth import register, login, password_reset, email_verification
from api.auth import csrf as csrf_api
from api.account import profile, email_change, password_change, delete_account
from api import health

from pydantic import ValidationError

# Logging
logger = setup_logging()


@asynccontextmanager
async def lifespan(app: FastAPI):
    """РРЅРёС†РёР°Р»РёР·Р°С†РёСЏ РїСЂРёР»РѕР¶РµРЅРёСЏ РЅР° СЃС‚Р°СЂС‚Рµ."""
    logger.info("Starting ID Service...")

    # РРЅРёС†РёР°Р»РёР·Р°С†РёСЏ Р‘Р”/СЃРµСЂРІРёСЃРѕРІ
    async with async_session_maker() as session:
        await init_db(session)
    await jwk_service.ensure_active_key()
    await rate_limiter.init()

    yield

    # Cleanup
    logger.info("Shutting down ID Service...")
    await backchannel_logout_service.cleanup()
    await rate_limiter.close()
    await engine.dispose()


app = FastAPI(
    title="ID Service",
    description="OpenID Connect Identity Provider for asynq.ru",
    version="1.0.0",
    docs_url="/docs" if settings.APP_ENV == "development" else None,
    redoc_url="/redoc" if settings.APP_ENV == "development" else None,
    lifespan=lifespan,
)

# ---------------------------
# Global middlewares
# ---------------------------

class SecurityHeadersMiddleware(BaseHTTPMiddleware):
    """Р‘Р°Р·РѕРІС‹Рµ security-Р·Р°РіРѕР»РѕРІРєРё РЅР° РІСЃРµ РѕС‚РІРµС‚С‹."""
    async def dispatch(self, request, call_next):
        resp = await call_next(request)
        resp.headers.setdefault("X-Frame-Options", "DENY")
        resp.headers.setdefault("X-Content-Type-Options", "nosniff")
        resp.headers.setdefault("Referrer-Policy", "no-referrer")
        if settings.APP_ENV == "production":
            resp.headers.setdefault("Strict-Transport-Security", "max-age=31536000; includeSubDomains; preload")
        return resp


class JSONContentTypeMiddleware(BaseHTTPMiddleware):
    """Р”Р»СЏ /auth/** Рё /account/** С‚СЂРµР±СѓРµРј JSON РЅР° РЅРµР±РµР·РѕРїР°СЃРЅС‹С… РјРµС‚РѕРґР°С…."""
    def _needs_json(self, path: str) -> bool:
        if path == "/auth/csrf":
            return False
        return path.startswith("/auth/") or path.startswith("/account/")

    async def dispatch(self, request: Request, call_next):
        if request.method in {"POST", "PUT", "PATCH", "DELETE"} and self._needs_json(request.url.path):
            ct = request.headers.get("content-type", "")
            if "application/json" not in ct.lower():
                # 415 Unsupported Media Type вЂ” СЏРІРЅС‹Р№ СЃРёРіРЅР°Р» РєР»РёРµРЅС‚Сѓ
                return JSONResponse(
                    {"error": {"code": 415, "message": "Content-Type must be application/json", "details": {"required": "application/json"}}},
                    status_code=415,
                )
        return await call_next(request)


class CSRFMiddleware(BaseHTTPMiddleware):
    """РџСЂРѕРІРµСЂРєР° CSRF РїРѕ Р·Р°РіРѕР»РѕРІРєСѓ X-CSRF-Token (double-submit cookie)."""
    async def dispatch(self, request, call_next):
        if csrf_protection.should_check_csrf(request):
            await csrf_protection.validate_token(request)
        return await call_next(request)


class AuthCacheHeadersMiddleware(BaseHTTPMiddleware):
    """РћС‚РєР»СЋС‡Р°РµРј РєСЌС€ РґР»СЏ /auth/** Рё OIDC-СЌРЅРґРїРѕРёРЅС‚РѕРІ.
    РСЃРєР»СЋС‡РµРЅРёСЏ: discovery Рё jwks.
    """
    DISCOVERY = "/.well-known/openid-configuration"
    JWKS = "/.well-known/jwks.json"
    OIDC_PATHS = {
        "/authorize",
        "/token",
        "/revoke",
        "/userinfo",
        "/logout",
    }

    async def dispatch(self, request: Request, call_next):
        resp = await call_next(request)
        path = request.url.path

        is_auth = path.startswith("/auth/")
        # СѓС‡РёС‚С‹РІР°РµРј РєР°Рє РєРѕСЂРЅРµРІС‹Рµ OIDC РїСѓС‚Рё, С‚Р°Рє Рё РіРёРїРѕС‚РµС‚РёС‡РµСЃРєРёР№ РїСЂРµС„РёРєСЃ /oidc/
        is_oidc = path in self.OIDC_PATHS or path.startswith("/oidc/")
        is_static = path in {self.DISCOVERY, self.JWKS}

        if (is_auth or is_oidc) and not is_static:
            resp.headers.setdefault("Cache-Control", "no-store")
            resp.headers.setdefault("Pragma", "no-cache")
        return resp



# РџРѕСЂСЏРґРѕРє РёРјРµРµС‚ Р·РЅР°С‡РµРЅРёРµ
app.add_middleware(SecurityHeadersMiddleware)
app.add_middleware(JSONContentTypeMiddleware)
app.add_middleware(CSRFMiddleware)
app.add_middleware(AuthCacheHeadersMiddleware)
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.CORS_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
if settings.APP_ENV == "production":
    app.add_middleware(TrustedHostMiddleware, allowed_hosts=["id.asynq.ru", "*.asynq.ru"])


# ---------------------------
# Routers
# ---------------------------

# OIDC endpoints
app.include_router(discovery.router, tags=["OIDC Discovery"])
app.include_router(jwks.router, tags=["OIDC JWKS"])
app.include_router(authorize.router, tags=["OIDC Authorization"])
app.include_router(token.router, tags=["OIDC Token"])
app.include_router(userinfo.router, tags=["OIDC UserInfo"])
app.include_router(logout.router, tags=["OIDC Logout"])
app.include_router(revoke.router, tags=["OIDC Token"])

# Auth endpoints
app.include_router(register.router, prefix="/auth", tags=["Authentication"])
app.include_router(login.router, prefix="/auth", tags=["Authentication"])
app.include_router(password_reset.router, prefix="/auth", tags=["Authentication"])
app.include_router(email_verification.router, prefix="/auth", tags=["Authentication"])
app.include_router(csrf_api.router, prefix="/auth", tags=["Authentication"])

# Account management endpoints
app.include_router(profile.router, prefix="/account", tags=["Account"])
app.include_router(email_change.router, prefix="/account", tags=["Account"])
app.include_router(password_change.router, prefix="/account", tags=["Account"])
app.include_router(delete_account.router, prefix="/account", tags=["Account"])

# Health
app.include_router(health.router, tags=["Health"])


@app.get("/")
async def root():
    return {"service": "ID Service", "version": "1.0.0", "issuer": settings.ISSUER}


# ---------------------------
# Global exception handlers
# ---------------------------

@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    """
    РЈРЅРёС„РёС†РёСЂРѕРІР°РЅРЅС‹Рµ JSON-РѕС€РёР±РєРё РґР»СЏ РІСЃРµС… РЅРµ-OAuth СЂСѓС‡РµРє.
    /oidc/token Рё /oidc/revoke СЃР°РјРё С„РѕСЂРјРёСЂСѓСЋС‚ RFC-РѕС€РёР±РєРё Рё СЃСЋРґР° РЅРµ РїРѕРїР°РґСѓС‚,
    С‚.Рє. РІРѕР·РІСЂР°С‰Р°СЋС‚ JSONResponse РЅР°РїСЂСЏРјСѓСЋ.
    """
    payload = {"error": {"code": exc.status_code, "message": exc.detail}}
    return JSONResponse(payload, status_code=exc.status_code)


@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    """Р’Р°Р»РёРґР°С†РёРѕРЅРЅС‹Рµ РѕС€РёР±РєРё Pydantic/FastAPI в†’ РµРґРёРЅС‹Р№ С„РѕСЂРјР°С‚."""
    details = exc.errors()
    payload = {"error": {"code": 422, "message": "Validation error", "details": details}}
    return JSONResponse(payload, status_code=422)

@app.exception_handler(ValidationError)
async def pydantic_validation_handler(request: Request, exc: ValidationError):
    return JSONResponse(
        {"error": {"code": 422, "message": "Validation error", "details": exc.errors()}},
        status_code=422,
    )

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        reload=settings.APP_ENV == "development",
        log_level="debug" if settings.APP_ENV == "development" else "info",
    )



/* ===== C:\Users\icipa\team-platform-public\id_service\models\__init__.py ===== */

# id_service/models/__init__.py

from .user import User
from .client import Client, ClientType, TokenAuthMethod
from .auth_code import AuthCode
from .refresh_token import RefreshToken
from .email_code import EmailCode, EmailCodePurpose
from .jwk_key import JWKKey
from .idp_session import IDPSession

__all__ = [
    "User",
    "Client",
    "ClientType",
    "TokenAuthMethod",
    "AuthCode",
    "RefreshToken",
    "EmailCode",
    "EmailCodePurpose",
    "JWKKey",
    "IDPSession",
]


/* ===== C:\Users\icipa\team-platform-public\id_service\models\auth_code.py ===== */

# id_service/models/auth_code.py

from datetime import datetime
from sqlalchemy import Column, String, DateTime, ForeignKey, Text, Boolean
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
import uuid

from db.base import Base


class AuthCode(Base):
    __tablename__ = "auth_codes"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    code_hash = Column(String(255), unique=True, nullable=False, index=True)
    
    # Relations
    client_id = Column(String(255), ForeignKey("clients.client_id"), nullable=False)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    
    # OIDC parameters
    redirect_uri = Column(Text, nullable=False)
    scope = Column(String(500), nullable=False)
    code_challenge_hash = Column(String(255), nullable=True)  # For PKCE
    nonce = Column(String(255), nullable=True)
    state = Column(String(500), nullable=True)
    
    # Security
    auth_time = Column(DateTime(timezone=True), nullable=False)
    expires_at = Column(DateTime(timezone=True), nullable=False, index=True)
    used_at = Column(DateTime(timezone=True), nullable=True)
    
    # Request info
    ip_address = Column(String(45), nullable=True)
    user_agent = Column(Text, nullable=True)
    
    # Relations
    client = relationship("Client", backref="auth_codes", lazy="joined")
    user = relationship("User", backref="auth_codes", lazy="joined")


/* ===== C:\Users\icipa\team-platform-public\id_service\models\client.py ===== */

# id_service/models/client.py

from datetime import datetime
from typing import Optional
import enum

from sqlalchemy import Column, String, Text, Boolean, DateTime, Index, func, Enum as SAEnum
from sqlalchemy.dialects.postgresql import UUID, JSONB
import uuid

from db.base import Base


class ClientType(str, enum.Enum):
    PUBLIC = "public"
    CONFIDENTIAL = "confidential"


class TokenAuthMethod(str, enum.Enum):
    NONE = "none"
    CLIENT_SECRET_POST = "client_secret_post"
    CLIENT_SECRET_BASIC = "client_secret_basic"


class Client(Base):
    __tablename__ = "clients"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)

    client_id = Column(String(255), unique=True, nullable=False, index=True)
    name = Column(String(255), nullable=False)

    type = Column(
        SAEnum(
            ClientType,
            name="clienttype",
            values_callable=lambda e: [i.value for i in e],
        ),
        nullable=False,
    )
    
    token_endpoint_auth_method = Column(
        SAEnum(
            TokenAuthMethod,
            name="tokenauthmethod",
            values_callable=lambda e: [i.value for i in e],
        ),
        nullable=False,
    )
    
    pkce_required = Column(Boolean, nullable=False, default=True)

    redirect_uris = Column(JSONB, nullable=False, default=list)
    post_logout_redirect_uris = Column(JSONB, nullable=False, default=list)
    backchannel_logout_uri = Column(Text, nullable=True)
    frontchannel_logout_uri = Column(Text, nullable=True)

    scopes = Column(JSONB, nullable=False, default=lambda: ["openid", "email", "profile"])

    client_secret_hash = Column(Text, nullable=True)
    secret_rotated_at = Column(DateTime(timezone=True), nullable=True)

    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now(),
        nullable=False,
    )

    __table_args__ = (
        Index("ux_clients_client_id", "client_id", unique=True),
    )



/* ===== C:\Users\icipa\team-platform-public\id_service\models\email_code.py ===== */

# id_service/models/email_code.py

from datetime import datetime
from sqlalchemy import Column, Text, Index, String, DateTime, ForeignKey, Integer, Enum
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
import uuid
import enum

from db.base import Base


class EmailCodePurpose(str, enum.Enum):
    REGISTER = "register"
    RESET_PASSWORD = "reset"
    CHANGE_EMAIL = "change_email"


class EmailCode(Base):
    __tablename__ = "email_codes"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    
    # Relations
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    
    # Code details
    purpose = Column(Enum(EmailCodePurpose), nullable=False)
    code_hash = Column(String(255), nullable=False)
    new_email = Column(String(255), nullable=True)  # For email change
    
    # Security
    expires_at = Column(DateTime(timezone=True), nullable=False, index=True)
    attempts = Column(Integer, default=0, nullable=False)
    resend_after = Column(DateTime(timezone=True), nullable=False)
    used_at = Column(DateTime(timezone=True), nullable=True)
    
    # Request info
    ip_address = Column(String(45), nullable=True)
    user_agent = Column(Text, nullable=True)
    
    # Relations
    user = relationship("User", backref="email_codes", lazy="joined")
    
    __table_args__ = (
        Index('ix_email_codes_user_purpose', 'user_id', 'purpose', 'expires_at'),
    )


/* ===== C:\Users\icipa\team-platform-public\id_service\models\idp_session.py ===== */

# id_service/models/idp_session.py

from datetime import datetime
from sqlalchemy import Column, String, DateTime, ForeignKey, Text, Index
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
import uuid

from db.base import Base


class IDPSession(Base):
    __tablename__ = "idp_sessions"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    session_id = Column(String(255), unique=True, nullable=False, index=True)  # sid for OIDC
    
    # Relations
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    
    # Session tracking
    last_seen_at = Column(DateTime(timezone=True), nullable=False)
    idle_expires_at = Column(DateTime(timezone=True), nullable=False, index=True)
    max_expires_at = Column(DateTime(timezone=True), nullable=False, index=True)
    
    # Request info
    ip_address = Column(String(45), nullable=True)
    user_agent = Column(Text, nullable=True)
    
    # Status
    created_at = Column(DateTime(timezone=True), nullable=False)
    revoked_at = Column(DateTime(timezone=True), nullable=True)
    
    # Relations
    user = relationship("User", backref="idp_sessions", lazy="joined")
    
    __table_args__ = (
        Index('ix_idp_sessions_user_revoked', 'user_id', 'revoked_at'),
    )


/* ===== C:\Users\icipa\team-platform-public\id_service\models\jwk_key.py ===== */

# id_service/models/jwk_key.py

from datetime import datetime
from sqlalchemy import Column, String, Text, Boolean, DateTime, Index, func
from sqlalchemy.dialects.postgresql import UUID
import uuid

from db.base import Base


class JWKKey(Base):
    __tablename__ = "jwk_keys"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    kid = Column(String(255), unique=True, nullable=False, index=True)  # Key ID
    alg = Column(String(10), nullable=False, default="RS256")
    
    # Key material
    public_pem = Column(Text, nullable=False)
    private_pem_encrypted = Column(Text, nullable=False)  # Encrypted with app secret
    
    # Status
    active = Column(Boolean, default=True, nullable=False)
    
    # Timestamps
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    rotated_at = Column(DateTime(timezone=True), nullable=True)
    expires_at = Column(DateTime(timezone=True), nullable=True)
    
    __table_args__ = (
        Index('ix_jwk_keys_active_kid', 'active', 'kid'),
    )


/* ===== C:\Users\icipa\team-platform-public\id_service\models\refresh_token.py ===== */

# id_service/models/refresh_token.py

from datetime import datetime
from sqlalchemy import Column, String, DateTime, ForeignKey, Text, Index
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
import uuid

from db.base import Base


class RefreshToken(Base):
    __tablename__ = "refresh_tokens"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    jti = Column(String(255), unique=True, nullable=False, index=True)  # JWT ID
    
    # Relations
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    client_id = Column(String(255), ForeignKey("clients.client_id"), nullable=False)
    
    # Token chain (for rotation)
    parent_jti = Column(String(255), nullable=True, index=True)  # Parent token that created this
    prev_jti = Column(String(255), nullable=True)  # Previous token in rotation chain
    
    # Scope
    scope = Column(String(500), nullable=False)
    
    # Timestamps
    created_at = Column(DateTime(timezone=True), nullable=False)
    expires_at = Column(DateTime(timezone=True), nullable=False, index=True)
    rotated_at = Column(DateTime(timezone=True), nullable=True)
    revoked_at = Column(DateTime(timezone=True), nullable=True)
    revoked_reason = Column(String(255), nullable=True)
    
    # Request info
    ip_address = Column(String(45), nullable=True)
    user_agent = Column(Text, nullable=True)
    
    # Relations
    user = relationship("User", backref="refresh_tokens", lazy="joined")
    client = relationship("Client", backref="refresh_tokens", lazy="joined")
    
    __table_args__ = (
        Index('ix_refresh_tokens_user_client', 'user_id', 'client_id', 'revoked_at', 'expires_at'),
    )


/* ===== C:\Users\icipa\team-platform-public\id_service\models\user.py ===== */

# id_service/models/user.py
from __future__ import annotations

import uuid
from sqlalchemy import Column, String, Text, Boolean, Integer, DateTime, Index, func
from sqlalchemy.dialects.postgresql import UUID
from db.base import Base


class User(Base):
    __tablename__ = "users"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)

    # Р›РѕРіРёРЅРЅС‹Рµ РїРѕР»СЏ
    email = Column(String(255), nullable=False)          # С…СЂР°РЅРёРј РІ lower РЅР° СѓСЂРѕРІРЅРµ РїСЂРёР»РѕР¶РµРЅРёСЏ
    username = Column(String(50), nullable=False)

    # Р‘РµР·РѕРїР°СЃРЅРѕСЃС‚СЊ
    password_hash = Column(Text, nullable=False)
    email_verified = Column(Boolean, nullable=False, default=False)
    failed_login_attempts = Column(Integer, nullable=False, default=0)

    # РђСѓРґРёС‚
    last_login_at = Column(DateTime(timezone=True), nullable=True)
    last_password_change_at = Column(DateTime(timezone=True), nullable=True)

    # РўР°Р№РјСЃС‚РµРјРїС‹ Рё soft-delete
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)
    deleted_at = Column(DateTime(timezone=True), nullable=True)

    __table_args__ = (
        # case-insensitive СѓРЅРёРєР°Р»СЊРЅРѕСЃС‚СЊ e-mail
        Index("ux_users_email_lower", func.lower(email), unique=True),
        Index("ux_users_username", "username", unique=True),
    )



/* ===== C:\Users\icipa\team-platform-public\id_service\requirements.txt ===== */

# id_service/requirements.txt

# Core
fastapi==0.115.0
uvicorn[standard]==0.32.0
pydantic==2.9.2
pydantic-settings==2.6.0

# Database
sqlalchemy==2.0.35
asyncpg==0.30.0
alembic==1.14.0

# Redis
redis==5.2.0

# Security & Auth
authlib==1.3.2
python-jose[cryptography]==3.3.0
argon2-cffi==23.1.0
cryptography==43.0.3

# HTTP & Forms
python-multipart==0.0.12
httpx==0.27.2

# Email
aiosmtplib==3.0.2
email-validator==2.2.0
jinja2==3.1.4

# Utilities
python-dotenv==1.0.1
itsdangerous==2.2.0

# Development (optional)
pytest==8.3.3
pytest-asyncio==0.24.0
black==24.10.0
ruff==0.7.4


/* ===== C:\Users\icipa\team-platform-public\id_service\schemas\__init__.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\schemas\account.py ===== */

# id_service/schemas/account.py

from pydantic import BaseModel, Field, EmailStr, field_validator, ConfigDict
from pydantic import FieldValidationInfo
from typing import Optional, List
from datetime import datetime

from core.security import security


class ProfileResponse(BaseModel):
    """User profile response schema"""
    email: str
    username: str
    email_verified: bool
    created_at: datetime
    last_login_at: Optional[datetime] = None
    
    model_config = ConfigDict(from_attributes=True)


class ChangeEmailRequest(BaseModel):
    """Change email request schema"""
    new_email: EmailStr = Field(..., description="New email address")
    password: str = Field(..., description="Current password for verification")
    
    model_config = ConfigDict(str_strip_whitespace=True)
    
    @field_validator('new_email')
    @classmethod
    def normalize_email(cls, v: str) -> str:
        return v.lower()


class ChangeEmailResponse(BaseModel):
    """Change email response schema"""
    message: str = "Verification code sent to new email address"


class ConfirmEmailChangeRequest(BaseModel):
    new_email: EmailStr
    code: str = Field(..., pattern=r'^\d{4}$', description="4-digit verification code")
  
    model_config = ConfigDict(str_strip_whitespace=True)
  
    @field_validator('new_email')
    @classmethod
    def normalize_email(cls, v: str) -> str:
        return v.lower()


class ConfirmEmailChangeResponse(BaseModel):
    """Confirm email change response schema"""
    message: str = "Email address updated successfully"


class ChangePasswordRequest(BaseModel):
    """Change password request schema"""
    old_password: str = Field(..., description="Current password")
    new_password: str = Field(..., min_length=8, description="New password")
    new_password_confirm: str = Field(..., description="New password confirmation")
    
    @field_validator('new_password')
    @classmethod
    def validate_password(cls, v: str) -> str:
        valid, error = security.validate_password_strength(v)
        if not valid:
            raise ValueError(error)
        return v
    
    @field_validator('new_password_confirm')
    @classmethod
    def passwords_match(cls, v: str, info: FieldValidationInfo) -> str:
        if info.data.get('new_password') and v != info.data['new_password']:
            raise ValueError('Passwords do not match')
        return v


class ChangePasswordResponse(BaseModel):
    """Change password response schema"""
    message: str = "Password changed successfully"


class DeleteAccountRequest(BaseModel):
    """Delete account request schema"""
    current_password: str
    confirmation: str = Field(..., pattern=r'^DELETE$', description="Type DELETE to confirm")


class DeleteAccountResponse(BaseModel):
    """Delete account response schema"""
    message: str = "Account has been deleted"


/* ===== C:\Users\icipa\team-platform-public\id_service\schemas\auth.py ===== */

# id_service/schemas/auth.py
"""
РЎС…РµРјС‹ (Pydantic v2) РґР»СЏ auth-С„Р»РѕСѓ.
Р’Р°Р¶РЅРѕ:
- Р’СЃРµ СЂСѓС‡РєРё, РєСЂРѕРјРµ /oidc/token Рё /oidc/revoke, СЂР°Р±РѕС‚Р°СЋС‚ РІ JSON.
- Р—РґРµСЃСЊ РѕРїРёСЃС‹РІР°РµРј С‚РѕР»СЊРєРѕ СЃС‚СЂСѓРєС‚СѓСЂС‹ Р·Р°РїСЂРѕСЃРѕРІ/РѕС‚РІРµС‚РѕРІ Рё РІР°Р»РёРґР°С†РёСЋ РїРѕР»РµР№.
"""

from pydantic import BaseModel, EmailStr, ConfigDict
from typing import Optional
from datetime import datetime
from pydantic import field_validator, FieldValidationInfo, Field

from utils.validators import validators
from core.security import security


# ---------------------------
# Р РµРіРёСЃС‚СЂР°С†РёСЏ
# ---------------------------

class RegisterRequest(BaseModel):
    """Р—Р°РїСЂРѕСЃ РЅР° СЂРµРіРёСЃС‚СЂР°С†РёСЋ."""
    username: str = Field(..., min_length=3, max_length=30, description="Username")
    email: EmailStr = Field(..., description="Email address")
    password: str = Field(..., min_length=8, description="Password")
    password_confirm: str = Field(..., description="Password confirmation")

    # РћР±С‰РёРµ РЅР°СЃС‚СЂРѕР№РєРё РјРѕРґРµР»Рё
    model_config = ConfigDict(str_strip_whitespace=True)

    @field_validator('username')
    @classmethod
    def validate_username(cls, v: str) -> str:
        ok, err = validators.validate_username(v)
        if not ok:
            raise ValueError(err)
        return v

    @field_validator('email')
    @classmethod
    def normalize_email(cls, v: str) -> str:
        return v.lower()

    @field_validator('password')
    @classmethod
    def validate_password(cls, v: str) -> str:
        ok, err = security.validate_password_strength(v)
        if not ok:
            raise ValueError(err)
        return v

    @field_validator('password_confirm')
    @classmethod
    def passwords_match(cls, v: str, info: FieldValidationInfo) -> str:
        if info.data.get('password') and v != info.data['password']:
            raise ValueError('Passwords do not match')
        return v


class RegisterResponse(BaseModel):
    """РћС‚РІРµС‚ РЅР° СЂРµРіРёСЃС‚СЂР°С†РёСЋ."""
    user_id: str
    message: str = "Registration successful. Please check your email for verification code."


# ---------------------------
# РџРѕРґС‚РІРµСЂР¶РґРµРЅРёРµ e-mail (OTP)
# ---------------------------

class VerifyEmailRequest(BaseModel):
    """РџРѕРґС‚РІРµСЂР¶РґРµРЅРёРµ e-mail РїРѕ OTP-РєРѕРґСѓ.
    Р”РѕРїРѕР»РЅРёС‚РµР»СЊРЅРѕ РїРѕРґРґРµСЂР¶РёРІР°РµС‚ state РґР»СЏ Р·Р°РІРµСЂС€РµРЅРёСЏ pending /authorize.
    """
    user_id: str = Field(..., description="User ID from registration")
    code: str = Field(..., pattern=r'^\d{4}$', description="4-digit verification code")
    state: Optional[str] = None

    model_config = ConfigDict(str_strip_whitespace=True)


class VerifyEmailResponse(BaseModel):
    """РћС‚РІРµС‚ РЅР° РІРµСЂРёС„РёРєР°С†РёСЋ e-mail."""
    ok: bool = True
    message: str = "Email verified successfully"
    redirect_to: Optional[str] = None  # РґР»СЏ SPA-СЂРµРґРёСЂРµРєС‚Р° Р±РµР· 302


# ---------------------------
# Р›РѕРіРёРЅ РїРѕ РїР°СЂРѕР»СЋ (JSON-only)
# ---------------------------

class LoginPasswordRequest(BaseModel):
    """Р—Р°РїСЂРѕСЃ Р»РѕРіРёРЅР° РїРѕ РїР°СЂРѕР»СЋ.
    JSON-only. Р¤РѕСЂРјС‹ РЅРµ РёСЃРїРѕР»СЊР·СѓСЋС‚СЃСЏ.
    Р•СЃР»Рё РїРµСЂРµРґР°РЅС‹ client_id+state Рё РІ Redis РµСЃС‚СЊ pending authreq вЂ” РІРµСЂРЅС‘Рј redirect_to.
    """
    email: EmailStr = Field(..., description="Email address")
    password: str = Field(..., description="Password")
    remember_me: bool = Field(default=False, description="Extended session duration")
    # Р”РѕРїРѕР»РЅРёС‚РµР»СЊРЅРѕ РґР»СЏ OIDC РїСЂРѕРґРѕР»Р¶РµРЅРёСЏ (РѕРїС†РёРѕРЅР°Р»СЊРЅРѕ):
    client_id: Optional[str] = Field(default=None, description="OIDC client_id for pending /authorize")
    state: Optional[str] = Field(default=None, description="State from pending /authorize")

    model_config = ConfigDict(str_strip_whitespace=True)

    @field_validator('email')
    @classmethod
    def normalize_email(cls, v: str) -> str:
        return v.lower()


class LoginPasswordResponse(BaseModel):
    """РћС‚РІРµС‚ РЅР° Р»РѕРіРёРЅ РїРѕ РїР°СЂРѕР»СЋ."""
    ok: bool = True
    message: str = "Login successful"
    redirect_to: Optional[str] = None  # SPA-СЂРµРґРёСЂРµРєС‚ Р±РµР· 302, Р»РёР±Рѕ null


# ---------------------------
# РЎР±СЂРѕСЃ РїР°СЂРѕР»СЏ (OTP в†’ reset_token)
# ---------------------------

class ForgotPasswordRequest(BaseModel):
    """Р—Р°РїСЂРѕСЃ РЅР° РѕС‚РїСЂР°РІРєСѓ РєРѕРґР° РґР»СЏ СЃР±СЂРѕСЃР° РїР°СЂРѕР»СЏ."""
    email: EmailStr = Field(..., description="Email address")

    model_config = ConfigDict(str_strip_whitespace=True)

    @field_validator('email')
    @classmethod
    def normalize_email(cls, v: str) -> str:
        return v.lower()


class ForgotPasswordResponse(BaseModel):
    """РћС‚РІРµС‚ РЅР° Р·Р°РїСЂРѕСЃ СЃР±СЂРѕСЃР° РїР°СЂРѕР»СЏ.
    РўРµРєСЃС‚ РѕРґРёРЅР°РєРѕРІС‹Р№, С‡С‚РѕР±С‹ РЅРµ СЂР°СЃРєСЂС‹РІР°С‚СЊ РЅР°Р»РёС‡РёРµ Р°РєРєР°СѓРЅС‚Р°.
    """
    message: str = "If an account exists with this email, a reset code has been sent"


class VerifyResetRequest(BaseModel):
    """РџРѕРґС‚РІРµСЂР¶РґРµРЅРёРµ РєРѕРґР° РґР»СЏ СЃР±СЂРѕСЃР° РїР°СЂРѕР»СЏ."""
    email: EmailStr = Field(..., description="Email address")
    code: str = Field(..., pattern=r'^\d{4}$', description="4-digit reset code")

    model_config = ConfigDict(str_strip_whitespace=True)

    @field_validator('email')
    @classmethod
    def normalize_email(cls, v: str) -> str:
        return v.lower()


class VerifyResetResponse(BaseModel):
    """РћС‚РІРµС‚ СЃ reset_token РґР»СЏ СѓСЃС‚Р°РЅРѕРІРєРё РЅРѕРІРѕРіРѕ РїР°СЂРѕР»СЏ."""
    user_id: str
    reset_token: str


class SetNewPasswordRequest(BaseModel):
    """РЈСЃС‚Р°РЅРѕРІРєР° РЅРѕРІРѕРіРѕ РїР°СЂРѕР»СЏ РїРѕСЃР»Рµ СѓСЃРїРµС€РЅРѕР№ РІРµСЂРёС„РёРєР°С†РёРё СЃР±СЂРѕСЃР°."""
    user_id: str = Field(..., description="User ID from reset verification")
    reset_token: str = Field(..., description="Reset token from verification")
    new_password: str = Field(..., min_length=8, description="New password")
    new_password_confirm: str = Field(..., description="New password confirmation")

    @field_validator('new_password')
    @classmethod
    def validate_password(cls, v: str) -> str:
        ok, err = security.validate_password_strength(v)
        if not ok:
            raise ValueError(err)
        return v

    @field_validator('new_password_confirm')
    @classmethod
    def passwords_match(cls, v: str, info: FieldValidationInfo) -> str:
        if info.data.get('new_password') and v != info.data['new_password']:
            raise ValueError('Passwords do not match')
        return v


class SetNewPasswordResponse(BaseModel):
    """РћС‚РІРµС‚ РЅР° СѓСЃРїРµС€РЅСѓСЋ СѓСЃС‚Р°РЅРѕРІРєСѓ РЅРѕРІРѕРіРѕ РїР°СЂРѕР»СЏ."""
    message: str = "Password has been reset successfully"



/* ===== C:\Users\icipa\team-platform-public\id_service\schemas\oidc.py ===== */

# id_service/schemas/oidc.py
"""
РЎС…РµРјС‹ (Pydantic v2) РґР»СЏ OIDC.
Р’Р°Р¶РЅРѕ:
- /oidc/logout С‚РµРїРµСЂСЊ РёРјРµРµС‚ JSON-РІР°СЂРёР°РЅС‚ (POST) СЃ С‚РµР»РѕРј/РѕС‚РІРµС‚РѕРј РЅРёР¶Рµ.
- /oidc/token Рё /oidc/revoke РѕСЃС‚Р°СЋС‚СЃСЏ RFC-СЃРѕРІРјРµСЃС‚РёРјС‹РјРё Рё СЃРІРѕРё РѕС€РёР±РєРё С„РѕСЂРјРёСЂСѓСЋС‚ СЃР°РјРё.
"""

from __future__ import annotations

from typing import List, Optional
from pydantic import BaseModel, ConfigDict, Field


# ---------------------------
# OIDC Discovery
# ---------------------------

class DiscoveryResponse(BaseModel):
    issuer: str
    authorization_endpoint: str
    token_endpoint: str
    userinfo_endpoint: str
    jwks_uri: str
    end_session_endpoint: str

    response_types_supported: List[str]
    grant_types_supported: List[str]
    scopes_supported: List[str]
    id_token_signing_alg_values_supported: List[str]
    subject_types_supported: List[str]
    token_endpoint_auth_methods_supported: List[str]
    code_challenge_methods_supported: List[str]
    claims_supported: List[str]

    frontchannel_logout_supported: bool
    backchannel_logout_supported: bool
    backchannel_logout_session_supported: bool


# ---------------------------
# UserInfo
# ---------------------------

class UserInfoResponse(BaseModel):
    sub: str
    email: Optional[str] = None
    email_verified: Optional[bool] = None
    preferred_username: Optional[str] = None
    updated_at: Optional[int] = None

    model_config = ConfigDict(from_attributes=True)


# ---------------------------
# RP-Initiated Logout (JSON)
# ---------------------------

class LogoutRequest(BaseModel):
    """JSON-Р·Р°РїСЂРѕСЃ РЅР° Р»РѕРіР°СѓС‚ РїРѕ OIDC.
    РџСЂРёРјРµС‡Р°РЅРёРµ: post_logout_redirect_uri РІР°Р»РёРґРёСЂСѓРµС‚СЃСЏ РїРѕ РєР»РёРµРЅС‚Сѓ РёР· id_token_hint.
    """
    id_token_hint: Optional[str] = Field(
        default=None,
        description="ID Token РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ РґР»СЏ РѕРїСЂРµРґРµР»РµРЅРёСЏ РєР»РёРµРЅС‚Р° Рё РІР°Р»РёРґР°С†РёРё post_logout_redirect_uri"
    )
    post_logout_redirect_uri: Optional[str] = Field(
        default=None,
        description="РљСѓРґР° СЂРµРґРёСЂРµРєС‚РёС‚СЊ РїРѕСЃР»Рµ Р»РѕРіР°СѓС‚Р°, РµСЃР»Рё РІР°Р»РёРґРµРЅ РґР»СЏ РєР»РёРµРЅС‚Р°"
    )
    state: Optional[str] = Field(
        default=None,
        description="РћРїС†РёРѕРЅР°Р»СЊРЅРѕРµ СЃРѕСЃС‚РѕСЏРЅРёРµ, РІРµСЂРЅС‘С‚СЃСЏ РєР°Рє РїР°СЂР°РјРµС‚СЂ РІ redirect_to"
    )


class LogoutResponse(BaseModel):
    """JSON-РѕС‚РІРµС‚ Р»РѕРіР°СѓС‚Р°.
    redirect_to: Р°Р±СЃРѕР»СЋС‚РЅС‹Р№ URL РёР»Рё null. Р¤СЂРѕРЅС‚ СЃР°Рј РІС‹РїРѕР»РЅРёС‚ РїРµСЂРµС…РѕРґ, 302 РЅРµС‚.
    """
    ok: bool = True
    redirect_to: Optional[str] = None



/* ===== C:\Users\icipa\team-platform-public\id_service\schemas\token.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\schemas\user.py ===== */

# id_service/schemas/user.py
from __future__ import annotations

from typing import Optional
from datetime import datetime

from pydantic import BaseModel, EmailStr, Field, field_validator, ConfigDict, FieldValidationInfo

from utils.validators import validators
from core.security import security


class UserBase(BaseModel):
    email: EmailStr
    username: str = Field(min_length=3, max_length=30)

    model_config = ConfigDict(str_strip_whitespace=True)

    @field_validator("email")
    @classmethod
    def normalize_email(cls, v: str) -> str:
        return v.lower()

    @field_validator("username")
    @classmethod
    def validate_username(cls, v: str) -> str:
        ok, err = validators.validate_username(v)
        if not ok:
            raise ValueError(err)
        return v


class UserCreate(UserBase):
    password: str = Field(min_length=8)
    email_verified: bool = False

    @field_validator("password")
    @classmethod
    def validate_password(cls, v: str) -> str:
        ok, err = security.validate_password_strength(v)
        if not ok:
            raise ValueError(err)
        return v


class UserUpdate(BaseModel):
    email: Optional[EmailStr] = None
    username: Optional[str] = Field(default=None, min_length=3, max_length=30)
    email_verified: Optional[bool] = None

    model_config = ConfigDict(str_strip_whitespace=True)

    @field_validator("email")
    @classmethod
    def normalize_email(cls, v: Optional[str]) -> Optional[str]:
        return v.lower() if v else v

    @field_validator("username")
    @classmethod
    def validate_username(cls, v: Optional[str]) -> Optional[str]:
        if v is None:
            return v
        ok, err = validators.validate_username(v)
        if not ok:
            raise ValueError(err)
        return v


class UserRead(BaseModel):
    id: str
    email: str
    username: str
    email_verified: bool
    created_at: datetime
    updated_at: Optional[datetime] = None
    last_login_at: Optional[datetime] = None

    model_config = ConfigDict(from_attributes=True)



/* ===== C:\Users\icipa\team-platform-public\id_service\services\__init__.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\services\auth_service.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\services\backchannel_logout.py ===== */

# id_service/services/backchannel_logout.py

import asyncio
import logging
import secrets
from datetime import datetime, timezone
from typing import List, Optional, Dict, Any
from jose import jwt
import httpx
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_
from db.session import async_session_maker

from models import Client, RefreshToken, User
from core.config import settings
from services.jwk_service import jwk_service

logger = logging.getLogger(__name__)


class BackchannelLogoutService:
    """Service for handling back-channel logout notifications"""
    
    def __init__(self):
        self.http_client = httpx.AsyncClient(
            timeout=httpx.Timeout(10.0),
            limits=httpx.Limits(max_keepalive_connections=5, max_connections=10)
        )
    
    async def __aenter__(self):
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.http_client.aclose()
    
    async def initiate_backchannel_logout(
        self,
        session: Optional[AsyncSession],
        user: User,
        session_id: Optional[str] = None,
        reason: str = "user_logout",
        only_client_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """Initiate back-channel logout for all user's active sessions"""
        owns_session = False
        if session is None:
            owns_session = True
            session_ctx = async_session_maker()
            session = await session_ctx.__aenter__()
        try:
            active_clients = await self._get_user_active_clients(session, user.id, session_id, only_client_id)
            
            if not active_clients:
                logger.info(f"No active clients found for user {user.id}")
                return {"notified_clients": [], "failed_clients": []}
            
            # Create logout tasks for each client
            tasks = []
            for client in active_clients:
                if client.backchannel_logout_uri:
                    task = self._send_logout_notification(
                        client=client,
                        user=user,
                        session_id=session_id,
                        reason=reason
                    )
                    tasks.append((client.client_id, task))
            
            # Execute all logout notifications concurrently
            notified_clients = []
            failed_clients = []
            
            if tasks:
                results = await asyncio.gather(
                    *[task for _, task in tasks],
                    return_exceptions=True
                )
                
                for (client_id, _), result in zip(tasks, results):
                    if isinstance(result, Exception):
                        logger.error(f"Failed to notify client {client_id}: {result}")
                        failed_clients.append(client_id)
                    elif result:
                        notified_clients.append(client_id)
                    else:
                        failed_clients.append(client_id)
            
            logger.info(
                f"Back-channel logout completed for user {user.id}. "
                f"Notified: {len(notified_clients)}, Failed: {len(failed_clients)}"
            )
        
            return {
                "notified_clients": notified_clients,
                "failed_clients": failed_clients,
                "reason": reason
            }
        finally:
            if owns_session:
                await session_ctx.__aexit__(None, None, None)

    async def _get_user_active_clients(
        self,
        session: AsyncSession,
        user_id: str,
        session_id: Optional[str] = None,
        only_client_id: Optional[str] = None
    ) -> List[Client]:
        """Get all clients with active sessions or tokens for a user"""
        client_ids: set[str] = set()
        clients: list[Client] = []

        q = select(RefreshToken).where(
            and_(
                RefreshToken.user_id == user_id,
                RefreshToken.revoked_at.is_(None),
                RefreshToken.expires_at > datetime.now(timezone.utc)
            )
        )
        if only_client_id:
            q = q.where(RefreshToken.client_id == only_client_id)

        result = await session.execute(q)
        tokens = result.scalars().all()
        for token in tokens:
            if token.client_id not in client_ids:
                cres = await session.execute(select(Client).where(Client.client_id == token.client_id))
                client = cres.scalar_one_or_none()
                if client:
                    client_ids.add(client.client_id)
                    clients.append(client)

        return clients

    
    async def _send_logout_notification(
        self,
        client: Client,
        user: User,
        session_id: Optional[str] = None,
        reason: str = "user_logout"
    ) -> bool:
        """Send logout notification to a single client"""
        
        if not client.backchannel_logout_uri:
            logger.warning(f"Client {client.client_id} has no backchannel logout URI")
            return False
        
        try:
            # Create logout token
            logout_token = await self._create_logout_token(
                client=client,
                user=user,
                session_id=session_id
            )
            
            # Send POST request to client's backchannel logout URI
            response = await self.http_client.post(
                client.backchannel_logout_uri,
                data={"logout_token": logout_token},
                headers={"Content-Type": "application/x-www-form-urlencoded"},
                follow_redirects=False
            )
            
            # Check response
            if response.status_code == 200:
                logger.info(
                    f"Successfully notified client {client.client_id} "
                    f"for user {user.id} logout (reason: {reason})"
                )
                return True
            else:
                logger.warning(
                    f"Client {client.client_id} returned {response.status_code} "
                    f"for logout notification"
                )
                return False
                
        except httpx.TimeoutException:
            logger.error(f"Timeout notifying client {client.client_id}")
            return False
        except Exception as e:
            logger.error(f"Error notifying client {client.client_id}: {e}")
            return False
    
    async def _create_logout_token(
        self,
        client: Client,
        user: User,
        session_id: Optional[str] = None
    ) -> str:
        """Create a logout token according to OIDC Back-Channel Logout spec"""
        
        # Get active JWK key
        jwk_key = await jwk_service.get_active_key()
        if not jwk_key:
            raise RuntimeError("No active JWK key available")
        
        # Decrypt private key
        private_key_pem = jwk_service.decrypt_private_key(jwk_key.private_pem_encrypted)
        
        now = datetime.now(timezone.utc)
        
        # Create logout token claims
        claims = {
            "iss": settings.ISSUER,
            "aud": client.client_id,
            "iat": int(now.timestamp()),
            "jti": secrets.token_urlsafe(16),
            "events": {
                "http://schemas.openid.net/event/backchannel_logout": {}
            }
        }
        
        # Add either sub or sid (or both)
        if session_id:
            claims["sid"] = session_id
        
        claims["sub"] = str(user.id)
        
        # Sign the token
        logout_token = jwt.encode(
            claims,
            private_key_pem,
            algorithm="RS256",
            headers={"kid": jwk_key.kid}
        )
        
        return logout_token
    
    async def cleanup(self):
        """Cleanup HTTP client"""
        await self.http_client.aclose()


# Global instance
backchannel_logout_service = BackchannelLogoutService()


/* ===== C:\Users\icipa\team-platform-public\id_service\services\email_service.py ===== */

# id_service/services/email_service.py

import logging
import aiosmtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from typing import Optional, Dict, Any
from jinja2 import Template

from core.config import settings

logger = logging.getLogger(__name__)


class EmailService:
    """Service for sending emails"""
    
    def __init__(self):
        self.smtp_host = settings.SMTP_HOST
        self.smtp_port = settings.SMTP_PORT
        self.smtp_user = settings.SMTP_USER
        self.smtp_password = settings.SMTP_PASSWORD
        self.smtp_tls = settings.SMTP_TLS
        self.from_email = settings.EMAIL_FROM
    
    async def send_email(
        self,
        to_email: str,
        subject: str,
        html_content: str,
        text_content: Optional[str] = None
    ) -> bool:
        """Send email using SMTP"""
        try:
            # Create message
            message = MIMEMultipart("alternative")
            message["From"] = self.from_email
            message["To"] = to_email
            message["Subject"] = subject
            
            # Add text and HTML parts
            if text_content:
                text_part = MIMEText(text_content, "plain")
                message.attach(text_part)
            
            html_part = MIMEText(html_content, "html")
            message.attach(html_part)
            
            # Send email
            async with aiosmtplib.SMTP(
                hostname=self.smtp_host,
                port=self.smtp_port,
                use_tls=False
            ) as smtp:
                if self.smtp_tls:
                    await smtp.starttls()
                await smtp.login(self.smtp_user, self.smtp_password)
                await smtp.send_message(message)

            logger.info(f"Email sent successfully to {to_email}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to send email to {to_email}: {e}")
            return False
    
    async def send_verification_code(
        self,
        to_email: str,
        username: str,
        code: str,
        purpose: str = "registration"
    ) -> bool:
        """Send verification code email"""
        
        subject_map = {
            "registration": "РџРѕРґС‚РІРµСЂР¶РґРµРЅРёРµ СЂРµРіРёСЃС‚СЂР°С†РёРё РЅР° Asynq",
            "reset": "РЎР±СЂРѕСЃ РїР°СЂРѕР»СЏ РЅР° Asynq",
            "change_email": "РџРѕРґС‚РІРµСЂР¶РґРµРЅРёРµ СЃРјРµРЅС‹ email РЅР° Asynq"
        }
        
        subject = subject_map.get(purpose, "РљРѕРґ РїРѕРґС‚РІРµСЂР¶РґРµРЅРёСЏ Asynq")
        
        html_template = """
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <style>
                body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
                .container { max-width: 600px; margin: 0 auto; padding: 20px; }
                .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; border-radius: 10px 10px 0 0; }
                .content { background: #f7f7f7; padding: 30px; border-radius: 0 0 10px 10px; }
                .code-box { background: white; border: 2px solid #667eea; border-radius: 8px; padding: 20px; text-align: center; margin: 20px 0; }
                .code { font-size: 32px; font-weight: bold; letter-spacing: 8px; color: #667eea; }
                .footer { margin-top: 30px; padding-top: 20px; border-top: 1px solid #e0e0e0; font-size: 12px; color: #666; }
            </style>
        </head>
        <body>
            <div class="container">
                <div class="header">
                    <h1 style="margin: 0;">Asynq ID</h1>
                </div>
                <div class="content">
                    <h2>Р—РґСЂР°РІСЃС‚РІСѓР№С‚Рµ, {{ username }}!</h2>
                    
                    {% if purpose == 'registration' %}
                        <p>РЎРїР°СЃРёР±Рѕ Р·Р° СЂРµРіРёСЃС‚СЂР°С†РёСЋ РЅР° РїР»Р°С‚С„РѕСЂРјРµ Asynq! Р”Р»СЏ Р·Р°РІРµСЂС€РµРЅРёСЏ СЂРµРіРёСЃС‚СЂР°С†РёРё РІРІРµРґРёС‚Рµ РєРѕРґ РїРѕРґС‚РІРµСЂР¶РґРµРЅРёСЏ:</p>
                    {% elif purpose == 'reset' %}
                        <p>Р’С‹ Р·Р°РїСЂРѕСЃРёР»Рё СЃР±СЂРѕСЃ РїР°СЂРѕР»СЏ. РСЃРїРѕР»СЊР·СѓР№С‚Рµ СЌС‚РѕС‚ РєРѕРґ РґР»СЏ РїРѕРґС‚РІРµСЂР¶РґРµРЅРёСЏ:</p>
                    {% elif purpose == 'change_email' %}
                        <p>Р’С‹ Р·Р°РїСЂРѕСЃРёР»Рё СЃРјРµРЅСѓ email Р°РґСЂРµСЃР°. РСЃРїРѕР»СЊР·СѓР№С‚Рµ СЌС‚РѕС‚ РєРѕРґ РґР»СЏ РїРѕРґС‚РІРµСЂР¶РґРµРЅРёСЏ РЅРѕРІРѕРіРѕ Р°РґСЂРµСЃР°:</p>
                    {% endif %}
                    
                    <div class="code-box">
                        <div class="code">{{ code }}</div>
                    </div>
                    
                    <p>РљРѕРґ РґРµР№СЃС‚РІРёС‚РµР»РµРЅ РІ С‚РµС‡РµРЅРёРµ 5 РјРёРЅСѓС‚.</p>
                    
                    <p style="color: #666; font-size: 14px;">
                        Р•СЃР»Рё РІС‹ РЅРµ Р·Р°РїСЂР°С€РёРІР°Р»Рё СЌС‚РѕС‚ РєРѕРґ, РїСЂРѕСЃС‚Рѕ РїСЂРѕРёРіРЅРѕСЂРёСЂСѓР№С‚Рµ СЌС‚Рѕ РїРёСЃСЊРјРѕ.
                    </p>
                    
                    <div class="footer">
                        <p>РЎ СѓРІР°Р¶РµРЅРёРµРј,<br>РљРѕРјР°РЅРґР° Asynq</p>
                        <p>Р­С‚Рѕ Р°РІС‚РѕРјР°С‚РёС‡РµСЃРєРѕРµ СЃРѕРѕР±С‰РµРЅРёРµ, РїРѕР¶Р°Р»СѓР№СЃС‚Р°, РЅРµ РѕС‚РІРµС‡Р°Р№С‚Рµ РЅР° РЅРµРіРѕ.</p>
                    </div>
                </div>
            </div>
        </body>
        </html>
        """
        
        text_template = """
        Р—РґСЂР°РІСЃС‚РІСѓР№С‚Рµ, {{ username }}!
        
        {% if purpose == 'registration' %}
        РЎРїР°СЃРёР±Рѕ Р·Р° СЂРµРіРёСЃС‚СЂР°С†РёСЋ РЅР° РїР»Р°С‚С„РѕСЂРјРµ Asynq! Р”Р»СЏ Р·Р°РІРµСЂС€РµРЅРёСЏ СЂРµРіРёСЃС‚СЂР°С†РёРё РІРІРµРґРёС‚Рµ РєРѕРґ РїРѕРґС‚РІРµСЂР¶РґРµРЅРёСЏ:
        {% elif purpose == 'reset' %}
        Р’С‹ Р·Р°РїСЂРѕСЃРёР»Рё СЃР±СЂРѕСЃ РїР°СЂРѕР»СЏ. РСЃРїРѕР»СЊР·СѓР№С‚Рµ СЌС‚РѕС‚ РєРѕРґ РґР»СЏ РїРѕРґС‚РІРµСЂР¶РґРµРЅРёСЏ:
        {% elif purpose == 'change_email' %}
        Р’С‹ Р·Р°РїСЂРѕСЃРёР»Рё СЃРјРµРЅСѓ email Р°РґСЂРµСЃР°. РСЃРїРѕР»СЊР·СѓР№С‚Рµ СЌС‚РѕС‚ РєРѕРґ РґР»СЏ РїРѕРґС‚РІРµСЂР¶РґРµРЅРёСЏ РЅРѕРІРѕРіРѕ Р°РґСЂРµСЃР°:
        {% endif %}
        
        РљРѕРґ: {{ code }}
        
        РљРѕРґ РґРµР№СЃС‚РІРёС‚РµР»РµРЅ РІ С‚РµС‡РµРЅРёРµ 5 РјРёРЅСѓС‚.
        
        Р•СЃР»Рё РІС‹ РЅРµ Р·Р°РїСЂР°С€РёРІР°Р»Рё СЌС‚РѕС‚ РєРѕРґ, РїСЂРѕСЃС‚Рѕ РїСЂРѕРёРіРЅРѕСЂРёСЂСѓР№С‚Рµ СЌС‚Рѕ РїРёСЃСЊРјРѕ.
        
        РЎ СѓРІР°Р¶РµРЅРёРµРј,
        РљРѕРјР°РЅРґР° Asynq
        """
        
        # Render templates
        html_content = Template(html_template).render(
            username=username,
            code=code,
            purpose=purpose
        )
        
        text_content = Template(text_template).render(
            username=username,
            code=code,
            purpose=purpose
        )
        
        return await self.send_email(
            to_email=to_email,
            subject=subject,
            html_content=html_content,
            text_content=text_content
        )
    
    async def send_password_changed_notification(
        self,
        to_email: str,
        username: str
    ) -> bool:
        """Send notification about password change"""
        
        subject = "Р’Р°С€ РїР°СЂРѕР»СЊ Р±С‹Р» РёР·РјРµРЅРµРЅ"
        
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <style>
                body {{ font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }}
                .container {{ max-width: 600px; margin: 0 auto; padding: 20px; }}
                .header {{ background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; border-radius: 10px 10px 0 0; }}
                .content {{ background: #f7f7f7; padding: 30px; border-radius: 0 0 10px 10px; }}
                .alert {{ background: #fff3cd; border: 1px solid #ffc107; border-radius: 8px; padding: 15px; margin: 20px 0; }}
            </style>
        </head>
        <body>
            <div class="container">
                <div class="header">
                    <h1 style="margin: 0;">Asynq ID</h1>
                </div>
                <div class="content">
                    <h2>Р—РґСЂР°РІСЃС‚РІСѓР№С‚Рµ, {username}!</h2>
                    
                    <div class="alert">
                        <strong>вљ пёЏ Р’Р°Р¶РЅРѕРµ СѓРІРµРґРѕРјР»РµРЅРёРµ Рѕ Р±РµР·РѕРїР°СЃРЅРѕСЃС‚Рё</strong>
                        <p>Р’Р°С€ РїР°СЂРѕР»СЊ Р±С‹Р» СѓСЃРїРµС€РЅРѕ РёР·РјРµРЅРµРЅ.</p>
                    </div>
                    
                    <p>Р•СЃР»Рё РІС‹ РЅРµ РјРµРЅСЏР»Рё РїР°СЂРѕР»СЊ, РЅРµРјРµРґР»РµРЅРЅРѕ СЃРІСЏР¶РёС‚РµСЃСЊ СЃ РЅР°С€РµР№ СЃР»СѓР¶Р±РѕР№ РїРѕРґРґРµСЂР¶РєРё.</p>
                    
                    <p>Р”Р»СЏ РІР°С€РµР№ Р±РµР·РѕРїР°СЃРЅРѕСЃС‚Рё РІСЃРµ Р°РєС‚РёРІРЅС‹Рµ СЃРµСЃСЃРёРё Р±С‹Р»Рё Р·Р°РІРµСЂС€РµРЅС‹. Р’Р°Рј РїРѕС‚СЂРµР±СѓРµС‚СЃСЏ РІРѕР№С‚Рё Р·Р°РЅРѕРІРѕ РЅР° РІСЃРµС… СѓСЃС‚СЂРѕР№СЃС‚РІР°С….</p>
                    
                    <div class="footer" style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e0e0e0; font-size: 12px; color: #666;">
                        <p>РЎ СѓРІР°Р¶РµРЅРёРµРј,<br>РљРѕРјР°РЅРґР° Asynq</p>
                        <p>Р­С‚Рѕ Р°РІС‚РѕРјР°С‚РёС‡РµСЃРєРѕРµ СЃРѕРѕР±С‰РµРЅРёРµ, РїРѕР¶Р°Р»СѓР№СЃС‚Р°, РЅРµ РѕС‚РІРµС‡Р°Р№С‚Рµ РЅР° РЅРµРіРѕ.</p>
                    </div>
                </div>
            </div>
        </body>
        </html>
        """
        
        text_content = f"""
        Р—РґСЂР°РІСЃС‚РІСѓР№С‚Рµ, {username}!
        
        Р’Р°Р¶РЅРѕРµ СѓРІРµРґРѕРјР»РµРЅРёРµ Рѕ Р±РµР·РѕРїР°СЃРЅРѕСЃС‚Рё:
        Р’Р°С€ РїР°СЂРѕР»СЊ Р±С‹Р» СѓСЃРїРµС€РЅРѕ РёР·РјРµРЅРµРЅ.
        
        Р•СЃР»Рё РІС‹ РЅРµ РјРµРЅСЏР»Рё РїР°СЂРѕР»СЊ, РЅРµРјРµРґР»РµРЅРЅРѕ СЃРІСЏР¶РёС‚РµСЃСЊ СЃ РЅР°С€РµР№ СЃР»СѓР¶Р±РѕР№ РїРѕРґРґРµСЂР¶РєРё.
        
        Р”Р»СЏ РІР°С€РµР№ Р±РµР·РѕРїР°СЃРЅРѕСЃС‚Рё РІСЃРµ Р°РєС‚РёРІРЅС‹Рµ СЃРµСЃСЃРёРё Р±С‹Р»Рё Р·Р°РІРµСЂС€РµРЅС‹. Р’Р°Рј РїРѕС‚СЂРµР±СѓРµС‚СЃСЏ РІРѕР№С‚Рё Р·Р°РЅРѕРІРѕ РЅР° РІСЃРµС… СѓСЃС‚СЂРѕР№СЃС‚РІР°С….
        
        РЎ СѓРІР°Р¶РµРЅРёРµРј,
        РљРѕРјР°РЅРґР° Asynq
        """
        
        return await self.send_email(
            to_email=to_email,
            subject=subject,
            html_content=html_content,
            text_content=text_content
        )


email_service = EmailService()


/* ===== C:\Users\icipa\team-platform-public\id_service\services\jwk_service.py ===== */

# id_service/services/jwk_service.py

import json
import base64
import logging
from datetime import datetime, timezone, timedelta
from typing import Optional, Dict, Any, List
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.backends import default_backend
from cryptography.fernet import Fernet
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_

from models import JWKKey
from core.config import settings
from db.session import async_session_maker

logger = logging.getLogger(__name__)


class JWKService:
    """Service for managing JSON Web Keys"""
    
    def __init__(self):
        # Create encryption key from settings
        key = base64.urlsafe_b64encode(settings.JWT_PRIVATE_KEY_PASSWORD.encode()[:32].ljust(32, b'0'))
        self.cipher = Fernet(key)
    
    async def ensure_active_key(self) -> JWKKey:
        """Ensure there's an active JWK key, create if not exists"""
        async with async_session_maker() as session:
            # Check for active key
            result = await session.execute(
                select(JWKKey).where(JWKKey.active == True)
            )
            active_key = result.scalar_one_or_none()
            
            if not active_key:
                logger.info("No active JWK key found, generating new one...")
                active_key = await self.generate_new_key(session)
                await session.commit()
            
            return active_key
    
    async def generate_new_key(self, session: AsyncSession) -> JWKKey:
        """Generate new RSA key pair"""
        # Generate RSA key pair
        private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048,
            backend=default_backend()
        )
        
        # Get PEM representations
        private_pem = private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption()
        )
        
        public_pem = private_key.public_key().public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        )
        
        # Encrypt private key
        encrypted_private = self.cipher.encrypt(private_pem)
        
        # Generate kid
        import secrets
        kid = secrets.token_urlsafe(16)
        
        # Create key record
        jwk_key = JWKKey(
            kid=kid,
            alg="RS256",
            public_pem=public_pem.decode('utf-8'),
            private_pem_encrypted=encrypted_private.decode('utf-8'),
            active=True,
            created_at=datetime.now(timezone.utc)
        )
        
        # Deactivate old keys
        await session.execute(
            select(JWKKey).where(JWKKey.active == True).with_for_update()
        )
        result = await session.execute(
            select(JWKKey).where(JWKKey.active == True)
        )
        old_keys = result.scalars().all()
        for old_key in old_keys:
            old_key.active = False
            old_key.rotated_at = datetime.now(timezone.utc)
        
        session.add(jwk_key)
        return jwk_key
    
    async def get_active_key(self) -> Optional[JWKKey]:
        """Get current active key"""
        async with async_session_maker() as session:
            result = await session.execute(
                select(JWKKey).where(JWKKey.active == True)
            )
            return result.scalar_one_or_none()
    
    async def get_jwks(self) -> Dict[str, Any]:
        async with async_session_maker() as session:
            # РґРµСЂР¶РёРј РїСЂРµРґС‹РґСѓС‰РёРµ РєР»СЋС‡Рё РјРёРЅРёРјСѓРј РґРѕ РёСЃС‚РµС‡РµРЅРёСЏ access/id С‚РѕРєРµРЅРѕРІ
            retention = timedelta(seconds=settings.ACCESS_TOKEN_TTL)
            cutoff = datetime.now(timezone.utc) - retention

            res = await session.execute(
                select(JWKKey).where(
                    or_(
                        JWKKey.active == True,
                        JWKKey.rotated_at >= cutoff
                    )
                )
            )
            keys = res.scalars().all()

            jwks = {"keys": []}
            for key in keys:
                public_key = serialization.load_pem_public_key(
                    key.public_pem.encode("utf-8"),
                    backend=default_backend()
                )
                numbers = public_key.public_numbers()
                def b64u(n: int) -> str:
                    b = n.to_bytes((n.bit_length() + 7) // 8, "big")
                    return base64.urlsafe_b64encode(b).decode().rstrip("=")
                jwks["keys"].append({
                    "kty": "RSA",
                    "use": "sig",
                    "kid": key.kid,
                    "alg": key.alg,
                    "n": b64u(numbers.n),
                    "e": b64u(numbers.e),
                })
            return jwks
        
    def decrypt_private_key(self, encrypted_pem: str) -> bytes:
        """Decrypt private key"""
        return self.cipher.decrypt(encrypted_pem.encode('utf-8'))

    async def get_key_by_kid(self, kid: str) -> Optional[JWKKey]:
        async with async_session_maker() as session:
            res = await session.execute(select(JWKKey).where(JWKKey.kid == kid))
            return res.scalar_one_or_none()
        
    
    def load_public_key(self, public_pem: str):
        return serialization.load_pem_public_key(public_pem.encode("utf-8"))

jwk_service = JWKService()


/* ===== C:\Users\icipa\team-platform-public\id_service\services\session_service.py ===== */

# id_service/services/session_service.py


import secrets
import logging
from datetime import datetime, timezone, timedelta
from typing import Optional, List
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_
from fastapi import Request, Response, Cookie

from models import IDPSession, User
from core.config import settings
from core.security import security

logger = logging.getLogger(__name__)


class SessionService:
    """Service for managing SSO sessions"""
    
    def __init__(self):
        self.cookie_name = "id_session"
        self.cookie_domain = "id.asynq.ru" if settings.APP_ENV == "production" else None
    
    async def create_session(
        self,
        session: AsyncSession,
        user: User,
        request: Request,
        remember_me: bool = False,   # <вЂ” РґРѕР±Р°РІРёР»Рё
    ) -> IDPSession:
        session_id = secrets.token_urlsafe(32)
        now = datetime.now(timezone.utc)

        max_ttl = settings.SSO_MAX_TTL if not remember_me else 30*24*3600

        idp_session = IDPSession(
            session_id=session_id,
            user_id=user.id,
            last_seen_at=now,
            idle_expires_at=now + timedelta(seconds=settings.SSO_IDLE_TTL),
            max_expires_at=now + timedelta(seconds=max_ttl),  # <вЂ” Р±С‹Р»Рѕ SSO_MAX_TTL
            ip_address=request.client.host,
            user_agent=request.headers.get("User-Agent"),
            created_at=now
        )
        session.add(idp_session)
        await session.flush()
        return idp_session

    
    async def get_session(
        self,
        session: AsyncSession,
        session_id: str
    ) -> Optional[IDPSession]:
        """Get valid session by ID"""
        now = datetime.now(timezone.utc)
        
        result = await session.execute(
            select(IDPSession).where(
                and_(
                    IDPSession.session_id == session_id,
                    IDPSession.revoked_at.is_(None),
                    IDPSession.idle_expires_at > now,
                    IDPSession.max_expires_at > now
                )
            )
        )
        
        idp_session = result.scalar_one_or_none()
        
        if idp_session:
            # Update last seen and idle timeout
            idp_session.last_seen_at = now
            idp_session.idle_expires_at = now + timedelta(seconds=settings.SSO_IDLE_TTL)
            await session.flush()
        
        return idp_session
    
    async def get_session_from_cookie(
        self,
        session: AsyncSession,
        request: Request
    ) -> Optional[IDPSession]:
        """Get session from request cookie"""
        session_cookie = request.cookies.get(self.cookie_name)
        if not session_cookie:
            return None
        
        return await self.get_session(session, session_cookie)
    
    def set_session_cookie(
        self,
        response: Response,
        session_id: str,
        max_age: int | None = None,
    ) -> None:
        response.set_cookie(
            key=self.cookie_name,
            value=session_id,
            domain=self.cookie_domain,
            path="/",
            secure=settings.APP_ENV == "production",
            httponly=True,
            samesite="lax",
            max_age=max_age or settings.SSO_MAX_TTL,
        )
    
    def clear_session_cookie(self, response: Response) -> None:
        """Clear SSO session cookie"""
        response.delete_cookie(
            key=self.cookie_name,
            domain=self.cookie_domain,
            path="/"
        )
    
    async def revoke_session(
        self,
        session: AsyncSession,
        idp_session: IDPSession
    ) -> None:
        """Revoke SSO session"""
        idp_session.revoked_at = datetime.now(timezone.utc)
        await session.flush()
    
    async def revoke_all_user_sessions(
        self,
        session: AsyncSession,
        user_id: str
    ) -> List[IDPSession]:
        """Revoke all sessions for a user"""
        result = await session.execute(
            select(IDPSession).where(
                and_(
                    IDPSession.user_id == user_id,
                    IDPSession.revoked_at.is_(None)
                )
            )
        )
        
        sessions = result.scalars().all()
        now = datetime.now(timezone.utc)
        
        for idp_session in sessions:
            idp_session.revoked_at = now
        
        await session.flush()
        return sessions
    
    async def get_active_user_sessions(
        self,
        session: AsyncSession,
        user_id: str
    ) -> List[IDPSession]:
        """Get all active sessions for a user"""
        now = datetime.now(timezone.utc)
        
        result = await session.execute(
            select(IDPSession).where(
                and_(
                    IDPSession.user_id == user_id,
                    IDPSession.revoked_at.is_(None),
                    IDPSession.max_expires_at > now
                )
            )
        )
        
        return result.scalars().all()


session_service = SessionService()


/* ===== C:\Users\icipa\team-platform-public\id_service\services\token_service.py ===== */

# id_service/services/token_service.py

import secrets
import hashlib
import logging
from datetime import datetime, timezone, timedelta
from typing import Optional, Dict, Any, Tuple

from jose import jwt, JWTError
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_
from cryptography.hazmat.primitives import serialization

from db.session import async_session_maker
from models import AuthCode, RefreshToken, User, Client, JWKKey
from core.config import settings
from core.security import security
from services.jwk_service import jwk_service
from services.backchannel_logout import backchannel_logout_service
from services.session_service import session_service

logger = logging.getLogger(__name__)


def _load_public_key(pem: str):
    """Р—Р°РіСЂСѓР·РєР° РїСѓР±Р»РёС‡РЅРѕРіРѕ РєР»СЋС‡Р° РёР· PEM."""
    return serialization.load_pem_public_key(pem.encode("utf-8"))


class TokenService:
    """Service for managing OAuth2/OIDC tokens"""

    async def create_auth_code(
        self,
        session: AsyncSession,
        user: User,
        client: Client,
        redirect_uri: str,
        scope: str,
        state: Optional[str] = None,
        nonce: Optional[str] = None,
        code_challenge: Optional[str] = None,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
    ) -> str:
        """
        РЎРѕР·РґР°С‚СЊ РѕРґРЅРѕСЂР°Р·РѕРІС‹Р№ authorization code СЃ Р±РёРЅРґРёРЅРіР°РјРё (PKCE, redirect_uri, scope, nonce, state).
        РҐСЂР°РЅРёРј С‚РѕР»СЊРєРѕ sha256 РѕС‚ РєРѕРґР°.
        """
        code = secrets.token_urlsafe(32)
        code_hash = hashlib.sha256(code.encode()).hexdigest()
        now = datetime.now(timezone.utc)

        code_challenge_hash = code_challenge
        
        auth_code = AuthCode(
            code_hash=code_hash,
            client_id=client.client_id,
            user_id=user.id,
            redirect_uri=redirect_uri,
            scope=scope,
            code_challenge_hash=code_challenge_hash,
            nonce=nonce,
            state=state,
            auth_time=now,
            expires_at=now + timedelta(seconds=settings.AUTH_CODE_TTL),
            ip_address=ip_address,
            user_agent=user_agent,
        )
        session.add(auth_code)
        await session.flush()
        return code

    async def exchange_auth_code(
        self,
        session: AsyncSession,
        code: str,
        client_id: str,
        redirect_uri: str,
        code_verifier: Optional[str] = None,
    ) -> Tuple[Optional[AuthCode], Optional[str]]:
        """
        РћР±РјРµРЅ authorization code в†’ РїСЂРѕРІРµСЂРєР° СЃСЂРѕРєР°, one-time, PKCE Рё Р±РёРЅРґРёРЅРіРѕРІ.
        Р’РѕР·РІСЂР°С‰Р°РµС‚ РЅР°Р№РґРµРЅРЅС‹Р№ AuthCode РёР»Рё РѕС€РёР±РєСѓ OAuth.
        """
        code_hash = hashlib.sha256(code.encode()).hexdigest()
        now = datetime.now(timezone.utc)

        result = await session.execute(
            select(AuthCode)
            .where(
                and_(
                    AuthCode.code_hash == code_hash,
                    AuthCode.client_id == client_id,
                    AuthCode.redirect_uri == redirect_uri,
                    AuthCode.expires_at > now,
                    AuthCode.used_at.is_(None),
                )
            )
            .with_for_update()
        )
        auth_code = result.scalar_one_or_none()
        if not auth_code:
            logger.warning("Invalid code exchange. client_id=%s", client_id)
            return None, "invalid_grant"

        # PKCE РїСЂРѕРІРµСЂСЏРµРј, РµСЃР»Рё Р±С‹Р» С‡РµР»РµРЅРґР¶
        if auth_code.code_challenge_hash:
            if not code_verifier:
                return None, "invalid_request"
            if not security.verify_code_challenge(code_verifier, auth_code.code_challenge_hash):
                logger.warning("PKCE failed. client_id=%s", client_id)
                return None, "invalid_grant"

        # РїРѕРјРµС‡Р°РµРј РєРѕРґ РёСЃРїРѕР»СЊР·РѕРІР°РЅРЅС‹Рј РІ С‚СЂР°РЅР·Р°РєС†РёРё
        auth_code.used_at = now
        await session.flush()
        return auth_code, None

    async def create_tokens(
        self,
        session: AsyncSession,
        user: User,
        client: Client,
        scope: str,
        nonce: Optional[str] = None,
        auth_time: Optional[datetime] = None,
        session_id: Optional[str] = None,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
    ) -> Dict[str, Any]:
        """
        Р’С‹РїСѓСЃРє access/id/refresh С‚РѕРєРµРЅРѕРІ.
        RS256 СЃ С‚РµРєСѓС‰РёРј Р°РєС‚РёРІРЅС‹Рј РєР»СЋС‡РѕРј. exp/iat вЂ” unix time.
        """
        now = datetime.now(timezone.utc)
        auth_time = auth_time or now
        ts = lambda dt: int(dt.timestamp())
        scopes = set(scope.split())

        # Р°РєС‚РёРІРЅС‹Р№ JWK
        jwk_key = await jwk_service.get_active_key()
        if not jwk_key:
            raise RuntimeError("No active JWK key available")

        private_key_pem = jwk_service.decrypt_private_key(jwk_key.private_pem_encrypted)

        # jti
        access_jti = secrets.token_urlsafe(16)
        refresh_jti = secrets.token_urlsafe(16)

        # access token
        access_claims = {
            "iss": settings.ISSUER,
            "sub": str(user.id),
            "aud": client.client_id,
            "exp": ts(now + timedelta(seconds=settings.ACCESS_TOKEN_TTL)),
            "iat": ts(now),
            "jti": access_jti,
            "scope": scope,
            "client_id": client.client_id,
        }
        if session_id:
            access_claims["sid"] = session_id

        access_token = jwt.encode(
            access_claims,
            private_key_pem,
            algorithm="RS256",
            headers={"kid": jwk_key.kid},
        )

        # id token РїСЂРё scope openid
        id_token: Optional[str] = None
        if "openid" in scopes:
            id_claims = {
                "iss": settings.ISSUER,
                "sub": str(user.id),
                "aud": client.client_id,
                "exp": ts(now + timedelta(seconds=settings.ACCESS_TOKEN_TTL)),
                "iat": ts(now),
                "auth_time": ts(auth_time),
            }
            if "email" in scopes:
                id_claims["email"] = user.email
                id_claims["email_verified"] = user.email_verified
            if "profile" in scopes:
                id_claims["preferred_username"] = user.username
            if nonce:
                id_claims["nonce"] = nonce
            if session_id:
                id_claims["sid"] = session_id

            # at_hash = left-most 128 bits of SHA-256(access_token), base64url Р±РµР· '='
            at_hash = hashlib.sha256(access_token.encode()).digest()[:16]
            import base64
            id_claims["at_hash"] = base64.urlsafe_b64encode(at_hash).decode().rstrip("=")

            id_token = jwt.encode(
                id_claims,
                private_key_pem,
                algorithm="RS256",
                headers={"kid": jwk_key.kid},
            )


        # refresh РїСЂРё offline_access
        refresh_token: Optional[str] = None
        if "offline_access" in scopes:
            refresh_token_obj = RefreshToken(
                jti=refresh_jti,
                user_id=user.id,
                client_id=client.client_id,
                scope=scope,
                created_at=now,
                expires_at=now + timedelta(seconds=settings.REFRESH_TOKEN_TTL),
                ip_address=ip_address,
                user_agent=user_agent,
            )
            session.add(refresh_token_obj)
            await session.flush()

            refresh_claims = {
                "iss": settings.ISSUER,
                "sub": str(user.id),
                "aud": client.client_id,
                "exp": ts(now + timedelta(seconds=settings.REFRESH_TOKEN_TTL)),
                "iat": ts(now),
                "jti": refresh_jti,
                "scope": scope,
                "token_type": "refresh",
            }
            refresh_token = jwt.encode(
                refresh_claims,
                private_key_pem,
                algorithm="RS256",
                headers={"kid": jwk_key.kid},
            )

        return {
            "access_token": access_token,
            "id_token": id_token,
            "refresh_token": refresh_token,
            "token_type": "Bearer",
            "expires_in": settings.ACCESS_TOKEN_TTL,
            "scope": scope,
        }

    async def rotate_refresh_token(
        self,
        session: AsyncSession,
        refresh_token: str,
        client_id: str,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
    ) -> Tuple[Optional[Dict[str, Any]], Optional[str]]:
        try:
            unverified = jwt.get_unverified_header(refresh_token)
            kid = unverified.get("kid")
            if not kid:
                return None, "invalid_grant"

            # Р‘РµСЂС‘Рј РєР»СЋС‡ РїРѕ kid
            result = await session.execute(select(JWKKey).where(JWKKey.kid == kid))
            jwk_key = result.scalar_one_or_none()
            if not jwk_key:
                return None, "invalid_grant"

            # Р’РµСЂРёС„РёС†РёСЂСѓРµРј С‚РѕРєРµРЅ
            private_key_pem = jwk_service.decrypt_private_key(jwk_key.private_pem_encrypted)
            claims = jwt.decode(
                refresh_token,
                private_key_pem,  # РґРѕРїСѓСЃС‚РёРјРѕ, РєР»СЋС‡ RSA РїСЂРёРІР°С‚РЅС‹Р№ СЃРѕРґРµСЂР¶РёС‚ РїСѓР±Р»РёС‡РЅСѓСЋ С‡Р°СЃС‚СЊ
                algorithms=["RS256"],
                audience=client_id,
                issuer=settings.ISSUER,
            )
            if claims.get("token_type") != "refresh":
                return None, "invalid_grant"

            jti = claims.get("jti")
            user_id = claims.get("sub")

            # Р›РѕС‡РёРј Р·Р°РїРёСЃСЊ СЂРµС„СЂРµС€Р°
            result = await session.execute(
                select(RefreshToken)
                .where(
                    and_(
                        RefreshToken.jti == jti,
                        RefreshToken.client_id == client_id,
                        RefreshToken.revoked_at.is_(None),
                    )
                )
                .with_for_update()
            )
            refresh_token_obj = result.scalar_one_or_none()

            if not refresh_token_obj:
                # РџСЂРѕРІРµСЂРєР° reuse
                result = await session.execute(select(RefreshToken).where(RefreshToken.jti == jti))
                used_token = result.scalar_one_or_none()
                if used_token:
                    logger.critical("Refresh reuse detected. user_id=%s client_id=%s", user_id, client_id)
                    await self._revoke_token_chain(session, used_token)
                    return None, "invalid_grant"
                return None, "invalid_grant"

            now = datetime.now(timezone.utc)

            # РџСЂРѕС‚СѓС…
            if refresh_token_obj.expires_at < now:
                refresh_token_obj.revoked_at = now
                refresh_token_obj.revoked_reason = "expired"
                await session.flush()
                return None, "invalid_grant"

            # РџРѕР»СѓС‡Р°РµРј СЃСѓС‰РЅРѕСЃС‚Рё РєРѕСЂСЂРµРєС‚РЅРѕ
            user = await session.get(User, user_id)
            # Р’РђР–РќРћ: Client РёС‰РµРј РїРѕ client_id, Р° РЅРµ РїРѕ PK
            cres = await session.execute(select(Client).where(Client.client_id == client_id))
            client = cres.scalar_one_or_none()
            if not user or not client:
                return None, "invalid_grant"

            # Р–С‘СЃС‚РєР°СЏ СЂРѕС‚Р°С†РёСЏ: СЃС‚Р°СЂС‹Р№ СЃСЂР°Р·Сѓ РЅРµРґРµР№СЃС‚РІРёС‚РµР»РµРЅ
            refresh_token_obj.rotated_at = now
            refresh_token_obj.revoked_at = now
            refresh_token_obj.revoked_reason = "rotated"


            # Р’С‹РїСѓСЃРєР°РµРј РЅРѕРІСѓСЋ РїР°С‡РєСѓ
            new_tokens = await self.create_tokens(
                session=session,
                user=user,
                client=client,
                scope=refresh_token_obj.scope,
                ip_address=ip_address,
                user_agent=user_agent,
            )

            # РЎРІСЏР·С‹РІР°РµРј С†РµРїРѕС‡РєСѓ
            if new_tokens.get("refresh_token"):
                new_jti = jwt.decode(new_tokens["refresh_token"], private_key_pem, algorithms=["RS256"])["jti"]
                res2 = await session.execute(select(RefreshToken).where(RefreshToken.jti == new_jti))
                new_refresh_obj = res2.scalar_one()
                new_refresh_obj.parent_jti = refresh_token_obj.jti
                new_refresh_obj.prev_jti = refresh_token_obj.jti

            await session.flush()
            return new_tokens, None

        except JWTError as e:
            logger.warning("JWT error during refresh: %s", e)
            return None, "invalid_grant"
        except Exception as e:
            logger.error("Error rotating refresh token: %s", e)
            return None, "server_error"

    async def revoke_refresh_token(
        self,
        session: AsyncSession,
        refresh_token: str,
        client_id: str,
        reason: str = "revoked_by_client",
    ) -> None:
        """
        RFC 7009: РѕС‚Р·С‹РІ refresh С‚РѕРєРµРЅР°. Р‘РµР·Р±РѕР»РµР·РЅРµРЅРЅРѕ РІРѕР·РІСЂР°С‰Р°РµС‚ 200 РґР°Р¶Рµ РµСЃР»Рё С‚РѕРєРµРЅ РЅРµРІР°Р»РёРґРµРЅ.
        РњС‹ РѕС‚Р·С‹РІРµРј СЃР°Рј С‚РѕРєРµРЅ Рё РІСЃРµС… РµРіРѕ РїРѕС‚РѕРјРєРѕРІ РїРѕ С†РµРїРѕС‡РєРµ parent_jti.
        """
        try:
            # Р’С‹С‡РёСЃР»СЏРµРј РєР»СЋС‡ РїРѕ kid Рё РІР°Р»РёРґРёСЂСѓРµРј С‚РѕРєРµРЅ
            unverified = jwt.get_unverified_header(refresh_token)
            kid = unverified.get("kid")
            if not kid:
                return

            res = await session.execute(select(JWKKey).where(JWKKey.kid == kid))
            jwk_key = res.scalar_one_or_none()
            if not jwk_key:
                return

            private_key_pem = jwk_service.decrypt_private_key(jwk_key.private_pem_encrypted)
            claims = jwt.decode(
                refresh_token,
                private_key_pem,  # РІР°Р»РёРґРЅРѕ: РїСЂРёРІР°С‚РЅС‹Р№ РєР»СЋС‡ СЃРѕРґРµСЂР¶РёС‚ РїСѓР±Р»РёС‡РЅСѓСЋ С‡Р°СЃС‚СЊ
                algorithms=["RS256"],
                audience=client_id,
                issuer=settings.ISSUER,
            )
            jti = claims.get("jti")
            if not jti:
                return

            # РќР°С…РѕРґРёРј СЃР°Рј С‚РѕРєРµРЅ
            result = await session.execute(
                select(RefreshToken)
                .where(
                    and_(
                        RefreshToken.jti == jti,
                        RefreshToken.client_id == client_id,
                    )
                )
                .with_for_update()
            )
            root = result.scalar_one_or_none()
            if not root:
                return

            now = datetime.now(timezone.utc)

            # РЎРѕР±РёСЂР°РµРј РІСЃРµС… РїРѕС‚РѕРјРєРѕРІ (С€РёСЂРѕРєРёР№ РїРѕРёСЃРє РїРѕ parent_jti)
            to_revoke = [root]
            queue = [root.jti]
            seen = set([root.jti])
            while queue:
                cur = queue.pop(0)
                res = await session.execute(select(RefreshToken).where(RefreshToken.parent_jti == cur))
                children = res.scalars().all()
                for c in children:
                    if c.jti not in seen:
                        seen.add(c.jti)
                        to_revoke.append(c)
                        queue.append(c.jti)

            # РћС‚Р·С‹РІР°РµРј
            for t in to_revoke:
                if not t.revoked_at:
                    t.revoked_at = now
                    t.revoked_reason = reason

            await session.flush()

        except JWTError:
            return
        except Exception:
            logger.exception("Error during refresh token revocation")
            return


    async def _revoke_token_chain(self, session: AsyncSession, token: RefreshToken) -> None:
        """
        РћС‚РѕР·РІР°С‚СЊ РІСЃСЋ С†РµРїРѕС‡РєСѓ refresh РїСЂРё reuse. РџР»СЋСЃ SSO Рё back-channel РґР»СЏ СЃРѕРѕС‚РІРµС‚СЃС‚РІСѓСЋС‰РµРіРѕ РєР»РёРµРЅС‚Р°.
        """
        now = datetime.now(timezone.utc)

        # СЃРѕР±РёСЂР°РµРј РІСЃСЋ С†РµРїРѕС‡РєСѓ РІРІРµСЂС… РїРѕ parent_jti
        tokens_to_revoke = []
        current = token
        while current.parent_jti:
            result = await session.execute(select(RefreshToken).where(RefreshToken.jti == current.parent_jti))
            parent = result.scalar_one_or_none()
            if parent:
                tokens_to_revoke.append(parent)
                current = parent
            else:
                break

        # Рё РІРЅРёР· РїРѕ РїРѕС‚РѕРјРєР°Рј
        result = await session.execute(select(RefreshToken).where(RefreshToken.parent_jti == token.jti))
        children = result.scalars().all()
        tokens_to_revoke.extend(children)

        tokens_to_revoke.append(token)
        for t in tokens_to_revoke:
            if not t.revoked_at:
                t.revoked_at = now
                t.revoked_reason = "token_reuse_detected"
        await session.flush()

        # РѕС‚Р·С‹РІР°РµС‚ РІСЃРµ IdP-СЃРµСЃСЃРёРё РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ (РїРѕРєР° РіР»РѕР±Р°Р»СЊРЅРѕ)
        await session_service.revoke_all_user_sessions(session, token.user_id)

        # back-channel С‚РѕС‡РµС‡РЅРѕ РїРѕ РєР»РёРµРЅС‚Сѓ С‚РѕРєРµРЅР°
        user = await session.get(User, token.user_id)
        try:
            await backchannel_logout_service.initiate_backchannel_logout(
                session=session,
                user=user,
                session_id=None,
                reason="refresh_reuse",
                only_client_id=token.client_id,
            )
        except Exception as e:
            logger.error("Back-channel during revoke chain failed: %s", e)

    async def verify_access_token(
        self,
        token: str,
        required_scope: Optional[str] = None,
    ) -> Optional[Dict[str, Any]]:
        """
        Р’РµСЂРёС„РёРєР°С†РёСЏ access: РїРѕРґРїРёСЃСЊ, iss. aud РѕРїС†РёРѕРЅР°Р»СЊРЅРѕ. РџСЂРѕРІРµСЂРєР° С‚СЂРµР±СѓРµРјРѕРіРѕ scope.
        """
        try:
            hdr = jwt.get_unverified_header(token)
            kid = hdr.get("kid")
            async with async_session_maker() as s:
                res = await s.execute(select(JWKKey).where(JWKKey.kid == kid))
                jwk_key = res.scalar_one_or_none()
                if not jwk_key:
                    return None
                public_key = _load_public_key(jwk_key.public_pem)
                claims = jwt.decode(
                    token,
                    public_key,
                    algorithms=["RS256"],
                    issuer=settings.ISSUER,
                    options={"verify_aud": False},
                )
            if required_scope and required_scope not in claims.get("scope", "").split():
                return None
            return claims
        except JWTError:
            return None

    async def revoke_all_refresh_tokens_for_user(
        self,
        session: AsyncSession,
        user_id: str,
        client_id: Optional[str] = None,
        reason: str = "user_action",
    ) -> list[str]:
        """
        РћС‚РѕР·РІР°С‚СЊ РІСЃРµ Р°РєС‚РёРІРЅС‹Рµ refresh С‚РѕРєРµРЅС‹ РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ.
        Р’РѕР·РІСЂР°С‰Р°РµС‚ СЃРїРёСЃРѕРє client_id, Сѓ РєРѕС‚РѕСЂС‹С… Р±С‹Р»Рё Р°РєС‚РёРІРЅС‹Рµ С‚РѕРєРµРЅС‹.
        """
        now = datetime.now(timezone.utc)
        q = select(RefreshToken).where(
            and_(
                RefreshToken.user_id == user_id,
                RefreshToken.revoked_at.is_(None),
                RefreshToken.expires_at > now,
            )
        )
        if client_id:
            q = q.where(RefreshToken.client_id == client_id)

        res = await session.execute(q)
        tokens = res.scalars().all()

        affected = set()
        for t in tokens:
            t.revoked_at = now
            t.revoked_reason = reason
            affected.add(t.client_id)

        await session.flush()
        return list(affected)


token_service = TokenService()



/* ===== C:\Users\icipa\team-platform-public\id_service\utils\__init__.py ===== */

# id_service/utils/__init__.py

from .validators import validators
from .rate_limit import rate_limiter
from .otp import otp_service
from .csrf import csrf_protection
from .logging_config import setup_logging

__all__ = [
    "validators",
    "rate_limiter", 
    "otp_service",
    "csrf_protection",
    "setup_logging"
]


/* ===== C:\Users\icipa\team-platform-public\id_service\utils\csrf.py ===== */

# id_service/utils/csrf.py

import hmac
import hashlib
import secrets
from typing import Optional
from fastapi import Depends, Request, HTTPException, status

from core.config import settings


class CSRFProtection:
    """CSRF protection using double-submit cookie pattern"""
    
    def __init__(self):
        self.cookie_name = "csrf_token"
        self.header_name = "X-CSRF-Token"
        self.form_field = "csrf_token"
    
    def generate_token(self) -> str:
        """Generate CSRF token"""
        return secrets.token_urlsafe(32)
    
    async def validate_token(
        self,
        request: Request,
        cookie_token: Optional[str] = None,
        submitted_token: Optional[str] = None
    ) -> bool:
        """
        Validate CSRF token
        
        Args:
            request: FastAPI request
            cookie_token: Token from cookie (if not in request)
            submitted_token: Token from header/form (if not in request)
            
        Returns:
            True if valid, raises HTTPException if invalid
        """
        
        
        # Get token from cookie
        if cookie_token is None:
            cookie_token = request.cookies.get(self.cookie_name)

        if not cookie_token:
            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="CSRF cookie not found")

        if submitted_token is None:
            submitted_token = request.headers.get(self.header_name)

            if not submitted_token and request.method in {"POST", "PUT", "PATCH", "DELETE"}:
                try:
                    form = await request.form()
                    submitted_token = form.get(self.form_field)
                except Exception:
                    submitted_token = None

        if not submitted_token:
            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="CSRF token not provided")

        if not hmac.compare_digest(cookie_token, submitted_token):
            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Invalid CSRF token")

        return True
    
    def should_check_csrf(self, request: Request) -> bool:
        if request.method in {"GET", "HEAD", "OPTIONS"}:
            return False
        path = request.url.path
        if path in {
            "/token", "/revoke", "/auth/csrf",
            "/.well-known/openid-configuration", "/.well-known/jwks.json",
            "/health", "/health/ready",
        }:
            return False
        auth_header = request.headers.get("Authorization", "")
        if auth_header.startswith("Bearer "):
            return False
        return True



csrf_protection = CSRFProtection()


/* ===== C:\Users\icipa\team-platform-public\id_service\utils\email_sender.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\utils\jwt_utils.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\utils\logging_config.py ===== */

# id_service/utils/logging_config.py

import logging
import sys
from typing import Any, Dict
import json
from datetime import datetime

from core.config import settings


class JSONFormatter(logging.Formatter):
    """JSON log formatter for structured logging"""
    
    def format(self, record: logging.LogRecord) -> str:
        log_obj = {
            "timestamp": datetime.utcnow().isoformat(),
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage(),
            "module": record.module,
            "function": record.funcName,
            "line": record.lineno
        }
        
        # Add extra fields
        if hasattr(record, 'user_id'):
            log_obj['user_id'] = record.user_id
        if hasattr(record, 'client_id'):
            log_obj['client_id'] = record.client_id
        if hasattr(record, 'ip_address'):
            log_obj['ip_address'] = record.ip_address
        if hasattr(record, 'trace_id'):
            log_obj['trace_id'] = record.trace_id
        
        # Add exception info if present
        if record.exc_info:
            log_obj['exception'] = self.formatException(record.exc_info)
        
        return json.dumps(log_obj)


def setup_logging():
    """Configure application logging"""
    
    # Set log level based on environment
    log_level = logging.DEBUG if settings.APP_ENV == "development" else logging.INFO
    
    # Create handlers
    console_handler = logging.StreamHandler(sys.stdout)
    
    # Set formatter based on environment
    if settings.APP_ENV == "production":
        formatter = JSONFormatter()
    else:
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
    
    console_handler.setFormatter(formatter)
    
    # Configure root logger
    root_logger = logging.getLogger()
    root_logger.setLevel(log_level)
    root_logger.addHandler(console_handler)
    
    # Silence noisy libraries
    logging.getLogger("uvicorn.access").setLevel(logging.WARNING)
    logging.getLogger("httpx").setLevel(logging.WARNING)
    
    return root_logger


/* ===== C:\Users\icipa\team-platform-public\id_service\utils\otp.py ===== */

# id_service/utils/otp.py

import hashlib
import hmac
import secrets
import string
from datetime import datetime, timezone, timedelta
from typing import Optional, Tuple
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_

from models import EmailCode, EmailCodePurpose, User
from core.config import settings
from core.security import security

import logging
logger = logging.getLogger(__name__)


class OTPService:
    """Service for managing OTP codes"""
    
    async def create_otp(
        self,
        session: AsyncSession,
        user: User,
        purpose: EmailCodePurpose,
        new_email: Optional[str] = None,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None
    ) -> Tuple[str, EmailCode]:
        """Create new OTP code"""
        
        # Check for existing active code
        now = datetime.now(timezone.utc)
        result = await session.execute(
            select(EmailCode).where(
                and_(
                    EmailCode.user_id == user.id,
                    EmailCode.purpose == purpose,
                    EmailCode.expires_at > now,
                    EmailCode.used_at.is_(None)
                )
            )
        )
        existing_code = result.scalar_one_or_none()
        
        if existing_code:
            # Check resend cooldown
            if existing_code.resend_after > now:
                seconds_left = int((existing_code.resend_after - now).total_seconds())
                raise ValueError(f"Please wait {seconds_left} seconds before requesting a new code")
            
            # Invalidate old code
            existing_code.used_at = now
        
        # Generate new OTP
        otp = security.generate_otp(4)
        otp_hash = security.hash_otp(otp)
        
        # Create email code record
        email_code = EmailCode(
            user_id=user.id,
            purpose=purpose,
            code_hash=otp_hash,
            new_email=new_email,
            expires_at=now + timedelta(seconds=settings.OTP_TTL),
            resend_after=now + timedelta(seconds=settings.OTP_RESEND_SECONDS),
            attempts=0,
            ip_address=ip_address,
            user_agent=user_agent
        )
        
        session.add(email_code)
        await session.flush()
        
        logger.info(f"Created OTP for user {user.id} with purpose {purpose}")
        return otp, email_code
    
    async def verify_otp(
        self,
        session: AsyncSession,
        user_id: str,
        code: str,
        purpose: EmailCodePurpose
    ) -> Tuple[bool, Optional[EmailCode], Optional[str]]:
        """
        Verify OTP code
        
        Returns:
            Tuple of (success, email_code if valid, error_message if invalid)
        """
        now = datetime.now(timezone.utc)
        
        # Find active code
        result = await session.execute(
            select(EmailCode).where(
                and_(
                    EmailCode.user_id == user_id,
                    EmailCode.purpose == purpose,
                    EmailCode.expires_at > now,
                    EmailCode.used_at.is_(None)
                )
            ).with_for_update()
        )
        email_code = result.scalar_one_or_none()
        
        if not email_code:
            return False, None, "No valid code found"
        
        # Check attempts
        email_code.attempts += 1
        
        if email_code.attempts > settings.OTP_MAX_ATTEMPTS:
            email_code.used_at = now  # Invalidate code
            await session.flush()
            return False, None, "Too many attempts. Please request a new code"
        
        # Verify code with constant time comparison
        code_hash = security.hash_otp(code)
        if not security.constant_time_compare(code_hash, email_code.code_hash):
            await session.flush()
            attempts_left = settings.OTP_MAX_ATTEMPTS - email_code.attempts
            return False, None, f"Invalid code. {attempts_left} attempts remaining"
        
        # Mark as used
        email_code.used_at = now
        await session.flush()
        
        logger.info(f"Successfully verified OTP for user {user_id} with purpose {purpose}")
        return True, email_code, None
    
    async def cleanup_expired_codes(
        self,
        session: AsyncSession
    ) -> int:
        """Clean up expired OTP codes (for maintenance)"""
        cutoff_date = datetime.now(timezone.utc) - timedelta(days=1)
        
        result = await session.execute(
            select(EmailCode).where(
                EmailCode.expires_at < cutoff_date
            )
        )
        expired_codes = result.scalars().all()
        
        for code in expired_codes:
            session.delete(code)
        
        await session.flush()
        
        count = len(expired_codes)
        if count > 0:
            logger.info(f"Cleaned up {count} expired OTP codes")
        
        return count


otp_service = OTPService()


/* ===== C:\Users\icipa\team-platform-public\id_service\utils\pkce.py ===== */



/* ===== C:\Users\icipa\team-platform-public\id_service\utils\rate_limit.py ===== */

# id_service/utils/rate_limit.py

import hashlib
import logging
from typing import Optional
from fastapi import Request, HTTPException, status
import redis.asyncio as redis
from datetime import timedelta

from core.config import settings

logger = logging.getLogger(__name__)


class RateLimiter:
    """Rate limiting implementation using Redis"""
    
    def __init__(self):
        self.redis_client: Optional[redis.Redis] = None
        self.enabled = settings.RATE_LIMIT_ENABLED
        
    async def init(self):
        """Initialize Redis connection"""
        if self.enabled:
            try:
                self.redis_client = redis.from_url(
                    settings.REDIS_URL,
                    encoding="utf-8",
                    decode_responses=True
                )
                await self.redis_client.ping()
                logger.info("Rate limiter initialized")
            except Exception as e:
                logger.error(f"Failed to initialize rate limiter: {e}")
                self.enabled = False
    
    async def close(self):
        """Close Redis connection"""
        if self.redis_client:
            await self.redis_client.close()
    
    def _get_key(self, request: Request, action: str) -> str:
        """Generate rate limit key"""
        client_ip = request.client.host
        # Include action in key for different limits per action
        raw_key = f"rate_limit:{action}:{client_ip}"
        # Hash for privacy
        return hashlib.sha256(raw_key.encode()).hexdigest()
    
    async def check_rate_limit(
        self,
        request: Request,
        action: str = "general",
        max_requests: Optional[int] = None,
        window_seconds: int = 60
    ) -> bool:
        """
        Check if request should be rate limited
        
        Args:
            request: FastAPI request
            action: Action identifier (login, register, etc.)
            max_requests: Maximum requests allowed
            window_seconds: Time window in seconds
            
        Returns:
            True if request is allowed, raises HTTPException if limited
        """
        if not self.enabled or not self.redis_client:
            return True
        
        max_requests = max_requests or settings.RATE_LIMIT_REQUESTS_PER_MINUTE
        key = self._get_key(request, action)
        
        try:
            # Use Redis pipeline for atomic operations
            async with self.redis_client.pipeline() as pipe:
                # Get current count
                current_count = await self.redis_client.get(key)
                
                if current_count is None:
                    # First request, set key with expiry
                    await pipe.setex(key, window_seconds, 1)
                    await pipe.execute()
                    return True
                
                current_count = int(current_count)
                
                if current_count >= max_requests:
                    # Rate limit exceeded
                    ttl = await self.redis_client.ttl(key)
                    raise HTTPException(
                        status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                        detail=f"Rate limit exceeded. Try again in {ttl} seconds.",
                        headers={"Retry-After": str(ttl)}
                    )
                
                # Increment counter
                await self.redis_client.incr(key)
                return True
                
        except HTTPException:
            raise
        except Exception as e:
            logger.error(f"Rate limit check failed: {e}")
            # Fail open - allow request if rate limiting fails
            return True
    
    async def add_failed_attempt(
        self,
        identifier: str,
        action: str = "login",
        max_attempts: int = 5,
        lockout_seconds: int = 900  # 15 minutes
    ) -> None:
        """
        Track failed attempts for an identifier (email, username, etc.)
        
        Args:
            identifier: Unique identifier to track
            action: Type of action (login, otp_verify, etc.)
            max_attempts: Maximum attempts before lockout
            lockout_seconds: Lockout duration in seconds
        """
        if not self.enabled or not self.redis_client:
            return
        
        key = f"failed_attempts:{action}:{hashlib.sha256(identifier.encode()).hexdigest()}"
        lockout_key = f"{key}:locked"
        
        try:
            # Check if already locked out
            is_locked = await self.redis_client.get(lockout_key)
            if is_locked:
                ttl = await self.redis_client.ttl(lockout_key)
                raise HTTPException(
                    status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                    detail=f"Account temporarily locked. Try again in {ttl} seconds.",
                    headers={"Retry-After": str(ttl)}
                )
            
            # Increment failed attempts
            attempts = await self.redis_client.incr(key)
            
            # Set expiry on first attempt
            if attempts == 1:
                await self.redis_client.expire(key, lockout_seconds)
            
            # Check if should lock out
            if attempts >= max_attempts:
                await self.redis_client.setex(lockout_key, lockout_seconds, "1")
                await self.redis_client.delete(key)
                
                raise HTTPException(
                    status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                    detail=f"Too many failed attempts. Account locked for {lockout_seconds // 60} minutes.",
                    headers={"Retry-After": str(lockout_seconds)}
                )
                
        except HTTPException:
            raise
        except Exception as e:
            logger.error(f"Failed to track failed attempt: {e}")
    
    async def clear_failed_attempts(
        self,
        identifier: str,
        action: str = "login"
    ) -> None:
        """Clear failed attempts for an identifier after successful action"""
        if not self.enabled or not self.redis_client:
            return
        
        key = f"failed_attempts:{action}:{hashlib.sha256(identifier.encode()).hexdigest()}"
        lockout_key = f"{key}:locked"
        
        try:
            await self.redis_client.delete(key, lockout_key)
        except Exception as e:
            logger.error(f"Failed to clear failed attempts: {e}")


# Global instance
rate_limiter = RateLimiter()


/* ===== C:\Users\icipa\team-platform-public\id_service\utils\validators.py ===== */

# id_service/utils/validators.py

import re
import secrets
import string
from typing import Optional, Tuple, List
from email_validator import validate_email, EmailNotValidError
from urllib.parse import urlparse

from core.config import settings


class Validators:
    """Input validation utilities"""
    
    @staticmethod
    def validate_email(email: str) -> Tuple[bool, Optional[str]]:
        """Validate email address"""
        try:
            # Validate and normalize
            validation = validate_email(email)
            return True, validation.email.lower()
        except EmailNotValidError as e:
            return False, str(e)
    
    @staticmethod
    def validate_username(username: str) -> Tuple[bool, str]:
        """
        Validate username
        - 3-30 characters
        - Alphanumeric, underscore, hyphen
        - Must start with letter
        """
        if not username:
            return False, "Username is required"
        
        if len(username) < 3:
            return False, "Username must be at least 3 characters"
        
        if len(username) > 30:
            return False, "Username must be at most 30 characters"
        
        if not username[0].isalpha():
            return False, "Username must start with a letter"
        
        if not re.match(r'^[a-zA-Z][a-zA-Z0-9_-]*$', username):
            return False, "Username can only contain letters, numbers, underscore and hyphen"
        
        # Check for reserved usernames
        reserved = ['admin', 'root', 'api', 'oauth', 'oidc', 'auth', 'account', 'id', 'login', 'register']
        if username.lower() in reserved:
            return False, "This username is reserved"
        
        return True, ""
    
    @staticmethod
    def validate_redirect_uri(uri: str, allowed_uris: List[str]) -> bool:
        """
        Validate redirect URI against whitelist
        Exact match required for security
        """
        if not uri or not allowed_uris:
            return False
        
        # Exact match required
        return uri in allowed_uris
    
    @staticmethod
    def validate_scope(scope: str) -> Tuple[bool, str]:
        """Validate OAuth2 scope"""
        if not scope:
            return False, "Scope is required"
        
        allowed_scopes = ["openid", "email", "profile", "offline_access"]
        requested_scopes = scope.split()
        
        for s in requested_scopes:
            if s not in allowed_scopes:
                return False, f"Invalid scope: {s}"
        
        return True, ""
    
    @staticmethod
    def validate_pkce_verifier(verifier: str) -> Tuple[bool, str]:
        """
        Validate PKCE code verifier
        - 43-128 characters
        - URL-safe characters only
        """
        if not verifier:
            return False, "Code verifier is required"
        
        if len(verifier) < 43:
            return False, "Code verifier too short (min 43 characters)"
        
        if len(verifier) > 128:
            return False, "Code verifier too long (max 128 characters)"
        
        # Check characters (RFC 7636)
        allowed = string.ascii_letters + string.digits + '-._~'
        if not all(c in allowed for c in verifier):
            return False, "Code verifier contains invalid characters"
        
        return True, ""
    
    @staticmethod
    def validate_state(state: str) -> Tuple[bool, str]:
        """Validate OAuth2 state parameter"""
        if not state:
            return True, ""  # State is optional
        
        if len(state) > 500:
            return False, "State parameter too long"
        
        # Check for potentially malicious content
        if '<' in state or '>' in state or 'javascript:' in state.lower():
            return False, "Invalid state parameter"
        
        return True, ""
    
    @staticmethod
    def validate_nonce(nonce: str) -> Tuple[bool, str]:
        """Validate OIDC nonce parameter"""
        if not nonce:
            return True, ""  # Nonce is optional
        
        if len(nonce) > 255:
            return False, "Nonce too long"
        
        # Should be unguessable
        if len(nonce) < 8:
            return False, "Nonce too short for security"
        
        return True, ""
    
    @staticmethod
    def sanitize_user_agent(user_agent: Optional[str]) -> str:
        """Sanitize user agent string for storage"""
        if not user_agent:
            return ""
        
        # Truncate if too long
        if len(user_agent) > 500:
            user_agent = user_agent[:500]
        
        # Remove any control characters
        return ''.join(c for c in user_agent if c.isprintable())
    
    @staticmethod
    def is_safe_url(url: str, allowed_hosts: Optional[List[str]] = None) -> bool:
        """Check if URL is safe for redirect"""
        if not url:
            return False
        
        try:
            parsed = urlparse(url)
            
            # Reject URLs with potentially dangerous schemes
            if parsed.scheme and parsed.scheme not in ['http', 'https']:
                return False
            
            # If no host specified, it's a relative URL (safe)
            if not parsed.netloc:
                return True
            
            # Check against allowed hosts if provided
            if allowed_hosts:
                return parsed.netloc in allowed_hosts
            
            return True
            
        except Exception:
            return False


validators = Validators()
